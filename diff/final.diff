diff -ru final2/arch/arm/common/cpaccess.c ics/arch/arm/common/cpaccess.c
--- final2/arch/arm/common/cpaccess.c	2014-08-29 08:20:15.288248000 +0200
+++ ics/arch/arm/common/cpaccess.c	2013-04-19 11:37:14.000000000 +0200
@@ -320,30 +320,22 @@
 {
 	int error = sysdev_class_register(&cpaccess_sysclass);
 
-	if (!error) {
+	if (!error)
 		error = sysdev_register(&device_cpaccess);
-	} else {
+	else
 		pr_err("Error initializing cpaccess interface\n");
-		return error;
-	}
 
 	if (!error)
 		error = sysdev_create_file(&device_cpaccess,
 		 &attr_cp_rw);
 	else {
 		pr_err("Error initializing cpaccess interface\n");
-		sysdev_class_unregister(&cpaccess_sysclass);
-		return error;
-	}
-
-	if (!error) {
-		sema_init(&cp_sem, 1);
-	} else {
-		pr_err("Error create cpaccess file interface\n");
 		sysdev_unregister(&device_cpaccess);
 		sysdev_class_unregister(&cpaccess_sysclass);
 	}
 
+	sema_init(&cp_sem, 1);
+
 	return error;
 }
 
Nur in ics/arch/arm/configs: exynos4_defconfig.
Nur in ics/arch/arm/configs: fsm9xxx_defconfig.
Nur in ics/arch/arm/configs: fsm9xxx-perf_defconfig.
Nur in final2/arch/arm/configs: kyle02_defconfig.
Nur in ics/arch/arm/configs: msm7627a_defconfig.
Nur in ics/arch/arm/configs: msm7627_defconfig.
Nur in ics/arch/arm/configs: msm7627-perf_defconfig.
Nur in ics/arch/arm/configs: msm7630_defconfig.
Nur in ics/arch/arm/configs: msm7630-perf_defconfig.
Nur in ics/arch/arm/configs: msm8660_defconfig.
Nur in ics/arch/arm/configs: msm8660-perf_defconfig.
Nur in ics/arch/arm/configs: msm8960_defconfig.
Nur in ics/arch/arm/configs: msm8960-perf_defconfig.
Nur in ics/arch/arm/configs: msm9615_defconfig.
Nur in ics/arch/arm/configs: msm-copper_defconfig.
Nur in ics/arch/arm/configs: mxs_defconfig.
Nur in ics/arch/arm/configs: omap1_defconfig.
Nur in ics/arch/arm/configs: omap2plus_defconfig.
Nur in ics/arch/arm/configs: pcontrol_g20_defconfig.
Nur in ics/arch/arm/configs: s5p64x0_defconfig.
Nur in ics/arch/arm/configs: spear3xx_defconfig.
Nur in ics/arch/arm/configs: spear6xx_defconfig.
Nur in ics/arch/arm/configs: tegra_defconfig.
Nur in ics/arch/arm/configs: vexpress_defconfig.
diff -ru final2/arch/arm/kernel/irq.c ics/arch/arm/kernel/irq.c
--- final2/arch/arm/kernel/irq.c	2014-08-29 08:16:09.392240000 +0200
+++ ics/arch/arm/kernel/irq.c	2013-04-19 11:37:14.000000000 +0200
@@ -43,7 +43,6 @@
 #include <asm/mach/time.h>
 
 #include <asm/perftypes.h>
-#include <linux/sec_debug.h>
 
 /*
  * No architecture-specific irq_finish function defined in arm/arch/irqs.h.
@@ -76,11 +75,6 @@
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
-#ifdef CONFIG_SEC_DEBUG_IRQ_EXIT_LOG
-	int cpu = smp_processor_id();
-	unsigned long long start_time = cpu_clock(cpu);
-#endif /* CONFIG_SEC_DEBUG_IRQ_EXIT_LOG */
-
 	perf_mon_interrupt_in();
 	irq_enter();
 
@@ -100,9 +94,6 @@
 	irq_finish(irq);
 
 	irq_exit();
-#ifdef CONFIG_SEC_DEBUG_IRQ_EXIT_LOG
-	sec_debug_irq_enterexit_log(irq, start_time);
-#endif /* CONFIG_SEC_DEBUG_IRQ_EXIT_LOG */
 	set_irq_regs(old_regs);
 	perf_mon_interrupt_out();
 }
diff -ru final2/arch/arm/kernel/traps.c ics/arch/arm/kernel/traps.c
--- final2/arch/arm/kernel/traps.c	2014-08-29 08:16:09.448240000 +0200
+++ ics/arch/arm/kernel/traps.c	2013-04-19 11:37:14.000000000 +0200
@@ -262,9 +262,6 @@
 /*
  * This function is protected against re-entrancy.
  */
-#ifdef CONFIG_SEC_DEBUG
-#include "../mach-msm/smd_private.h"
-#endif
 void die(const char *str, struct pt_regs *regs, int err)
 {
 	struct thread_info *thread = current_thread_info();
@@ -272,26 +269,6 @@
 	enum bug_trap_type bug_type = BUG_TRAP_TYPE_NONE;
 
 	oops_enter();
-#ifdef CONFIG_SEC_DEBUG
-	{
-		unsigned size;
-		samsung_vendor1_id *vendor1_id = (samsung_vendor1_id *)\
-			smem_get_entry(SMEM_ID_VENDOR1, &size);
-
-		/*error message */
-		memcpy(&(vendor1_id->apps_dump.apps_string),\
-			(void *)str, strlen(str));
-		vendor1_id->apps_dump.apps_string[strlen(str) + 1] = '\0';
-
-		/* current process*/
-		memcpy(&(vendor1_id->apps_dump.apps_process),\
-			(void *)thread->task->comm, strlen(thread->task->comm));
-		vendor1_id->apps_dump.apps_process[strlen(thread->task->comm) + 1] = '\0';
-		vendor1_id->apps_dump.apps_pid = task_pid_nr(thread->task);
-		vendor1_id->apps_dump.apps  = 0xf0;
-	}
-#endif /* CONFIG_SEC_DEBUG */
-
 
 	raw_spin_lock_irq(&die_lock);
 	console_verbose();
diff -ru final2/arch/arm/mach-msm/acpuclock-7201.c ics/arch/arm/mach-msm/acpuclock-7201.c
--- final2/arch/arm/mach-msm/acpuclock-7201.c	2014-08-29 08:20:15.288248000 +0200
+++ ics/arch/arm/mach-msm/acpuclock-7201.c	2013-04-19 11:37:14.000000000 +0200
@@ -117,7 +117,6 @@
 static struct clock_state drv_state = { 0 };
 static struct clkctl_acpu_speed *acpu_freq_tbl;
 
-unsigned int acpuclk_max_rate;
 /*
  * ACPU freq tables used for different PLLs frequency combinations. The
  * correct table is selected during init.
@@ -536,8 +535,6 @@
 	int res, rc = 0;
 	unsigned int plls_enabled = 0, pll;
 
-	if (acpuclk_max_rate < rate)
-		acpuclk_max_rate = rate;
 	if (reason == SETRATE_CPUFREQ)
 		mutex_lock(&drv_state.lock);
 
diff -ru final2/arch/arm/mach-msm/acpuclock.h ics/arch/arm/mach-msm/acpuclock.h
--- final2/arch/arm/mach-msm/acpuclock.h	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/acpuclock.h	2013-04-19 11:37:14.000000000 +0200
@@ -90,7 +90,6 @@
  * @data: acpuclock API implementations and data
  */
 void acpuclk_register(struct acpuclk_data *data);
-extern unsigned int acpuclk_max_rate;
 
 /**
  * acpuclk_init() - acpuclock driver initialization function
Nur in final2/arch/arm/mach-msm: board-amazing.c.
Nur in final2/arch/arm/mach-msm: board-amazing_cdma.c.
Nur in final2/arch/arm/mach-msm: board-amazing-cdma-modems.c.
Nur in final2/arch/arm/mach-msm: board-amazing-modems.c.
Nur in final2/arch/arm/mach-msm: board-kyle.c.
Nur in final2/arch/arm/mach-msm: board-kyle-modems.c.
diff -ru final2/arch/arm/mach-msm/board-msm7627a-bt.c ics/arch/arm/mach-msm/board-msm7627a-bt.c
--- final2/arch/arm/mach-msm/board-msm7627a-bt.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/board-msm7627a-bt.c	2013-04-19 11:37:14.000000000 +0200
@@ -24,27 +24,13 @@
 #include "board-msm7627a.h"
 #include "devices-msm7x2xa.h"
 
-/* SS_BLUETOOTH(taekyu.shin) 2012.03.26 */
-/* WCN2243 Bring-up, BT searching is available by this fix from qualcomm */
-#define GPIO_BLUETOOTH_LDO 82
-/* SS_BLUETOOTH(taekyu.shin) End */
-
-#define WLAN_33V_CONTROL_FOR_BT_ANTENNA
-
 #if defined(CONFIG_BT) && defined(CONFIG_MARIMBA_CORE)
 
-/* SS_BLUETOOTH(bg43.kim) 2012.03.21 */
-/* WCN2243 Bring-up, BT activation sucessful only for power-on process */
+
 static struct bt_vreg_info bt_vregs[] = {
 	{"msme1", 2, 1800000, 1800000, 0, NULL},
-#ifdef CONFIG_MACH_AMAZING_CDMA
-{"ldo18", 13, 3000000, 3000000, 0, NULL},
-#endif
+	{"bt", 21, 2900000, 3300000, 1, NULL}
 };
-/* SS_BLUETOOTH(bg43.kim) End */
-#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA
-#define WLAN_33V_BT_FLAG (0x02)
-#endif
 
 struct platform_device msm_bt_power_device = {
 	.name = "bt_power",
@@ -109,15 +95,12 @@
 	GPIO_CFG(71, 0, GPIO_CFG_INPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
 };
 
-/* SS_BLUETOOTH(bg43.kim) 2012.03.21 */
-/* WCN2243 Bring-up, BT activation sucessful only for power-on process */
-int gpio_bt_sys_rest_en = 34;
+int gpio_bt_sys_rest_en = 133;
 static void gpio_bt_config(void)
 {
 	if (machine_is_msm7627a_qrd1())
-		gpio_bt_sys_rest_en = 34;
+		gpio_bt_sys_rest_en = 114;
 }
-/* SS_BLUETOOTH(bg43.kim) End */
 
 static int bt_set_gpio(int on)
 {
@@ -672,41 +655,6 @@
 }
 
 static struct regulator *reg_s3;
-
-
-/* SS_BLUETOOTH(taekyu.shin) 2012.03.26 */
-/* WCN2243 Bring-up, BT searching is available by this fix from qualcomm */
-static int bluetooth_setup_ldo(unsigned gpio, int on)
-{
-	int rc = 0;
-
-	printk("%s - %d : %s\n", __func__, gpio, on ? "on" : "off");
-
-	// Request
-	if (gpio_request(gpio, "bt_en_gpio")) {
-		printk(KERN_ERR "%s: gpio_request for %d failed\n",
-				__func__, gpio);
-		return -1;
-	}
-	int temp = gpio_get_value(gpio);
-       printk( "%s:gpio_direction_output before(%d):: gpio_get_value=%d\n", __func__, on, temp);
-
-	rc = gpio_direction_output(gpio, on);
-
-        temp = gpio_get_value(gpio);
-       printk( "%s:gpio_direction_output after(%d):: gpio_get_value=%d\n", __func__, on, temp);
-
-	gpio_free(gpio);
-
-	if (rc) {
-		printk(KERN_ERR "%s: gpio_direction_output for %d failed\n",
-				__func__, gpio);
-		return -1;
-	}
-	return 0;
-}
-/* SS_BLUETOOTH(taekyu.shin) End */
-
 static unsigned int msm_bahama_setup_power(void)
 {
 	int rc = 0;
@@ -853,15 +801,7 @@
 		return -ENODEV;
 	}
 	if (on) {
-#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA
-		/* setup antenna configuration*/
-#ifdef CONFIG_MACH_AMAZING_CDMA
-		wlan_enable_ldo_33v(on);
-#else
-		wlan_setup_ldo_33v(WLAN_33V_BT_FLAG, 1);
-#endif
-#endif
-/*setup power for BT SOC*/
+		/*setup power for BT SOC*/
 		rc = bt_set_gpio(on);
 		if (rc) {
 			pr_err("%s: bt_set_gpio = %d\n",
@@ -874,20 +814,6 @@
 					__func__, rc);
 			goto exit;
 		}
-
-/* SS_BLUETOOTH(taekyu.shin) 2012.03.26 */
-/* WCN2243 Bring-up, BT searching is available by this fix from qualcomm */
-#ifndef CONFIG_MACH_AMAZING_CDMA
-		 if (bluetooth_setup_ldo(GPIO_BLUETOOTH_LDO,1))
-		 {
-					pr_err("%s: GPIO_BLUETOOTH_LDO fail = %d\n",
-							__func__, GPIO_BLUETOOTH_LDO);
-		   return -ENODEV;
-		  }
-			msleep(100);
-/* SS_BLUETOOTH(taekyu.shin) End */
-#endif
-				
 		/*setup BT GPIO lines*/
 		for (pin = 0; pin < ARRAY_SIZE(bt_config_power_on);
 			pin++) {
@@ -936,19 +862,6 @@
 		if (rc < 0)
 			pr_err("%s: bahama_bt rc = %d", __func__, rc);
 
-#ifndef CONFIG_MACH_AMAZING_CDMA
-/* SS_BLUETOOTH(taekyu.shin) 2012.03.26 */
-/* WCN2243 Bring-up, BT searching is available by this fix from qualcomm */
-		 if (bluetooth_setup_ldo(GPIO_BLUETOOTH_LDO,0))
-		 {
-					pr_err("%s: GPIO_BLUETOOTH_LDO fail = %d\n",
-							__func__, GPIO_BLUETOOTH_LDO);
-		   return -ENODEV;
-		  }
-			msleep(100);
-/* SS_BLUETOOTH(taekyu.shin) End */
-#endif
-
 		rc = msm_bahama_setup_pcm_i2s(BT_PCM_OFF);
 		if (rc < 0) {
 			pr_err("%s: msm_bahama_setup_pcm_i2s, rc =%d\n",
@@ -959,14 +872,6 @@
 			pr_err("%s: bt_set_gpio = %d\n",
 					__func__, rc);
 		}
-#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA
-		/* setup antenna configuration*/
-#ifdef CONFIG_MACH_AMAZING_CDMA
-		wlan_enable_ldo_33v(on);
-#else
-		wlan_setup_ldo_33v(WLAN_33V_BT_FLAG, 0);
-#endif
-#endif
 fail_i2c:
 		rc = pmapp_clock_vote(id, PMAPP_CLOCK_ID_D1,
 				  PMAPP_CLOCK_VOTE_OFF);
diff -ru final2/arch/arm/mach-msm/board-msm7627a-camera.c ics/arch/arm/mach-msm/board-msm7627a-camera.c
--- final2/arch/arm/mach-msm/board-msm7627a-camera.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/board-msm7627a-camera.c	2013-04-19 11:37:14.000000000 +0200
@@ -307,50 +307,11 @@
 };
 #else
 static uint32_t camera_off_gpio_table[] = {
-#ifdef CONFIG_MACH_AMAZING_CDMA
-	GPIO_CFG(15, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_4MA),
-	GPIO_CFG(96, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(85, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(107, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-
-#elif CONFIG_MACH_KYLE
-	GPIO_CFG(15, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_6MA),
-	GPIO_CFG(4, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(18, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(49, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(58, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(85, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(86, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(96, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(98, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(107, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-#else
-	GPIO_CFG(15, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_6MA),
-#endif
+	GPIO_CFG(15, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
 };
 
 static uint32_t camera_on_gpio_table[] = {
-#ifdef CONFIG_MACH_AMAZING_CDMA
-	GPIO_CFG(15, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_4MA),
-	GPIO_CFG(96, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(85, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(107, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-#elif CONFIG_MACH_KYLE
-	GPIO_CFG(15, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_6MA),
-	GPIO_CFG(4, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(18, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(49, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(58, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(85, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(86, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(96, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(98, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-	GPIO_CFG(107, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
-#elif CONFIG_MACH_AMAZING
-	GPIO_CFG(15, 0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_6MA),
-#else
-	GPIO_CFG(15, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_6MA),
-#endif
+	GPIO_CFG(15, 1, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA),
 };
 
 #ifdef CONFIG_MSM_CAMERA_FLASH
@@ -426,19 +387,19 @@
 
 static void msm_camera_vreg_config(int vreg_en)
 {
-	/*int rc = vreg_en ?
+	int rc = vreg_en ?
 		regulator_bulk_enable(ARRAY_SIZE(regs_camera), regs_camera) :
 		regulator_bulk_disable(ARRAY_SIZE(regs_camera), regs_camera);
 
 	if (rc)
 		pr_err("%s: could not %sable regulators: %d\n",
-				__func__, vreg_en ? "en" : "dis", rc);*/
+				__func__, vreg_en ? "en" : "dis", rc);
 }
 
 static int config_gpio_table(uint32_t *table, int len)
 {
 	int rc = 0, i = 0;
-	printk("####################config_gpio_table(\n");
+
 	for (i = 0; i < len; i++) {
 		rc = gpio_tlmm_config(table[i], GPIO_CFG_ENABLE);
 		if (rc) {
@@ -455,7 +416,7 @@
 static int config_camera_on_gpios_rear(void)
 {
 	int rc = 0;
-	printk("########################config_camera_on_gpios_rear\n");
+
 	if (machine_is_msm7x27a_ffa() || machine_is_msm7625a_ffa()
 				|| machine_is_msm7627a_qrd1())
 		msm_camera_vreg_config(1);
@@ -476,7 +437,7 @@
 	if (machine_is_msm7x27a_ffa() || machine_is_msm7625a_ffa()
 				|| machine_is_msm7627a_qrd1())
 		msm_camera_vreg_config(0);
-	printk("#################config_camera_off_gpios_rear\n");
+
 	config_gpio_table(camera_off_gpio_table,
 			ARRAY_SIZE(camera_off_gpio_table));
 }
@@ -564,142 +525,7 @@
 	},
 };
 #endif
-#if defined(CONFIG_S5K4ECGX) || defined(CONFIG_S5K4ECGX_KYLE)
-static struct msm_camera_sensor_platform_info s5k4ecgx_sensor_7627a_info = {
-	.mount_angle = 90
-};
-
-static struct msm_camera_sensor_flash_data flash_s5k4ecgx = {
-	.flash_type             = MSM_CAMERA_FLASH_LED,
-};
 
-static struct msm_camera_sensor_info msm_camera_sensor_s5k4ecgx_data = {
-	.sensor_name    = "s5k4ecgx",
-	.sensor_reset_enable = 0,
-	.vcm_enable             = 0,
-	.pdata                  = &msm_camera_device_data_rear,
-	.flash_data             = &flash_s5k4ecgx,
-	.sensor_platform_info   = &s5k4ecgx_sensor_7627a_info,
-	.csi_if                 = 1
-};
-
-static struct platform_device msm_camera_sensor_s5k4ecgx = {
-	.name   = "msm_camera_s5k4ecgx",
-	.dev    = {
-		.platform_data = &msm_camera_sensor_s5k4ecgx_data,
-	},
-};
-#endif
-#ifdef CONFIG_SR030PC50
-static struct msm_camera_sensor_platform_info sr030pc50_sensor_7627a_info = {
-	.mount_angle = 90
-};
-
-static struct msm_camera_sensor_flash_data flash_sr030pc50 = {
-	.flash_type             = MSM_CAMERA_FLASH_NONE,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_sr030pc50_data = {
-	.sensor_name    = "sr030pc50",
-	.sensor_reset_enable = 0,
-	.vcm_enable             = 0,
-	.pdata                  = &msm_camera_device_data_front,
-	.flash_data             = &flash_sr030pc50,
-	.sensor_platform_info   = &sr030pc50_sensor_7627a_info,
-	.csi_if                 = 1
-};
-
-static struct platform_device msm_camera_sensor_sr030pc50 = {
-	.name   = "msm_camera_sr030pc50",
-	.dev    = {
-		.platform_data = &msm_camera_sensor_sr030pc50_data,
-	},
-};
-#endif
-
-#ifdef CONFIG_S5K5CCGX
-static struct msm_camera_sensor_platform_info s5k5ccgx_sensor_7627a_info = {
-	.mount_angle = 90
-};
-
-static struct msm_camera_sensor_flash_data flash_s5k5ccgx = {
-	.flash_type             = MSM_CAMERA_FLASH_LED,
-//	.flash_src              = &msm_flash_src
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_s5k5ccgx_data = {
-	.sensor_name    = "s5k5ccgx",
-	.sensor_reset_enable = 0,
-	.vcm_enable             = 0,
-	.pdata                  = &msm_camera_device_data_rear,
-	.flash_data             = &flash_s5k5ccgx,
-	.sensor_platform_info   = &s5k5ccgx_sensor_7627a_info,
-	.csi_if                 = 1
-};
-
-static struct platform_device msm_camera_sensor_s5k5ccgx = {
-	.name   = "msm_camera_s5k5ccgx",
-	.dev    = {
-		.platform_data = &msm_camera_sensor_s5k5ccgx_data,
-	},
-};
-#endif
-
-#ifdef CONFIG_SR300PC20
-static struct msm_camera_sensor_platform_info sr300pc20_sensor_7627a_info = {
-	.mount_angle = 90
-};
-
-static struct msm_camera_sensor_flash_data flash_sr300pc20 = {
-	.flash_type             = MSM_CAMERA_FLASH_NONE,
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_sr300pc20_data = {
-	.sensor_name    = "sr300pc20",
-	.sensor_reset_enable = 0,
-	.vcm_enable             = 0,
-	.pdata                  = &msm_camera_device_data_rear,
-	.flash_data             = &flash_sr300pc20,
-	.sensor_platform_info = &sr300pc20_sensor_7627a_info,
-	.csi_if                 = 1
-
-};
-
-static struct platform_device msm_camera_sensor_sr300pc20 = {
-	.name   = "msm_camera_sr300pc20",
-	.dev    = {
-		.platform_data = &msm_camera_sensor_sr300pc20_data,
-	},
-};
-#endif
-
-#ifdef CONFIG_MT9V113
-static struct msm_camera_sensor_platform_info mt9v113_sensor_7627a_info = {
-	.mount_angle = 90
-};
-
-static struct msm_camera_sensor_flash_data flash_mt9v113 = {
-	.flash_type             = MSM_CAMERA_FLASH_NONE,
-//	.flash_src              = &msm_flash_src
-};
-
-static struct msm_camera_sensor_info msm_camera_sensor_mt9v113_data = {
-	.sensor_name    = "mt9v113",
-	.sensor_reset_enable = 0,
-	.vcm_enable             = 0,
-	.pdata                  = &msm_camera_device_data_front,
-	.flash_data             = &flash_mt9v113,
-	.sensor_platform_info   = &mt9v113_sensor_7627a_info,
-	.csi_if                 = 1 // 0: Parallel interface , 1: MIPI interface
-};
-
-static struct platform_device msm_camera_sensor_mt9v113 = {
-	.name   = "msm_camera_mt9v113",
-	.dev    = {
-		.platform_data = &msm_camera_sensor_mt9v113_data,
-	},
-};
-#endif
 #ifdef CONFIG_IMX072
 static struct msm_camera_sensor_platform_info imx072_sensor_7627a_info = {
 	.mount_angle = 90
@@ -887,31 +713,6 @@
 		I2C_BOARD_INFO("mt9e013", 0x6C >> 2),
 	},
 	#endif
-	#if defined(CONFIG_S5K4ECGX) || defined(CONFIG_S5K4ECGX_KYLE)
-	{
-		I2C_BOARD_INFO("s5k4ecgx", 0xAC >> 1),
-	},
-	#endif
-	#ifdef CONFIG_SR030PC50
-	{
-		I2C_BOARD_INFO("sr030pc50", 0x60>>1),
-	},
-	#endif
-	#ifdef CONFIG_S5K5CCGX
-	{
-		I2C_BOARD_INFO("s5k5ccgx", 0x5A >> 1),
-	},
-	#endif
-	#ifdef CONFIG_SR300PC20
-	{
-		I2C_BOARD_INFO("sr300pc20", 0x40>>1),
-	},
-	#endif
-	#ifdef CONFIG_MT9V113
-	{
-		I2C_BOARD_INFO("mt9v113", 0x7A >> 1),
-	},
-	#endif
 	{
 		I2C_BOARD_INFO("sc628a", 0x6E),
 	},
@@ -943,21 +744,6 @@
 #ifdef CONFIG_MT9E013
 	&msm_camera_sensor_mt9e013,
 #endif
-#if defined(CONFIG_S5K4ECGX) || defined(CONFIG_S5K4ECGX_KYLE)
-	&msm_camera_sensor_s5k4ecgx,
-#endif
-#ifdef CONFIG_SR030PC50
-	&msm_camera_sensor_sr030pc50,
-#endif
-#ifdef CONFIG_S5K5CCGX
-	&msm_camera_sensor_s5k5ccgx,
-#endif
-#ifdef CONFIG_SR300PC20
-	&msm_camera_sensor_sr300pc20,
-#endif
-#ifdef CONFIG_MT9V113
-	&msm_camera_sensor_mt9v113,
-#endif
 };
 
 static struct platform_device *camera_devices_qrd[] __initdata = {
@@ -994,7 +780,6 @@
 
 static void __init register_i2c_devices(void)
 {
-	printk("################ register_i2c_devices\n");
 	i2c_register_board_info(MSM_GSBI0_QUP_I2C_BUS_ID,
 				cam_exp_i2c_info,
 				ARRAY_SIZE(cam_exp_i2c_info));
@@ -1003,7 +788,6 @@
 void __init msm7627a_camera_init(void)
 {
 	int rc;
-	printk("##################kkkkkk msm7627a_camera_init\n");
 
 #ifndef CONFIG_MSM_CAMERA_V4L2
 	if (machine_is_msm7627a_qrd1()) {
@@ -1014,7 +798,6 @@
 		platform_add_devices(camera_devices_msm,
 				ARRAY_SIZE(camera_devices_msm));
 #endif
-/*
 	if (!machine_is_msm7627a_qrd1())
 		register_i2c_devices();
 	rc = regulator_bulk_get(NULL, ARRAY_SIZE(regs_camera), regs_camera);
@@ -1030,7 +813,6 @@
 		pr_err("%s: could not set voltages: %d\n", __func__, rc);
 		return;
 	}
-*/
 
 #if defined(CONFIG_MSM_CAMERA_V4L2)
 	msm7x27a_init_cam();
@@ -1045,5 +827,4 @@
 		i2c_register_board_info(MSM_GSBI0_QUP_I2C_BUS_ID,
 				i2c_camera_devices,
 				ARRAY_SIZE(i2c_camera_devices));
-		
 }
diff -ru final2/arch/arm/mach-msm/board-msm7627a.h ics/arch/arm/mach-msm/board-msm7627a.h
--- final2/arch/arm/mach-msm/board-msm7627a.h	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/board-msm7627a.h	2013-04-19 11:37:14.000000000 +0200
@@ -13,7 +13,6 @@
 #ifndef __ARCH_ARM_MACH_MSM_BOARD_7627A__
 #define __ARCH_ARM_MACH_MSM_BOARD_7627A__
 
-#define WLAN_33V_CONTROL_FOR_BT_ANTENNA
 #include "pm.h"
 void __init msm7627a_init_mmc(void);
 
@@ -103,13 +102,4 @@
 
 void __init msm7627a_camera_init(void);
 u32 msm7627a_power_collapse_latency(enum msm_pm_sleep_mode);
-#ifdef WLAN_33V_CONTROL_FOR_BT_ANTENNA
-#ifdef CONFIG_MACH_AMAZING_CDMA
-extern int wlan_enable_ldo_33v(int on);
-#else
-int wlan_setup_ldo_33v(int input_flag, int on);
 #endif
-extern void bluetooth_setup_ldo_33v(int on);
-#endif
-#endif
-
diff -ru final2/arch/arm/mach-msm/board-msm7x27a-regulator.c ics/arch/arm/mach-msm/board-msm7x27a-regulator.c
--- final2/arch/arm/mach-msm/board-msm7x27a-regulator.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/board-msm7x27a-regulator.c	2013-04-19 11:37:14.000000000 +0200
@@ -21,7 +21,7 @@
 #define n_ranges VOLTAGE_RANGE(750000, 1525000, 12500)
 
 #define s_ranges (VOLTAGE_RANGE(700000, 1500000, 12500) + \
-		VOLTAGE_RANGE(1500000, 3050000, 25000))
+			VOLTAGE_RANGE(1500000, 3050000, 25000))
 
 #define PCOM_VREG_CONSUMERS(name) \
 	static struct regulator_consumer_supply __pcom_vreg_supply_##name[]
@@ -38,7 +38,7 @@
 		.max_uV = _max_uV, \
 		.valid_modes_mask = REGULATOR_MODE_NORMAL, \
 		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | \
-		REGULATOR_CHANGE_STATUS, \
+				  REGULATOR_CHANGE_STATUS, \
 		.input_uV = _supply_uV, \
 		.apply_uV = _apply_uV, \
 		.boot_on = _boot_on, \
@@ -47,7 +47,7 @@
 }
 
 #define PCOM_VREG_SMP(_name, _id, _supply, _min_uV, _max_uV, _rise_time, \
-		_pulldown, _always_on, _boot_on, _apply_uV, _supply_uV, _range) \
+	_pulldown, _always_on, _boot_on, _apply_uV, _supply_uV, _range) \
 { \
 	.init_data = PCOM_VREG_INIT_DATA(_name, _supply, _min_uV, _max_uV, \
 			_always_on, _boot_on, _apply_uV, _supply_uV), \
@@ -64,7 +64,7 @@
 		_always_on, _boot_on, _apply_uV, _supply_uV) \
 { \
 	.init_data = PCOM_VREG_INIT_DATA(_name, _supply, -(_min_uV), \
-			-(_max_uV), _always_on, _boot_on, _apply_uV, _supply_uV), \
+		-(_max_uV), _always_on, _boot_on, _apply_uV, _supply_uV), \
 	.id = _id, \
 	.rise_time = _rise_time, \
 	.pulldown = -1, \
@@ -74,56 +74,45 @@
 PCOM_VREG_CONSUMERS(smps1) = {
 	REGULATOR_SUPPLY("smps1",	NULL),
 	REGULATOR_SUPPLY("msmc1",	NULL),
-	REGULATOR_SUPPLY("vreg_msmc1",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(smps2) = {
 	REGULATOR_SUPPLY("smps2",	NULL),
 	REGULATOR_SUPPLY("msmc2",	NULL),
-	REGULATOR_SUPPLY("vreg_msmc2",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(smps3) = {
 	REGULATOR_SUPPLY("smps3",	NULL),
 	REGULATOR_SUPPLY("msme1",	NULL),
-	REGULATOR_SUPPLY("vreg_pa",		NULL),
 };
 
 PCOM_VREG_CONSUMERS(smps4) = {
 	REGULATOR_SUPPLY("smps4",	NULL),
 	REGULATOR_SUPPLY("rf",		NULL),
-	REGULATOR_SUPPLY("vreg_msme",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo01) = {
 	REGULATOR_SUPPLY("ldo01",	NULL),
 	REGULATOR_SUPPLY("ldo1",	NULL),
 	REGULATOR_SUPPLY("rfrx1",	NULL),
-	REGULATOR_SUPPLY("vreg_vib",		NULL),
-	#ifdef CONFIG_MACH_AMAZING_CDMA
-	REGULATOR_SUPPLY("vcama",	NULL),
-	#endif
 };
 
 PCOM_VREG_CONSUMERS(ldo02) = {
 	REGULATOR_SUPPLY("ldo02",	NULL),
 	REGULATOR_SUPPLY("ldo2",	NULL),
 	REGULATOR_SUPPLY("rfrx2",	NULL),
-	REGULATOR_SUPPLY("vreg_rf",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo03) = {
 	REGULATOR_SUPPLY("ldo03",	NULL),
 	REGULATOR_SUPPLY("ldo3",	NULL),
 	REGULATOR_SUPPLY("mddi",	NULL),
-	REGULATOR_SUPPLY("vreg_msm_dsi",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo04) = {
 	REGULATOR_SUPPLY("ldo04",	NULL),
 	REGULATOR_SUPPLY("ldo4",	NULL),
 	REGULATOR_SUPPLY("pllx",	NULL),
-	REGULATOR_SUPPLY("vreg_msm_pll",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo05) = {
@@ -136,97 +125,74 @@
 	REGULATOR_SUPPLY("ldo06",	NULL),
 	REGULATOR_SUPPLY("ldo6",	NULL),
 	REGULATOR_SUPPLY("wlan3",	NULL),
-	REGULATOR_SUPPLY("vcamc",		NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo07) = {
 	REGULATOR_SUPPLY("ldo07",	NULL),
 	REGULATOR_SUPPLY("ldo7",	NULL),
 	REGULATOR_SUPPLY("msma",	NULL),
-	REGULATOR_SUPPLY("vreg_msma",		NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo08) = {
 	REGULATOR_SUPPLY("ldo08",	NULL),
 	REGULATOR_SUPPLY("ldo8",	NULL),
 	REGULATOR_SUPPLY("tcxo",	NULL),
-	REGULATOR_SUPPLY("vreg_tcxo",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo09) = {
 	REGULATOR_SUPPLY("ldo09",	NULL),
 	REGULATOR_SUPPLY("ldo9",	NULL),
 	REGULATOR_SUPPLY("usb2",	NULL),
-	REGULATOR_SUPPLY("vreg_usb18",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo10) = {
 	REGULATOR_SUPPLY("ldo10",	NULL),
 	REGULATOR_SUPPLY("emmc",	NULL),
-	REGULATOR_SUPPLY("vbt",		NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo11) = {
 	REGULATOR_SUPPLY("ldo11",	NULL),
 	REGULATOR_SUPPLY("wlan_tcx0",	NULL),
-	REGULATOR_SUPPLY("vreg_adc",		NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo12) = {
 	REGULATOR_SUPPLY("ldo12",	NULL),
 	REGULATOR_SUPPLY("gp2",		NULL),
-	REGULATOR_SUPPLY("vreg_msmp",		NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo13) = {
 	REGULATOR_SUPPLY("ldo13",	NULL),
 	REGULATOR_SUPPLY("mmc",		NULL),
-	REGULATOR_SUPPLY("vreg_tflash",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo14) = {
 	REGULATOR_SUPPLY("ldo14",	NULL),
 	REGULATOR_SUPPLY("usb",		NULL),
-	REGULATOR_SUPPLY("vreg_usb30",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo15) = {
 	REGULATOR_SUPPLY("ldo15",	NULL),
 	REGULATOR_SUPPLY("usim2",	NULL),
-	REGULATOR_SUPPLY("vcamio",		NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo16) = {
 	REGULATOR_SUPPLY("ldo16",	NULL),
 	REGULATOR_SUPPLY("ruim",	NULL),
-	REGULATOR_SUPPLY("vreg_usim",		NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo17) = {
 	REGULATOR_SUPPLY("ldo17",	NULL),
-#ifdef CONFIG_MACH_AMAZING_CDMA
-	REGULATOR_SUPPLY("wlan",		NULL),
-#else
-REGULATOR_SUPPLY("bt",		NULL),
-#endif
-	#ifndef CONFIG_MACH_AMAZING_CDMA
-	REGULATOR_SUPPLY("vcama",	NULL),
-	#endif
+	REGULATOR_SUPPLY("bt",		NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo18) = {
 	REGULATOR_SUPPLY("ldo18",	NULL),
-#ifdef CONFIG_MACH_AMAZING_CDMA
-REGULATOR_SUPPLY("bt",		NULL),
-#endif
 	REGULATOR_SUPPLY("rftx",	NULL),
-	REGULATOR_SUPPLY("vreg_rfrx",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ldo19) = {
 	REGULATOR_SUPPLY("ldo19",	NULL),
 	REGULATOR_SUPPLY("wlan4",	NULL),
-	REGULATOR_SUPPLY("vlcd",	NULL),
 };
 
 PCOM_VREG_CONSUMERS(ncp)   = {
@@ -243,60 +209,31 @@
 	 * S = supply voltage (uV)
 	 * T = type of regulator (smps, pldo, nldo)
 	 *            name   id  supp  min uV    max uV  R   P  A  B  V  S  T*/
-
-#ifdef CONFIG_MACH_AMAZING_CDMA
-        PCOM_VREG_SMP(smps1,  3, NULL, 1100000, 1100000, 0, -1, 0, 1, 0, 0, s),
-		PCOM_VREG_SMP(smps2,  4, NULL, 1100000, 1100000, 0, -1, 0, 0, 0, 0, s),
-        PCOM_VREG_SMP(smps3,  2, NULL, 1800000, 1800000, 0, -1, 1, 1, 0, 0, s),
-		PCOM_VREG_SMP(smps4, 24, NULL, 2100000, 2100000, 0, -1, 0, 0, 0, 0, s),
-        PCOM_VREG_LDO(ldo01, 5,  NULL, 2800000, 2800000, 0, -1, 0, 0, 0, 0, p), //minimum voltage is changed from 3.3 V to 3 V
-       /*PCOM_VREG_LDO(ldo02, 13, NULL, 3000000, 3000000, 0, -1, 0, 0, 0, 0, p), */
-        PCOM_VREG_LDO(ldo03, 49, NULL, 1200000, 1200000, 0, -1, 0, 1, 0, 0, n),
-        PCOM_VREG_LDO(ldo04, 50, NULL, 1100000, 1100000, 0, -1, 0, 1, 0, 0, n),
-        PCOM_VREG_LDO(ldo05, 45, NULL, 0      , 0      , 0, -1, 0, 0, 0, 0, n),
-        PCOM_VREG_LDO(ldo06, 51, NULL, 0      , 0      , 0, -1, 0, 0, 0, 0, n),
-        PCOM_VREG_LDO(ldo07,  0, NULL, 2600000, 2600000, 0, -1, 0, 1, 0, 0, p),
-        PCOM_VREG_LDO(ldo08,  9, NULL, 2800000, 2800000, 0, -1, 0, 1, 0, 0, p),
-        PCOM_VREG_LDO(ldo09, 44, NULL, 1800000, 1800000, 0, -1, 0, 1, 0, 0, p),
-        PCOM_VREG_LDO(ldo10, 52, NULL, 3000000, 3000000, 0, -1, 0, 0, 0, 0, p),
-        PCOM_VREG_LDO(ldo11, 53, NULL, 1800000, 1800000, 0, -1, 0, 0, 0, 0, p),
-        PCOM_VREG_LDO(ldo12, 21, NULL, 2850000, 2850000, 0, -1, 0, 1, 0, 0, p),
-        PCOM_VREG_LDO(ldo13, 18, NULL, 2850000, 2850000, 0, -1, 0, 1, 0, 0, p),
-        PCOM_VREG_LDO(ldo14, 16, NULL, 3000000, 3300000, 0, -1, 0, 1, 0, 0, p),
-        PCOM_VREG_LDO(ldo15, 54, NULL, 1800000, 1800000, 0, -1, 0, 0, 0, 0, p),
-		PCOM_VREG_LDO(ldo16, 19, NULL, 0      , 0      , 0, -1, 0, 0, 0, 0, p),
-	PCOM_VREG_LDO(ldo17, 56, NULL, 2800000, 2800000, 0, -1, 0, 0, 0, 0, p),
-		PCOM_VREG_LDO(ldo18, 13, NULL, 3000000, 3000000, 0, -1, 0, 0, 0, 0, p),
-        PCOM_VREG_LDO(ldo19, 57, NULL, 3000000, 3000000, 0, -1, 0, 1, 0, 0, p),
-
-        PCOM_VREG_NCP(ncp,   31, NULL, -1800000, -1800000, 0,     0, 0, 0, 0),
-#else
-	PCOM_VREG_SMP(smps1, 3, NULL, 1100000, 1100000, 0, -1, 0, 1, 0, 0, s),
-	PCOM_VREG_SMP(smps2, 4, NULL, 1100000, 1100000, 0, -1, 0, 0, 0, 0, s),
-	PCOM_VREG_SMP(smps3, 2, NULL, 1800000, 1800000, 0, -1, 1, 1, 0, 0, s),
+	PCOM_VREG_SMP(smps1,  3, NULL, 1100000, 1100000, 0, -1, 0, 0, 0, 0, s),
+	PCOM_VREG_SMP(smps2,  4, NULL, 1100000, 1100000, 0, -1, 0, 0, 0, 0, s),
+	PCOM_VREG_SMP(smps3,  2, NULL, 1800000, 1800000, 0, -1, 0, 0, 0, 0, s),
 	PCOM_VREG_SMP(smps4, 24, NULL, 2100000, 2100000, 0, -1, 0, 0, 0, 0, s),
-	PCOM_VREG_LDO(ldo01, 12, NULL, 3000000, 3300000, 0, -1, 0, 0, 0, 0, p),
-	PCOM_VREG_LDO(ldo02, 13, NULL, 2100000, 2100000, 0, -1, 0, 1, 0, 0, p),
-	PCOM_VREG_LDO(ldo03, 49, NULL, 1200000, 1200000, 0, -1, 0, 1, 0, 0, n),
-	PCOM_VREG_LDO(ldo04, 50, NULL, 1100000, 1100000, 0, -1, 0, 1, 0, 0, n),
-	PCOM_VREG_LDO(ldo05, 45, NULL, 0, 0, 0, -1, 0, 0, 0, 0, n),
+	PCOM_VREG_LDO(ldo01, 12, NULL, 2100000, 2100000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo02, 13, NULL, 2850000, 2850000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo03, 49, NULL, 1200000, 1200000, 0, -1, 0, 0, 0, 0, n),
+	PCOM_VREG_LDO(ldo04, 50, NULL, 1100000, 1100000, 0, -1, 0, 0, 0, 0, n),
+	PCOM_VREG_LDO(ldo05, 45, NULL, 1300000, 1350000, 0, -1, 0, 0, 0, 0, n),
 	PCOM_VREG_LDO(ldo06, 51, NULL, 1200000, 1200000, 0, -1, 0, 0, 0, 0, n),
-	PCOM_VREG_LDO(ldo07, 0, NULL, 2600000, 2600000, 0, -1, 0, 1, 0, 0, p),
-	PCOM_VREG_LDO(ldo08, 9, NULL, 2800000, 2800000, 0, -1, 0, 1, 0, 0, p),
-	PCOM_VREG_LDO(ldo09, 44, NULL, 1800000, 1800000, 0, -1, 0, 1, 0, 0, p),
-	PCOM_VREG_LDO(ldo10, 52, NULL, 2850000, 2850000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo07,  0, NULL, 2600000, 2600000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo08,  9, NULL, 2850000, 2850000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo09, 44, NULL, 1800000, 1800000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo10, 52, NULL, 1800000, 3000000, 0, -1, 0, 0, 0, 0, p),
 	PCOM_VREG_LDO(ldo11, 53, NULL, 1800000, 1800000, 0, -1, 0, 0, 0, 0, p),
-	PCOM_VREG_LDO(ldo12, 21, NULL, 3300000, 3300000, 0, -1, 0, 1, 0, 0, p),
-	PCOM_VREG_LDO(ldo13, 18, NULL, 2850000, 2850000, 0, -1, 0, 1, 0, 0, p),
-	PCOM_VREG_LDO(ldo14, 16, NULL, 3000000, 3300000, 0, -1, 0, 1, 0, 0, p),
-	PCOM_VREG_LDO(ldo15, 54, NULL, 1800000, 1800000, 0, -1, 0, 0, 0, 0, p),
-	PCOM_VREG_LDO(ldo16, 19, NULL, 3000000, 3000000, 0, -1, 0, 0, 0, 0, p),
-	PCOM_VREG_LDO(ldo17, 56, NULL, 2800000, 2800000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo12, 21, NULL, 2850000, 2850000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo13, 18, NULL, 2850000, 2850000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo14, 16, NULL, 3300000, 3300000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo15, 54, NULL, 1800000, 2850000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo16, 19, NULL, 1800000, 2850000, 0, -1, 0, 0, 0, 0, p),
+	PCOM_VREG_LDO(ldo17, 56, NULL, 2900000, 3300000, 0, -1, 0, 0, 0, 0, p),
 	PCOM_VREG_LDO(ldo18, 11, NULL, 2700000, 2700000, 0, -1, 0, 0, 0, 0, p),
-	PCOM_VREG_LDO(ldo19, 57, NULL, 3000000, 3000000, 0, -1, 0, 1, 0, 0, p),
+	PCOM_VREG_LDO(ldo19, 57, NULL, 1200000, 1800000, 0, -1, 0, 0, 0, 0, p),
 
-	PCOM_VREG_NCP(ncp, 31, NULL, -1800000, -1800000, 0, 0, 0, 0, 0),
-#endif
+	PCOM_VREG_NCP(ncp,   31, NULL, -1800000, -1800000, 0,     0, 0, 0, 0),
 };
 
 struct proccomm_regulator_platform_data msm7x27a_proccomm_regulator_data = {
Nur in final2/arch/arm/mach-msm: board-trebon.c.
Nur in final2/arch/arm/mach-msm: board-trebon-modems.c.
diff -ru final2/arch/arm/mach-msm/btpintest.c ics/arch/arm/mach-msm/btpintest.c
--- final2/arch/arm/mach-msm/btpintest.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/btpintest.c	2013-04-19 11:37:14.000000000 +0200
@@ -217,9 +217,6 @@
 					0, &pintest_debugfs_fops) == NULL) {
 		printk(KERN_ERR "%s(%d): debugfs_create_file: index fail\n",
 							__FILE__, __LINE__);
-	/*[SEL_BLUETOOTH_SAURABH] P120612-2783 CHANGES START */
-	debugfs_remove(pin_debugfs_dent);
-	/*[SEL_BLUETOOTH_SAURABH] P120612-2783 CHANGES END */
 		return -ENOMEM;
 	}
 	return 0;
diff -ru final2/arch/arm/mach-msm/clock.c ics/arch/arm/mach-msm/clock.c
--- final2/arch/arm/mach-msm/clock.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/clock.c	2013-04-19 11:37:14.000000000 +0200
@@ -21,7 +21,6 @@
 #include <linux/module.h>
 #include <linux/clk.h>
 #include <linux/clkdev.h>
-#include <linux/string.h>
 #include <linux/dma-mapping.h>
 
 #include "clock.h"
@@ -314,15 +313,6 @@
 }
 EXPORT_SYMBOL(clk_round_rate);
 
-int clk_set_min_rate(struct clk *clk, unsigned long rate)
-{
-	if (!clk->ops->set_min_rate)
-		return -ENOSYS;
-
-	return clk->ops->set_min_rate(clk, rate);
-}
-EXPORT_SYMBOL(clk_set_min_rate);
-
 int clk_set_max_rate(struct clk *clk, unsigned long rate)
 {
 	if (!clk->ops->set_max_rate)
@@ -403,35 +393,35 @@
 	unsigned n, count = 0;
 	unsigned long flags;
 	int ret = 0;
+
 	clock_debug_init(clk_init_data);
 	for (n = 0; n < clk_init_data->size; n++) {
 		struct clk *clk = clk_init_data->table[n].clk;
 		bool handoff = false;
-        if(strcmp(clk_init_data->table[n].con_id,"uart_clk")!=0)
-		{
-		  clock_debug_add(clk);
-		     if (!(clk->flags & CLKFLAG_SKIP_AUTO_OFF)) {
-			    spin_lock_irqsave(&clk->lock, flags);
-			     if (!clk->count && clk->ops->auto_off) {
-				    count++;
-				    clk->ops->auto_off(clk);
+
+		clock_debug_add(clk);
+		if (!(clk->flags & CLKFLAG_SKIP_AUTO_OFF)) {
+			spin_lock_irqsave(&clk->lock, flags);
+			if (!clk->count && clk->ops->auto_off) {
+				count++;
+				clk->ops->auto_off(clk);
 			}
-		/*	if (clk->flags & CLKFLAG_HANDOFF_RATE) {
+			if (clk->flags & CLKFLAG_HANDOFF_RATE) {
 				clk->flags &= ~CLKFLAG_HANDOFF_RATE;
-				handoff = true; 
-			} */
+				handoff = true;
+			}
 			spin_unlock_irqrestore(&clk->lock, flags);
 			/*
 			 * Calling clk_disable() outside the lock is safe since
 			 * it doesn't need to be atomic with the flag change.
 			 */
-		/*	if (handoff)
-				clk_disable(clk); */
+			if (handoff)
+				clk_disable(clk);
 		}
-    	}
 	}
-/*	if (clk_init_data->late_init)
-		ret = clk_init_data->late_init(); */
-	return 0;
+	pr_info("clock_late_init() disabled %d unused clocks\n", count);
+	if (clk_init_data->late_init)
+		ret = clk_init_data->late_init();
+	return ret;
 }
 late_initcall(clock_late_init);
diff -ru final2/arch/arm/mach-msm/clock-debug.c ics/arch/arm/mach-msm/clock-debug.c
--- final2/arch/arm/mach-msm/clock-debug.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/clock-debug.c	2013-04-19 11:37:14.000000000 +0200
@@ -139,7 +139,7 @@
 			NULL, "%llu\n");
 
 static struct dentry *debugfs_base;
-static u32 debug_suspend = 1;
+static u32 debug_suspend;
 static struct clk_lookup *msm_clocks;
 static size_t num_msm_clocks;
 
diff -ru final2/arch/arm/mach-msm/clock.h ics/arch/arm/mach-msm/clock.h
--- final2/arch/arm/mach-msm/clock.h	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/clock.h	2013-04-19 11:37:14.000000000 +0200
@@ -71,9 +71,8 @@
 	int (*in_hwcg_mode)(struct clk *clk);
 	int (*handoff)(struct clk *clk);
 	int (*reset)(struct clk *clk, enum clk_reset_action action);
-	int (*set_rate)(struct clk *clk, unsigned rate);
-	int (*set_min_rate)(struct clk *clk, unsigned rate);
-	int (*set_max_rate)(struct clk *clk, unsigned rate);
+	int (*set_rate)(struct clk *clk, unsigned long rate);
+	int (*set_max_rate)(struct clk *clk, unsigned long rate);
 	int (*set_flags)(struct clk *clk, unsigned flags);
 	unsigned long (*get_rate)(struct clk *clk);
 	int (*list_rate)(struct clk *clk, unsigned n);
@@ -137,7 +136,6 @@
 extern struct clock_init_data msm7x01a_clock_init_data;
 extern struct clock_init_data msm7x27_clock_init_data;
 extern struct clock_init_data msm7x27a_clock_init_data;
-extern struct clock_init_data msm7x27a_uart_clock_init_data;
 extern struct clock_init_data msm7x30_clock_init_data;
 extern struct clock_init_data msm8960_clock_init_data;
 extern struct clock_init_data msm8960_dummy_clock_init_data;
diff -ru final2/arch/arm/mach-msm/clock-pcom.c ics/arch/arm/mach-msm/clock-pcom.c
--- final2/arch/arm/mach-msm/clock-pcom.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/clock-pcom.c	2013-04-19 11:37:14.000000000 +0200
@@ -35,18 +35,6 @@
 	if (id == P_EBI1_CLK || id == P_EBI1_FIXED_CLK)
 		return 0;
 
-	/* FIXME: disable clock id 86 initialy.
-	 * this clock block CP sleep.
-	 * this problem looks like Qualcomm issue.
-	 * Use follow code temporary until solve that.
-	 */
-#if 1
-	if (id == 86) {
-		pr_info("[%s] get 86 clk \n");
-		return 0;
-	}
-#endif
-
 	rc = msm_proc_comm(PCOM_CLKCTL_RPC_ENABLE, &id, NULL);
 	if (rc < 0)
 		return rc;
@@ -101,14 +89,14 @@
 		return (int)id < 0 ? -EINVAL : 0;
 }
 
-static int pc_clk_set_min_rate(struct clk *clk, unsigned rate)
+static int _pc_clk_set_min_rate(struct clk *clk, unsigned long rate)
 {
 	int rc;
 	int id = to_pcom_clk(clk)->id;
 	bool ignore_error = (cpu_is_msm7x27() && id == P_EBI1_CLK &&
 				rate >= INT_MAX);
-
-	rc = msm_proc_comm(PCOM_CLKCTL_RPC_MIN_RATE, &id, &rate);
+	unsigned r = rate;
+	rc = msm_proc_comm(PCOM_CLKCTL_RPC_MIN_RATE, &id, &r);
 	if (rc < 0)
 		return rc;
 	else if (ignore_error)
@@ -120,7 +108,7 @@
 static int pc_clk_set_rate(struct clk *clk, unsigned long rate)
 {
 	if (clk->flags & CLKFLAG_MIN)
-		return pc_clk_set_min_rate(clk, rate);
+		return _pc_clk_set_min_rate(clk, rate);
 	else
 		return _pc_clk_set_rate(clk, rate);
 }
@@ -193,7 +181,6 @@
 	.auto_off = pc_clk_disable,
 	.reset = pc_reset,
 	.set_rate = pc_clk_set_rate,
-	.set_min_rate = pc_clk_set_min_rate,
 	.set_max_rate = pc_clk_set_max_rate,
 	.set_flags = pc_clk_set_flags,
 	.get_rate = pc_clk_get_rate,
@@ -208,7 +195,6 @@
 	.auto_off = pc_clk_disable,
 	.reset = pc_reset,
 	.set_rate = pc_clk_set_ext_config,
-	.set_min_rate = pc_clk_set_min_rate,
 	.set_max_rate = pc_clk_set_max_rate,
 	.set_flags = pc_clk_set_flags,
 	.get_rate = pc_clk_get_rate,
diff -ru final2/arch/arm/mach-msm/clock-pcom-lookup.c ics/arch/arm/mach-msm/clock-pcom-lookup.c
--- final2/arch/arm/mach-msm/clock-pcom-lookup.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/clock-pcom-lookup.c	2013-04-19 11:37:14.000000000 +0200
@@ -117,7 +117,7 @@
 static DEFINE_CLK_PCOM(uart1dm_clk,	UART1DM_CLK,	0);
 static DEFINE_CLK_PCOM(uart2_clk,	UART2_CLK,	0);
 static DEFINE_CLK_PCOM(uart2dm_clk,	UART2DM_CLK,	0);
-static DEFINE_CLK_PCOM(uart3_clk,	UART3_CLK,	CLKFLAG_SKIP_AUTO_OFF);
+static DEFINE_CLK_PCOM(uart3_clk,	UART3_CLK,	0);
 static DEFINE_CLK_PCOM(usb_hs2_clk,	USB_HS2_CLK,	0);
 static DEFINE_CLK_PCOM(usb_hs2_p_clk,	USB_HS2_P_CLK,	0);
 static DEFINE_CLK_PCOM(usb_hs3_clk,	USB_HS3_CLK,	0);
@@ -264,21 +264,12 @@
 	CLK_LOOKUP("ahb_m_clk",		ahb_m_clk.c,	NULL),
 	CLK_LOOKUP("ahb_s_clk",		ahb_s_clk.c,	NULL),
 	CLK_LOOKUP("cam_m_clk",		cam_m_clk.c,	NULL),
-#ifdef CONFIG_MACH_KYLE
-	CLK_LOOKUP("csi_clk", csi0_clk.c, "msm_camera_s5k4ecgx.0"),
-	CLK_LOOKUP("csi_pclk", csi0_p_clk.c, "msm_camera_s5k4ecgx.0"),
-	CLK_LOOKUP("csi_vfe_clk", csi0_vfe_clk.c, "msm_camera_s5k4ecgx.0"),
-	CLK_LOOKUP("csi_clk", csi0_clk.c, "msm_camera_sr030pc50.0"),
-	CLK_LOOKUP("csi_pclk", csi0_p_clk.c, "msm_camera_sr030pc50.0"),
-	CLK_LOOKUP("csi_vfe_clk", csi0_vfe_clk.c, "msm_camera_sr030pc50.0"),
-#else
 	CLK_LOOKUP("csi_clk",		csi0_clk.c,	"msm_camera_ov9726.0"),
 	CLK_LOOKUP("csi_pclk",		csi0_p_clk.c,	"msm_camera_ov9726.0"),
 	CLK_LOOKUP("csi_vfe_clk",	csi0_vfe_clk.c,	"msm_camera_ov9726.0"),
 	CLK_LOOKUP("csi_clk",		csi0_clk.c,	"msm_camera_ov7692.0"),
 	CLK_LOOKUP("csi_pclk",		csi0_p_clk.c,	"msm_camera_ov7692.0"),
 	CLK_LOOKUP("csi_vfe_clk",	csi0_vfe_clk.c,	"msm_camera_ov7692.0"),
-#endif
 	CLK_LOOKUP("csi_clk",		csi1_clk.c,	NULL),
 	CLK_LOOKUP("csi_pclk",		csi1_p_clk.c,	NULL),
 	CLK_LOOKUP("csi_vfe_clk",	csi1_vfe_clk.c,	NULL),
@@ -330,9 +321,7 @@
 	CLK_LOOKUP("core_clk",		uart1_clk.c,	"msm_serial.0"),
 	CLK_LOOKUP("core_clk",		uart2_clk.c,	"msm_serial.1"),
 	CLK_LOOKUP("core_clk",		uart1dm_clk.c,	"msm_serial_hs.0"),
-#ifndef CONFIG_MACH_KYLE
 	CLK_LOOKUP("core_clk",		uart2dm_clk.c,	"msm_serial_hsl.0"),
-#endif
 	CLK_LOOKUP("core_clk",		usb_hs_core_clk.c, "msm_otg"),
 	CLK_LOOKUP("alt_core_clk",	usb_hs_clk.c,	"msm_otg"),
 	CLK_LOOKUP("iface_clk",		usb_hs_p_clk.c,	"msm_otg"),
@@ -358,92 +347,6 @@
 	.size = ARRAY_SIZE(msm_clocks_7x27a),
 };
 
-struct clk_lookup msm_clocks_7x27a_uart[] = {
-	CLK_LOOKUP("core_clk",		adm_clk.c,	"msm_dmov"),
-	CLK_LOOKUP("adsp_clk",		adsp_clk.c,	NULL),
-	CLK_LOOKUP("ahb_m_clk",		ahb_m_clk.c,	NULL),
-	CLK_LOOKUP("ahb_s_clk",		ahb_s_clk.c,	NULL),
-	CLK_LOOKUP("cam_m_clk",		cam_m_clk.c,	NULL),
-	CLK_LOOKUP("csi_clk",		csi0_clk.c,	"msm_camera_ov9726.0"),
-	CLK_LOOKUP("csi_pclk",		csi0_p_clk.c,	"msm_camera_ov9726.0"),
-	CLK_LOOKUP("csi_vfe_clk",	csi0_vfe_clk.c,	"msm_camera_ov9726.0"),
-	CLK_LOOKUP("csi_clk",		csi0_clk.c,	"msm_camera_ov7692.0"),
-	CLK_LOOKUP("csi_pclk",		csi0_p_clk.c,	"msm_camera_ov7692.0"),
-	CLK_LOOKUP("csi_vfe_clk",	csi0_vfe_clk.c,	"msm_camera_ov7692.0"),
-	CLK_LOOKUP("csi_clk",		csi1_clk.c,	NULL),
-	CLK_LOOKUP("csi_pclk",		csi1_p_clk.c,	NULL),
-	CLK_LOOKUP("csi_vfe_clk",	csi1_vfe_clk.c,	NULL),
-	CLK_LOOKUP("dsi_byte_clk",	dsi_byte_clk.c,	NULL),
-	CLK_LOOKUP("dsi_clk",		dsi_clk.c,	NULL),
-	CLK_LOOKUP("dsi_esc_clk",	dsi_esc_clk.c,	NULL),
-	CLK_LOOKUP("dsi_pixel_clk",	dsi_pixel_clk.c, NULL),
-	CLK_LOOKUP("dsi_ref_clk",	dsi_ref_clk.c,	NULL),
-	CLK_LOOKUP("ebi1_clk",		ebi1_clk.c,	NULL),
-	CLK_LOOKUP("ebi2_clk",		ebi2_clk.c,	NULL),
-	CLK_LOOKUP("ecodec_clk",	ecodec_clk.c,	NULL),
-	CLK_LOOKUP("core_clk",		gp_clk.c,	NULL),
-	CLK_LOOKUP("core_clk",		grp_3d_clk.c,	"kgsl-3d0.0"),
-	CLK_LOOKUP("core_clk",		grp_3d_clk.c,	"footswitch-pcom.2"),
-	CLK_LOOKUP("iface_clk",		grp_3d_p_clk.c,	"kgsl-3d0.0"),
-	CLK_LOOKUP("iface_clk",		grp_3d_p_clk.c,	"footswitch-pcom.2"),
-	CLK_LOOKUP("core_clk",		gsbi1_qup_clk.c, "qup_i2c.0"),
-	CLK_LOOKUP("core_clk",		gsbi2_qup_clk.c, "qup_i2c.1"),
-	CLK_LOOKUP("iface_clk",		gsbi1_qup_p_clk.c, "qup_i2c.0"),
-	CLK_LOOKUP("iface_clk",		gsbi2_qup_p_clk.c, "qup_i2c.1"),
-	CLK_LOOKUP("icodec_rx_clk",	icodec_rx_clk.c, NULL),
-	CLK_LOOKUP("icodec_tx_clk",	icodec_tx_clk.c, NULL),
-	CLK_LOOKUP("mem_clk",		imem_clk.c,	NULL),
-	CLK_LOOKUP("mddi_clk",		pmdh_clk.c,	NULL),
-	CLK_LOOKUP("mdp_clk",		mdp_clk.c,	NULL),
-	CLK_LOOKUP("mdp_lcdc_pclk_clk",	mdp_lcdc_pclk_clk.c, NULL),
-	CLK_LOOKUP("mdp_lcdc_pad_pclk_clk", mdp_lcdc_pad_pclk_clk.c, NULL),
-	CLK_LOOKUP("mdp_vsync_clk",	mdp_vsync_clk.c,	NULL),
-	CLK_LOOKUP("mdp_dsi_pclk",	mdp_dsi_p_clk.c,	NULL),
-	CLK_LOOKUP("pbus_clk",		pbus_clk.c,	NULL),
-	CLK_LOOKUP("pcm_clk",		pcm_clk.c,	NULL),
-	CLK_LOOKUP("sdac_clk",		sdac_clk.c,	NULL),
-	CLK_LOOKUP("core_clk",		sdc1_clk.c,	"msm_sdcc.1"),
-	CLK_LOOKUP("iface_clk",		sdc1_p_clk.c,	"msm_sdcc.1"),
-	CLK_LOOKUP("core_clk",		sdc2_clk.c,	"msm_sdcc.2"),
-	CLK_LOOKUP("iface_clk",		sdc2_p_clk.c,	"msm_sdcc.2"),
-	CLK_LOOKUP("core_clk",		sdc3_clk.c,	"msm_sdcc.3"),
-	CLK_LOOKUP("iface_clk",		sdc3_p_clk.c,	"msm_sdcc.3"),
-	CLK_LOOKUP("core_clk",		sdc4_clk.c,	"msm_sdcc.4"),
-	CLK_LOOKUP("iface_clk",		sdc4_p_clk.c,	"msm_sdcc.4"),
-	CLK_LOOKUP("ref_clk",		tsif_ref_clk.c,	"msm_tsif.0"),
-	CLK_LOOKUP("iface_clk",		tsif_p_clk.c,	"msm_tsif.0"),
-	CLK_LOOKUP("core_clk",		uart1_clk.c,	"msm_serial.0"),
-	CLK_LOOKUP("core_clk",		uart2_clk.c,	"msm_serial.1"),
-	CLK_LOOKUP("core_clk",		uart1dm_clk.c,	"msm_serial_hs.0"),
-	CLK_LOOKUP("core_clk",		uart2dm_clk.c,	"msm_serial_hsl.0"),
-	CLK_LOOKUP("core_clk",		usb_hs_core_clk.c, "msm_otg"),
-	CLK_LOOKUP("alt_core_clk",	usb_hs_clk.c,	"msm_otg"),
-	CLK_LOOKUP("iface_clk",		usb_hs_p_clk.c,	"msm_otg"),
-	CLK_LOOKUP("phy_clk",		usb_phy_clk.c,	"msm_otg"),
-	CLK_LOOKUP("alt_core_clk",	usb_hs2_clk.c,	"msm_hsusb_host.0"),
-	CLK_LOOKUP("vdc_clk",		vdc_clk.c,	NULL),
-	CLK_LOOKUP("core_clk",		vdc_clk.c,	"footswitch-pcom.7"),
-	CLK_LOOKUP("vfe_clk",		vfe_clk.c,	NULL),
-	CLK_LOOKUP("core_clk",		vfe_clk.c,	"footswitch-pcom.8"),
-	CLK_LOOKUP("vfe_mdc_clk",	vfe_mdc_clk.c,	NULL),
-	CLK_LOOKUP("uart_clk",		uart3_clk.c,	"msm_serial.2"),
-	CLK_LOOKUP("ebi1_acpu_clk",	ebi_acpu_clk.c,	NULL),
-	CLK_LOOKUP("bus_clk",		ebi_grp_3d_clk.c, "kgsl-3d0.0"),
-	CLK_LOOKUP("ebi1_lcdc_clk",	ebi_lcdc_clk.c,	NULL),
-	CLK_LOOKUP("ebi1_mddi_clk",	ebi_mddi_clk.c,	NULL),
-	CLK_LOOKUP("ebi1_vfe_clk",	ebi_vfe_clk.c,	NULL),
-	CLK_LOOKUP("mem_clk",		ebi_adm_clk.c,	"msm_dmov"),
-	
-};
-
-
-
-struct clock_init_data msm7x27a_uart_clock_init_data __initdata = {
-	.table = msm_clocks_7x27a_uart,
-	.size = ARRAY_SIZE(msm_clocks_7x27a_uart),
-};
-
-
 static struct clk_lookup msm_clocks_8x50[] = {
 	CLK_LOOKUP("core_clk",		adm_clk.c,	"msm_dmov"),
 	CLK_LOOKUP("core_clk",		ce_clk.c,	"qce.0"),
diff -ru final2/arch/arm/mach-msm/cpufreq.c ics/arch/arm/mach-msm/cpufreq.c
--- final2/arch/arm/mach-msm/cpufreq.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/cpufreq.c	2013-04-19 11:37:14.000000000 +0200
@@ -51,40 +51,6 @@
 static DEFINE_PER_CPU(struct cpufreq_suspend_t, cpufreq_suspend);
 
 static int override_cpu;
-#ifdef CONFIG_SEC_DVFS
-static unsigned int upper_limit_freq;
-static unsigned int lower_limit_freq;
-
-unsigned int get_min_lock(void)
-{
-	return lower_limit_freq;
-}
-
-unsigned int get_max_lock(void)
-{
-	return upper_limit_freq;
-}
-
-void set_min_lock(int freq)
-{
-	if (freq <= MIN_FREQ_LIMIT)
-		lower_limit_freq = 0;
-	else if (freq > MAX_FREQ_LIMIT)
-		lower_limit_freq = 0;
-	else
-		lower_limit_freq = freq;
-}
-
-void set_max_lock(int freq)
-{
-	if (freq < MIN_FREQ_LIMIT)
-		upper_limit_freq = 0;
-	else if (freq >= MAX_FREQ_LIMIT)
-		upper_limit_freq = 0;
-	else
-		upper_limit_freq = freq;
-}
-#endif
 
 static int set_cpu_freq(struct cpufreq_policy *policy, unsigned int new_freq)
 {
@@ -97,26 +63,11 @@
 			return 0;
 		else
 			freqs.new = policy->max;
-	}
-#ifdef CONFIG_SEC_DVFS
-	else if (lower_limit_freq || upper_limit_freq) {
-		freqs.new = new_freq;
-
-		if (lower_limit_freq && new_freq < lower_limit_freq)
-			freqs.new = lower_limit_freq;
-
-		if (upper_limit_freq && new_freq > upper_limit_freq)
-			freqs.new = upper_limit_freq;
-
-		if (freqs.new == freqs.old)
-			return 0;
-	}
-#endif
-	else
+	} else
 		freqs.new = new_freq;
 	freqs.cpu = policy->cpu;
 	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
-	ret = acpuclk_set_rate(policy->cpu, freqs.new, SETRATE_CPUFREQ);
+	ret = acpuclk_set_rate(policy->cpu, new_freq, SETRATE_CPUFREQ);
 	if (!ret)
 		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
 
@@ -353,10 +304,7 @@
 static int __init msm_cpufreq_register(void)
 {
 	int cpu;
-#ifdef CONFIG_SEC_DVFS
-	upper_limit_freq = 0;
-	lower_limit_freq = 0;
-#endif
+
 	int err = sysfs_create_file(&cpu_sysdev_class.kset.kobj,
 			&attr_mfreq.attr);
 	if (err)
diff -ru final2/arch/arm/mach-msm/devices.h ics/arch/arm/mach-msm/devices.h
--- final2/arch/arm/mach-msm/devices.h	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/devices.h	2013-04-19 11:37:14.000000000 +0200
@@ -227,8 +227,6 @@
 extern struct platform_device fsm_xo_device;
 
 extern struct platform_device qfec_device;
-extern struct clk_lookup msm_clocks_7x27a_uart[];
-extern unsigned msm_num_clocks_7x27a_uart;
 
 extern struct platform_device msm_kgsl_3d0;
 extern struct platform_device msm_kgsl_2d0;
diff -ru final2/arch/arm/mach-msm/devices-msm7x27a.c ics/arch/arm/mach-msm/devices-msm7x27a.c
--- final2/arch/arm/mach-msm/devices-msm7x27a.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/devices-msm7x27a.c	2013-04-19 11:37:14.000000000 +0200
@@ -241,26 +241,6 @@
 	.resource	= resources_uart1,
 };
 
-static struct resource resources_uart3[] = {
-	{
-		.start	= INT_UART3,
-		.end	= INT_UART3,
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= MSM_UART3_PHYS,
-		.end	= MSM_UART3_PHYS + MSM_UART3_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-struct platform_device msm_device_uart3 = {
-	.name	= "msm_serial",
-	.id	= 2,
-	.num_resources	= ARRAY_SIZE(resources_uart3),
-	.resource	= resources_uart3,
-};
-
 #define MSM_UART1DM_PHYS      0xA0200000
 static struct resource msm_uart1_dm_resources[] = {
 	{
@@ -538,14 +518,13 @@
 int __init msm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat)
 {
 	struct platform_device	*pdev;
-    int ret;
+
 	if (controller < 1 || controller > 4)
 		return -EINVAL;
 
 	pdev = msm_sdcc_devices[controller-1];
 	pdev->dev.platform_data = plat;
-	ret = platform_device_register(pdev);
-	return ret;
+	return platform_device_register(pdev);
 }
 
 #ifdef CONFIG_MSM_CAMERA_V4L2
@@ -779,8 +758,6 @@
 	},
 };
 
-extern unsigned int kernel_uart_flag;
-
 struct platform_device asoc_msm_pcm = {
 	.name   = "msm-dsp-audio",
 	.id     = 0,
@@ -816,28 +793,18 @@
 
 static int msm7627a_init_gpio(void)
 {
-	int ret = 0;
-
-	ret = platform_device_register(&msm_device_gpio);
-	return ret;
+	platform_device_register(&msm_device_gpio);
+	return 0;
 }
 postcore_initcall(msm7627a_init_gpio);
 
-
-
 int __init msm7x2x_misc_init(void)
 {
-	if (!kernel_uart_flag)
-		msm_clock_init(&msm7x27a_uart_clock_init_data);
-	else
-		msm_clock_init(&msm7x27a_clock_init_data);
-
+	msm_clock_init(&msm7x27a_clock_init_data);
 	if (cpu_is_msm7x27aa() || cpu_is_msm7x25ab())
 		acpuclk_init(&acpuclk_7x27aa_soc_data);
 	else
 		acpuclk_init(&acpuclk_7x27a_soc_data);
-		
-	
 
 
 	return 0;
diff -ru final2/arch/arm/mach-msm/gpio.c ics/arch/arm/mach-msm/gpio.c
--- final2/arch/arm/mach-msm/gpio.c	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/gpio.c	2013-04-19 11:37:14.000000000 +0200
@@ -24,124 +24,16 @@
 #include <asm/mach/irq.h>
 #include <mach/gpiomux.h>
 #include "gpio_hw.h"
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
 #include "proc_comm.h"
 #include "smd_private.h"
 
 enum {
 	GPIO_DEBUG_SLEEP = 1U << 0,
 };
-static int msm_gpio_debug_mask = GPIO_DEBUG_SLEEP;
+static int msm_gpio_debug_mask;
 module_param_named(debug_mask, msm_gpio_debug_mask, int,
 		   S_IRUGO | S_IWUSR | S_IWGRP);
 
-#if defined(CONFIG_MACH_TREBON)
-static unsigned ldo_gpios0[] = {
-};
-
-static unsigned ldo_gpios1[] = {
-	18, 22, 32, 33, 34, 41
-};
-static unsigned ldo_gpios2[] = {
-	49, 58
-};
-
-static unsigned ldo_gpios3[] = {
-	84, 85
-};
-
-static unsigned ldo_gpios4[] = {
-	96
-};
-
-static unsigned ldo_gpios5[] = {
-	107, 109, 110, 124, 129
-};
-#elif defined(CONFIG_MACH_KYLE)
-static unsigned ldo_gpios0[] = {
-	4,
-};	/* 0 ~ 15 */
-static unsigned ldo_gpios1[] = {
-	18, 22, 23, 32, 33, 34, 41, 42
-};	/* 16 ~ 42 */
-static unsigned ldo_gpios2[] = {
-	49, 58
-};	/* 43 ~ 67 */
-static unsigned ldo_gpios3[] = {
-	77, 81, 82, 85
-};	/* 68 ~ 94 */
-static unsigned ldo_gpios4[] = {
-	96, 98
-};	/* 95 ~ 106 */
-static unsigned ldo_gpios5[] = {
-	107, 109, 110, 124
-};	/* 107 ~ 132 */
-#elif defined(CONFIG_MACH_AMAZING)
-static unsigned ldo_gpios0[] = {};
-static unsigned ldo_gpios1[] = {
-	22, 32, 33, 34, 41, 42
-};
-static unsigned ldo_gpios2[] = {
-};
-static unsigned ldo_gpios3[] = {
-	81, 82, 85
-};
-static unsigned ldo_gpios4[] = {
-	96, 97
-};
-static unsigned ldo_gpios5[] = {
-	107, 109, 110, 124, 129
-};
-#elif defined(CONFIG_MACH_GEIM)
-static unsigned ldo_gpios0[] = {};
-static unsigned ldo_gpios1[] = {
-	18, 22, 32, 33, 34, 41, 42
-};
-static unsigned ldo_gpios2[] = {
-	49
-};
-static unsigned ldo_gpios3[] = {
-	81, 82, 84, 85
-};
-static unsigned ldo_gpios4[] = {
-	96, 97
-};
-static unsigned ldo_gpios5[] = {
-	107, 109, 110, 124, 129
-};
-#elif defined(CONFIG_MACH_JENA)
-static unsigned ldo_gpios0[] = {
-};
-static unsigned ldo_gpios1[] = {
-	18, 22, 32, 33, 34, 41
-};
-
-static unsigned ldo_gpios2[] = {
-	/*49, */ 58
-};
-
-static unsigned ldo_gpios3[] = {
-	/*84, */ 85
-};
-
-static unsigned ldo_gpios4[] = {
-	96
-};
-
-static unsigned ldo_gpios5[] = {
-	107, 109, 110, 124, 129
-};
-
-#else
-static unsigned ldo_gpios0[] = {};
-static unsigned ldo_gpios1[] = {};
-static unsigned ldo_gpios2[] = {};
-static unsigned ldo_gpios3[] = {};
-static unsigned ldo_gpios4[] = {};
-static unsigned ldo_gpios5[] = {};
-#endif
-
 #define FIRST_GPIO_IRQ MSM_GPIO_TO_INT(0)
 
 #define MSM_GPIO_BANK(bank, first, last)				\
@@ -514,38 +406,6 @@
 }
 
 static DECLARE_TASKLET(msm_gpio_sleep_int_tasklet, msm_gpio_sleep_int, 0);
-static char *msm_gpio_buf;
-
-static void msm_gpio_show_suspend_state(unsigned *gpios,
-		unsigned len, struct msm_gpio_chip *chips)
-{
-	unsigned i, offset, size = 0;
-
-	if (!len)
-		return;
-
-	if (unlikely(!msm_gpio_buf)) {
-		pr_info("[%s] No memory\n", __func__);
-		return;
-	}
-
-	memset(msm_gpio_buf, 0, 512);
-	for (i = 0; i < len; i++) {
-		offset = gpios[i] - chips->chip.base;
-		if (__raw_readl(chips->regs.oe) & BIT(offset)) {
-			snprintf(msm_gpio_buf + size, 16,
-					"gpio-%03d-%s", gpios[i],
-					(__raw_readl(chips->regs.out) &
-					 BIT(offset)) ?	"high, " : "low,  ");
-			size += 15;
-		}
-		if (size > 500)
-			break;
-	}
-	msm_gpio_buf[size - 1] = '\0';
-
-	pr_info("gpio_suspend: %s\n", msm_gpio_buf);
-}
 
 void msm_gpio_enter_sleep(int from_idle)
 {
@@ -604,26 +464,6 @@
 		for (i = 0; i < GPIO_SMEM_NUM_GROUPS; i++)
 			smem_gpio->num_fired[i] = 0;
 	}
-
-	if (from_idle)
-		return;
-	msm_gpio_show_suspend_state(ldo_gpios0,
-			ARRAY_SIZE(ldo_gpios0), &msm_gpio_chips[0]);
-
-	msm_gpio_show_suspend_state(ldo_gpios1,
-			ARRAY_SIZE(ldo_gpios1), &msm_gpio_chips[1]);
-
-	msm_gpio_show_suspend_state(ldo_gpios2,
-			ARRAY_SIZE(ldo_gpios2), &msm_gpio_chips[2]);
-
-	msm_gpio_show_suspend_state(ldo_gpios3,
-			ARRAY_SIZE(ldo_gpios3), &msm_gpio_chips[3]);
-
-	msm_gpio_show_suspend_state(ldo_gpios4,
-			ARRAY_SIZE(ldo_gpios4), &msm_gpio_chips[4]);
-
-	msm_gpio_show_suspend_state(ldo_gpios5,
-			ARRAY_SIZE(ldo_gpios5), &msm_gpio_chips[5]);
 }
 
 void msm_gpio_exit_sleep(void)
@@ -647,47 +487,6 @@
 	}
 }
 
-static int gdump_proc_show(struct seq_file *seq, void *offset)
-{
-	unsigned val, i;
-
-	for (i = 0; i < ARRAY_SIZE(msm_gpio_chips); i++) {
-		val = __raw_readl(msm_gpio_chips[i].regs.oe);
-		seq_printf(seq, "%d.oe:\t0x%08x\n", i, val);
-		val = __raw_readl(msm_gpio_chips[i].regs.out);
-		seq_printf(seq, "%d.out:\t0x%08x\n", i, val);
-		val = __raw_readl(msm_gpio_chips[i].regs.in);
-		seq_printf(seq, "%d.in:\t0x%08x\n\n", i, val);
-	}
-
-	return 0;
-}
-static int gdump_proc_open(struct inode *inode, struct file *file)
-{
-	int ret;
-
-	if (!try_module_get(THIS_MODULE))
-		return -ENODEV;
-
-	ret = single_open(file, gdump_proc_show, NULL);
-	if (ret)
-		module_put(THIS_MODULE);
-	return ret;
-}
-
-static int gdump_proc_release(struct inode *inode, struct file *file)
-{
-	int res = single_release(inode, file);
-	module_put(THIS_MODULE);
-	return res;
-}
-
-static const struct file_operations gdump_proc_fops = {
-	.open		= gdump_proc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= gdump_proc_release,
-};
 
 int gpio_tlmm_config(unsigned config, unsigned disable)
 {
@@ -845,8 +644,6 @@
 		__raw_writel(0, msm_gpio_chips[i].regs.int_en);
 		gpiochip_add(&msm_gpio_chips[i].chip);
 	}
-	proc_create_data("gdump", 0, NULL, &gdump_proc_fops, NULL);
-	msm_gpio_buf = kzalloc(512, GFP_KERNEL);
 
 	mb();
 	return 0;
Nur in final2/arch/arm/mach-msm/include/mach: bq27425_fuelguage.h.
diff -ru final2/arch/arm/mach-msm/include/mach/camera.h ics/arch/arm/mach-msm/include/mach/camera.h
--- final2/arch/arm/mach-msm/include/mach/camera.h	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/include/mach/camera.h	2013-04-19 11:37:14.000000000 +0200
@@ -27,9 +27,9 @@
 #include <mach/msm_subsystem_map.h>
 #include <linux/ion.h>
 
-/*#define CONFIG_MSM_CAMERA_DEBUG*/
+#define CONFIG_MSM_CAMERA_DEBUG
 #ifdef CONFIG_MSM_CAMERA_DEBUG
-#define CDBG(fmt, args...) printk(KERN_ERR "msm_camera: " fmt, ##args)
+#define CDBG(fmt, args...) pr_debug(fmt, ##args)
 #else
 #define CDBG(fmt, args...) do { } while (0)
 #endif
@@ -332,32 +332,15 @@
 	int *dis;
 };
 
-#ifdef CONFIG_MACH_KYLE_I
 struct msm_sensor_ctrl {
-
-	int (*s_power) (int enable);	//eunice09.kim change camera power sequence
 	int (*s_init)(const struct msm_camera_sensor_info *);
 	int (*s_release)(void);
 	int (*s_config)(void __user *);
-        int (*s_ext_config)(void __user *); // add for dual camera interface
 	enum msm_camera_type s_camera_type;
 	uint32_t s_mount_angle;
 	enum msm_st_frame_packing s_video_packing;
 	enum msm_st_frame_packing s_snap_packing;
 };
-#else
-struct msm_sensor_ctrl {
-	int (*s_init)(const struct msm_camera_sensor_info *);
-	int (*s_release)(void);
-	int (*s_config)(void __user *);
-        int (*s_ext_config)(void __user *); // add for dual camera interface
-	enum msm_camera_type s_camera_type;
-	uint32_t s_mount_angle;
-	enum msm_st_frame_packing s_video_packing;
-	enum msm_st_frame_packing s_snap_packing;
-};
-#endif
-
 
 struct msm_actuator_ctrl {
 	int (*a_init_table)(void);
diff -ru final2/arch/arm/mach-msm/include/mach/dma.h ics/arch/arm/mach-msm/include/mach/dma.h
--- final2/arch/arm/mach-msm/include/mach/dma.h	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/include/mach/dma.h	2013-04-19 11:37:14.000000000 +0200
@@ -224,7 +224,7 @@
 #define DMOV_SDC2_CHAN        8
 #define DMOV_SDC2_CRCI        7
 
-#define DMOV_SDC3_CHAN        7
+#define DMOV_SDC3_CHAN        8
 #define DMOV_SDC3_CRCI        12
 
 #define DMOV_SDC4_CHAN        8
Nur in final2/arch/arm/mach-msm/include/mach: entry-macro-qgic.S.
Nur in final2/arch/arm/mach-msm/include/mach: entry-macro-vic.S.
Nur in final2/arch/arm/mach-msm/include/mach: gpio_amazing_cdma.h.
Nur in final2/arch/arm/mach-msm/include/mach: gpio_geim.h.
Nur in final2/arch/arm/mach-msm/include/mach: gpio_jena.h.
Nur in final2/arch/arm/mach-msm/include/mach: gpio_kyle.h.
Nur in final2/arch/arm/mach-msm/include/mach: gpio_trebon.h.
Nur in final2/arch/arm/mach-msm/include/mach: gpio_trebon_rev01.h.
Nur in final2/arch/arm/mach-msm/include/mach: gpio_trebon_rev02.h.
diff -ru final2/arch/arm/mach-msm/include/mach/msm_battery.h ics/arch/arm/mach-msm/include/mach/msm_battery.h
--- final2/arch/arm/mach-msm/include/mach/msm_battery.h	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/include/mach/msm_battery.h	2013-04-19 11:37:14.000000000 +0200
@@ -1,29 +1,13 @@
 /* Copyright (c) 2009, The Linux Foundation. All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
  *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
  */
 
@@ -31,61 +15,10 @@
 #ifndef __MSM_BATTERY_H__
 #define __MSM_BATTERY_H__
 
-#define NO_CHG     0x00000000
 #define AC_CHG     0x00000001
 #define USB_CHG    0x00000002
-#ifdef CONFIG_CHARGER_SMB328A
-#include <linux/smb328a_charger.h>
-#endif
-
-enum cable_type_t {
-	CABLE_TYPE_UNKNOWN = 0,
-	CABLE_TYPE_USB,
-	CABLE_TYPE_TA,
-    CABLE_TYPE_USB_OTG,
-};
-
-enum acc_type_t {
-	ACC_TYPE_NONE = 0,
-	ACC_TYPE_USB,
-	ACC_TYPE_CHARGER,
-	ACC_TYPE_CAR_DOCK,
-	ACC_TYPE_DESK_DOCK,
-	ACC_TYPE_JIG,
-};
-
-enum ovp_type_t {
-	OVP_TYPE_NONE = 0,
-	OVP_TYPE_OVP,
-	OVP_TYPE_RECOVER,
-};
-
-extern bool power_down;
-extern int charging_boot;
-static int set_timer;
-
-struct msm_battery_callback {
-	void (*set_cable)(struct msm_battery_callback *ptr,
-		enum cable_type_t status);
-	void (*set_acc_type)(struct msm_battery_callback *ptr,
-		enum acc_type_t status);
-	void (*set_ovp_type)(struct msm_battery_callback *ptr,
-		enum ovp_type_t status);
-#ifdef CONFIG_CHARGER_SMB328A
-	void (*charge_done)(struct msm_battery_callback *ptr);	/* switching charger */
-#endif
-};
-
-struct msm_charger_data {
-	struct power_supply *psy_fuelgauge;
-#ifdef CONFIG_CHARGER_SMB328A
-	struct smb328a_platform_data *charger_ic;	/* SMB328A switching charger */
-#endif
-	void (*register_callbacks)(struct msm_battery_callback *ptr);
-};
 
 struct msm_psy_batt_pdata {
-	struct msm_charger_data	*charger;
 	u32 voltage_max_design;
 	u32 voltage_min_design;
 	u32 voltage_fail_safe;
@@ -94,5 +27,4 @@
 	u32 (*calculate_capacity)(u32 voltage);
 };
 
-void msm_battery_fuel_alert(void);
 #endif
diff -ru final2/arch/arm/mach-msm/include/mach/msm_hsusb.h ics/arch/arm/mach-msm/include/mach/msm_hsusb.h
--- final2/arch/arm/mach-msm/include/mach/msm_hsusb.h	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/include/mach/msm_hsusb.h	2013-04-19 11:37:14.000000000 +0200
@@ -121,7 +121,6 @@
 
 	int self_powered;
 	int is_phy_status_timer_on;
-	int (*get_usb_chg_type)(void);
 };
 
 struct msm_otg_platform_data {
@@ -173,8 +172,6 @@
 	int  (*chg_init)(int init);
 	int (*config_vddcx)(int high);
 	int (*init_vddcx)(int init);
-	int (*chg_connect_type)(void);
-	int (*chg_mode_check)(void);
 
 	struct pm_qos_request_list pm_qos_req_dma;
 };
diff -ru final2/arch/arm/mach-msm/include/mach/rpc_server_handset.h ics/arch/arm/mach-msm/include/mach/rpc_server_handset.h
--- final2/arch/arm/mach-msm/include/mach/rpc_server_handset.h	2014-08-29 08:20:15.292248000 +0200
+++ ics/arch/arm/mach-msm/include/mach/rpc_server_handset.h	2013-04-19 11:37:14.000000000 +0200
@@ -20,6 +20,5 @@
 };
 
 void report_headset_status(bool connected);
-extern int current_jack_type;
-extern int current_key_state;
+
 #endif
Nur in final2/arch/arm/mach-msm/include/mach: samsung_vibe.h.
Nur in final2/arch/arm/mach-msm/include/mach: sdio_tty.h.
Nur in final2/arch/arm/mach-msm/include/mach: usb_gadget_fserial.h.
diff -ru final2/arch/arm/mach-msm/irq-vic.c ics/arch/arm/mach-msm/irq-vic.c
--- final2/arch/arm/mach-msm/irq-vic.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/irq-vic.c	2013-04-19 11:37:14.000000000 +0200
@@ -41,8 +41,7 @@
 	IRQ_DEBUG_SLEEP = 1U << 3,
 	IRQ_DEBUG_SLEEP_REQUEST = 1U << 4,
 };
-static int msm_irq_debug_mask = IRQ_DEBUG_SLEEP_INT_TRIGGER
-					| IRQ_DEBUG_SLEEP_INT;
+static int msm_irq_debug_mask;
 module_param_named(debug_mask, msm_irq_debug_mask, int,
 		   S_IRUGO | S_IWUSR | S_IWGRP);
 
diff -ru final2/arch/arm/mach-msm/Kconfig ics/arch/arm/mach-msm/Kconfig
--- final2/arch/arm/mach-msm/Kconfig	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -424,69 +424,6 @@
         help
           Support for the Qualcomm MSM7x27A FFA.
 
-config MACH_TREBON
-        depends on ARCH_MSM7X27A
-        depends on !MSM_STACKED_MEMORY
-        default n
-        bool "MSM7x27A TREBON"
-        help
-          Support for the Qualcomm TREBON       
-
-config MACH_AMAZING
-        depends on !MSM_STACKED_MEMORY
-        default n
-        bool "MSM7x27A AMAZING"
-        help
-          Support for the Qualcomm AMAZING               
-	  
-config MACH_AMAZING_CDMA
-        depends on ARCH_MSM7X27A
-        depends on !MSM_STACKED_MEMORY
-        default n
-        bool "MSM7x27A AMAZING-CDMA"
-        help
-	  Support for the Qualcomm AMAZING-CDMA
-
-config MACH_KYLE
-        depends on !MSM_STACKED_MEMORY
-	select DISABLE_HDMI_FB_CLEAR
-        default n
-        bool "MSM7x27A KYLE"
-        help
-          Support for the Qualcomm KYLE
-
-config MACH_KYLE_CHN
-        depends on !MSM_STACKED_MEMORY
-	select DISABLE_HDMI_FB_CLEAR
-        default n
-        bool "MSM7x27A KYLE-CHN"
-        help
-          Support for the Qualcomm KYLE-CHN
-
-config MACH_KYLE_HKTW
-        depends on !MSM_STACKED_MEMORY
-	select DISABLE_HDMI_FB_CLEAR
-        default n
-        bool "MSM7x27A KYLE-HKTW"
-        help
-          Support for the Qualcomm KYLE-HKTW
-	  
-config MACH_KYLE_I
-        depends on !MSM_STACKED_MEMORY
-	select DISABLE_HDMI_FB_CLEAR
-        default n
-        bool "MSM7x27A KYLE-I"
-        help
-          Support for the Qualcomm KYLE-I
-
-config MACH_KYLE_I_CU
-        depends on !MSM_STACKED_MEMORY
-	select DISABLE_HDMI_FB_CLEAR
-        default n
-        bool "MSM7x27A KYLE-I-CU"
-        help
-          Support for the Qualcomm KYLE-I-CU
-
 config MACH_MSM7625A_SURF
         depends on ARCH_MSM7X27A
         depends on !MSM_STACKED_MEMORY
@@ -775,20 +712,6 @@
 
 endmenu
 
-config MACH_TREBON_HWREV
-        hex "MSM7x27A TREBON HWREV"
-		depends on MACH_TREBON
-		default "0x2"
-		help
-          Qualcomm TREBON H/W revision.
-
-config MACH_AMAZING_CDMA_HWREV
-        hex "MSM7x27A AMAZING-CDMA HWREV"
-               depends on MACH_AMAZING_CDMA
-               default "0x0"
-               help
-          Qualcomm AMAZING-CDMA H/W revision.
-
 config MSM_STACKED_MEMORY
 	bool "Stacked Memory"
 	default y
@@ -2009,9 +1932,6 @@
 		the resume loop unrolls. Say Y if you want to debug why the system
 		resumed.
 
-config BT_CSR_7820
-	bool "CSR Bluetooth"
-
 config BT_MSM_PINTEST
 	tristate "MSM Bluetooth Pin Connectivity Test"
 	depends on ((ARCH_MSM8X60 || ARCH_MSM7X27A) && DEBUG_FS)
@@ -2100,20 +2020,6 @@
 	  instead of pmem. Selecting this may also involve userspace
 	  dependencies as well.
 
-config SEC_DEBUG_SCHED_LOG
-        default n
-        bool "Scheduler Log"
-
-config SEC_DEBUG_IRQ_EXIT_LOG
-        depends on SEC_DEBUG_SCHED_LOG
-        default n
-        bool "IRQ Log"
-
-config APPLY_GA_SOLUTION
-        default y
-        bool "MSM7x27A GetLog"
-        help
-
 config MSM_RTB
 	bool "Register tracing"
 	help
@@ -2130,31 +2036,6 @@
 	  separately. This will guarantee that the last acesses for each cpu
 	  will be logged but there will be fewer entries per cpu
 
-config SEC_MODEM_AMAZING
-	bool "Amazing with msm7x25a"
-	depends on SEC_MODEM
-	select LINK_DEVICE_DPRAM
-	select UMTS_MODEM_MSM7x27
-
-config SEC_MODEM_TREBON
-	bool "Trebon with msm7x27a"
-	depends on SEC_MODEM
-	select LINK_DEVICE_DPRAM
-	select UMTS_MODEM_MSM7x27
-
-config SEC_MODEM_AMAZING_CDMA
-        bool "Amazing-cdma with msm7x25a"
-        depends on SEC_MODEM
-        select LINK_DEVICE_DPRAM
-        select UMTS_MODEM_MSM7x27
-
-config DISABLE_FM_SUPPORT
-    bool "Disable FM support"
-        depends on MACH_AMAZING_CDMA
-    default y
-    help
-          Feature for disabling FM support
-	  
 config MSM_CACHE_ERP
 	bool "Cache / CPU error reporting"
 	depends on ARCH_MSM_KRAIT
@@ -2265,10 +2146,4 @@
 	  want to dump the L1 and L2 caches on panic before any flush occurs.
 	  If unsure, say N
 
-config BT_MGMT
-	bool "Bluetooth Mgmt"
-	default n
-	help
-	  This is for bluetooth mgmt.
-
 endif
diff -ru final2/arch/arm/mach-msm/Makefile ics/arch/arm/mach-msm/Makefile
--- final2/arch/arm/mach-msm/Makefile	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -215,14 +215,10 @@
 obj-$(CONFIG_MACH_MSM7X27_SURF) += board-msm7x27.o devices-msm7x27.o
 obj-$(CONFIG_MACH_MSM7X27_FFA) += board-msm7x27.o devices-msm7x27.o
 obj-$(CONFIG_ARCH_MSM7X27A) += clock-pcom-lookup.o devices-msm7x27a.o
-obj-$(CONFIG_MACH_TREBON) += board-trebon.o board-trebon-modems.o wlan-prealloc.o
-obj-$(CONFIG_MACH_AMAZING) += board-amazing.o board-amazing-modems.o 
-obj-$(CONFIG_MACH_KYLE) += board-kyle.o
-obj-$(CONFIG_MACH_AMAZING_CDMA) += board-amazing_cdma.o
-obj-$(CONFIG_MACH_MSM7X27A_RUMI3) += board-msm7627a-storage.o board-msm7627a-bt.o board-msm7627a-camera.o
-obj-$(CONFIG_MACH_MSM7X27A_SURF) += board-msm7627a-storage.o board-msm7627a-bt.o board-msm7627a-camera.o
-obj-$(CONFIG_MACH_MSM7X27A_FFA) += board-msm7627a-storage.o board-msm7627a-bt.o board-msm7627a-camera.o
-
+obj-$(CONFIG_MACH_MSM7X27A_RUMI3) += board-msm7x27a.o board-msm7627a-storage.o board-msm7627a-bt.o board-msm7627a-camera.o
+obj-$(CONFIG_MACH_MSM7X27A_SURF) += board-msm7x27a.o board-msm7627a-storage.o board-msm7627a-bt.o board-msm7627a-camera.o
+obj-$(CONFIG_MACH_MSM7X27A_FFA) += board-msm7x27a.o board-msm7627a-storage.o board-msm7627a-bt.o board-msm7627a-camera.o
+obj-$(CONFIG_MACH_MSM7627A_QRD1) += board-qrd7627a.o board-msm7627a-storage.o board-msm7627a-bt.o board-msm7627a-camera.o
 obj-$(CONFIG_ARCH_MSM7X30) += board-msm7x30.o devices-msm7x30.o memory_topology.o
 obj-$(CONFIG_ARCH_MSM7X30) += clock-local.o clock-7x30.o acpuclock-7x30.o
 obj-$(CONFIG_MACH_MSM7X25_SURF) += board-msm7x27.o devices-msm7x25.o
diff -ru final2/arch/arm/mach-msm/Makefile.boot ics/arch/arm/mach-msm/Makefile.boot
--- final2/arch/arm/mach-msm/Makefile.boot	2014-08-29 08:16:09.728240000 +0200
+++ ics/arch/arm/mach-msm/Makefile.boot	2013-04-19 11:37:14.000000000 +0200
@@ -1,7 +1,7 @@
 # MSM7x01A
-   zreladdr-$(CONFIG_ARCH_MSM7X01A)	:= 0x00208000#0x10008000
-params_phys-$(CONFIG_ARCH_MSM7X01A)	:= 0x00200100#0x10000100
-initrd_phys-$(CONFIG_ARCH_MSM7X01A)	:= #0x10800000
+   zreladdr-$(CONFIG_ARCH_MSM7X01A)	:= 0x10008000
+params_phys-$(CONFIG_ARCH_MSM7X01A)	:= 0x10000100
+initrd_phys-$(CONFIG_ARCH_MSM7X01A)	:= 0x10800000
 
 # MSM7x25
    zreladdr-$(CONFIG_ARCH_MSM7X25)	:= 0x00208000
@@ -48,6 +48,6 @@
    zreladdr-$(CONFIG_ARCH_MSM9615)	:= 0x40808000
 
 # FSM9XXX
-   zreladdr-$(CONFIG_ARCH_FSM9XXX)	:= 0x00208000#0x10008000
-params_phys-$(CONFIG_ARCH_FSM9XXX)	:= 0x00200100#0x10000100
+   zreladdr-$(CONFIG_ARCH_FSM9XXX)	:= 0x10008000
+params_phys-$(CONFIG_ARCH_FSM9XXX)	:= 0x10000100
 initrd_phys-$(CONFIG_ARCH_FSM9XXX)	:= 0x12000000
diff -ru final2/arch/arm/mach-msm/memory.c ics/arch/arm/mach-msm/memory.c
--- final2/arch/arm/mach-msm/memory.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/memory.c	2013-04-19 11:37:14.000000000 +0200
@@ -44,7 +44,7 @@
 
 void map_page_strongly_ordered(void)
 {
-#if defined(CONFIG_ARCH_MSM7X27) || defined(CONFIG_ARCH_MSM7X27A)
+#if defined(CONFIG_ARCH_MSM7X27) && !defined(CONFIG_ARCH_MSM7X27A)
 	long unsigned int phys;
 	struct map_desc map;
 
@@ -67,7 +67,7 @@
 
 void write_to_strongly_ordered_memory(void)
 {
-#if defined(CONFIG_ARCH_MSM7X27) || defined(CONFIG_ARCH_MSM7X27A)
+#if defined(CONFIG_ARCH_MSM7X27) && !defined(CONFIG_ARCH_MSM7X27A)
 	if (!strongly_ordered_page) {
 		if (!in_interrupt())
 			map_page_strongly_ordered();
diff -ru final2/arch/arm/mach-msm/modem_notifier.c ics/arch/arm/mach-msm/modem_notifier.c
--- final2/arch/arm/mach-msm/modem_notifier.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/modem_notifier.c	2013-04-19 11:37:14.000000000 +0200
@@ -22,8 +22,6 @@
 #include <linux/workqueue.h>
 
 #include "modem_notifier.h"
-#include <linux/sec_debug.h>
-#include <asm/cacheflush.h>
 
 #define DEBUG
 
diff -ru final2/arch/arm/mach-msm/msm_vibrator.c ics/arch/arm/mach-msm/msm_vibrator.c
--- final2/arch/arm/mach-msm/msm_vibrator.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/msm_vibrator.c	2013-04-19 11:37:14.000000000 +0200
@@ -18,240 +18,82 @@
 #include <linux/platform_device.h>
 #include <linux/err.h>
 #include <linux/hrtimer.h>
-#include <linux/clk.h>
-#include <../../../drivers/staging/android/timed_output.h>
 #include <linux/sched.h>
+#include "pmic.h"
+#include "timed_output.h"
 
 #include <mach/msm_rpcrouter.h>
 
-//#include <mach/clk.h>
-#include <mach/samsung_vibe.h>
-#include <mach/gpio.h>
-#include <mach/vreg.h>
-#include <linux/delay.h>
-#include <linux/regulator/consumer.h>
-#include <linux/workqueue.h>
-#include <mach/pmic.h>
-
-struct work_struct	 vibe_work;
-
-struct clk *android_vib_clk; /* gp_clk */
-
-#define GP_CLK_M_DEFAULT			21
-#define GP_CLK_N_DEFAULT			18000
-#define GP_CLK_D_DEFAULT			9000	/* 50% duty cycle */ 
-#define IMM_PWM_MULTIPLIER		    17778	/* Must be integer */
-
-/*
- * ** Global variables for LRA PWM M,N and D values.
- * */
-VibeInt32 g_nLRA_GP_CLK_M = GP_CLK_M_DEFAULT;
-VibeInt32 g_nLRA_GP_CLK_N = GP_CLK_N_DEFAULT;
-VibeInt32 g_nLRA_GP_CLK_D = GP_CLK_N_DEFAULT;
-VibeInt32 g_nLRA_GP_CLK_PWM_MUL = IMM_PWM_MULTIPLIER;
-
-static struct hrtimer vibe_timer;
-static struct regulator *vreg_msm_vibrator;
-static int enabled = 0;
-
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE_I)
-static int is_vibe_on;
-#endif
-
-#if defined(CONFIG_MACH_KYLE_I)
-#define VIB_ON_GPIO		111
-#endif
-
-static int msm_vibrator_suspend(struct platform_device *pdev, pm_message_t state);
-static int msm_vibrator_resume(struct platform_device *pdev);
-static int msm_vibrator_probe(struct platform_device *pdev);
-static int msm_vibrator_exit(struct platform_device *pdev);
-static int msm_vibrator_power(int power_mode);
-
-
-/* Variable for setting PWM in Force Out Set */
-VibeInt32 g_nForce_32 = 0;
-
-/*
- * This function is used to set and re-set the GP_CLK M and N counters
- * to output the desired target frequency.
- * 
- */
-
-/* for the suspend/resume VIBRATOR Module */
-static struct platform_driver msm_vibrator_platdrv = 
-{
-	.probe   = msm_vibrator_probe,
-	.suspend = msm_vibrator_suspend,
-	.resume  = msm_vibrator_resume,
-	.remove  = msm_vibrator_exit,
-	.driver = 
-	{
-		.name = MODULE_NAME,
-		.owner = THIS_MODULE,
-	},
-};
-
-static int msm_vibrator_suspend(struct platform_device *pdev, pm_message_t state)
-{
-
-#if 0
-	if(is_vibe_on) {
-		clk_disable(android_vib_clk);
-		is_vibe_on = 0;
-	}
-#endif
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE_I)
-	msm_vibrator_power(VIBRATION_OFF);
+#define PM_LIBPROG      0x30000061
+#if (CONFIG_MSM_AMSS_VERSION == 6220) || (CONFIG_MSM_AMSS_VERSION == 6225)
+#define PM_LIBVERS      0xfb837d0b
+#else
+#define PM_LIBVERS      0x10001
 #endif
-	printk("[VIB] susepend\n");
-	return VIBE_S_SUCCESS;
-}
-
-static int msm_vibrator_resume(struct platform_device *pdev)
-{
-
-	//	msm_vibrator_power(VIBRATION_ON);
 
-	printk("[VIB] resume\n");
-	return VIBE_S_SUCCESS;
-}
-
-static int msm_vibrator_exit(struct platform_device *pdev)
-{
-	printk("[VIB] EXIT\n");
-	return 0;
-}
+#define HTC_PROCEDURE_SET_VIB_ON_OFF	21
+#define PMIC_VIBRATOR_LEVEL	(3000)
 
+static struct work_struct work_vibrator_on;
+static struct work_struct work_vibrator_off;
+static struct hrtimer vibe_timer;
 
-static int msm_vibrator_power(int on)
+#ifdef CONFIG_PM8XXX_RPC_VIBRATOR
+static void set_pmic_vibrator(int on)
 {
-	int ret = 0;
-#if !defined(CONFIG_MACH_AMAZING_CDMA) && !defined(CONFIG_MACH_KYLE_I)
-	if (on) {
-#if defined(CONFIG_MACH_KYLE)
-		ret = regulator_set_voltage(vreg_msm_vibrator, 3050000, 3050000);
-#else
-		ret = regulator_set_voltage(vreg_msm_vibrator, 3000000,3000000);
-#endif
-		if (ret) {
-			printk(KERN_ERR "%s: vreg set level failed (%d)\n",
-					__func__, ret);
-			regulator_put(vreg_msm_vibrator);
-			return -EIO;
-		}
-		if (!enabled) {
-			enabled = 1;
-			ret = regulator_enable(vreg_msm_vibrator);
-		}
-		if (ret) {
-			printk(KERN_ERR "%s: vreg enable failed (%d)\n",
-					__func__, ret);
-			return -EIO;
-		}
-		mdelay(10);
-	}
-	else {
-		if (enabled) {
-			enabled = 0;
-			ret = regulator_disable(vreg_msm_vibrator);
-		}
-		if (ret) {
-			printk(KERN_ERR "%s: vreg disable failed (%d)\n",
-					__func__, ret);
-			return -EIO;
-		}
-	}
-#else
-	static int nStatus;
-	unsigned int vib_voltage = 0;
-
-	printk(KERN_DEBUG "%s on = %d nStatus = %d\n", __func__, on, nStatus);
+	int rc;
 
-	if (nStatus == on)	{
-		printk(KERN_DEBUG "%s set already!\n", __func__);
-		return VIBE_E_FAIL;
-	}
-	else {
-		nStatus = on;
+	rc = pmic_vib_mot_set_mode(PM_VIB_MOT_MODE__MANUAL);
+	if (rc) {
+		pr_err("%s: Vibrator set mode failed", __func__);
+		return;
 	}
 
-	vib_voltage = 3100;
-
-#if defined(CONFIG_MACH_KYLE_I)
 	if (on)
-	{
-		ret = pmic_vib_mot_set_volt(vib_voltage);
-		gpio_set_value_cansleep(VIB_ON_GPIO,1);
-	}
+		rc = pmic_vib_mot_set_volt(PMIC_VIBRATOR_LEVEL);
 	else
-	{
-		ret = pmic_vib_mot_set_volt(0);
-		gpio_set_value_cansleep(VIB_ON_GPIO,0);
-	}
+		rc = pmic_vib_mot_set_volt(0);
 
-#else
-	if (on)
-		ret = pmic_vib_mot_set_volt(vib_voltage);
-	else
-		ret = pmic_vib_mot_set_volt(0);
-#endif
-	printk(KERN_DEBUG "%s status = %d\n", __func__, ret);
-#endif
-	return VIBE_S_SUCCESS;
+	if (rc)
+		pr_err("%s: Vibrator set voltage level failed", __func__);
 }
-
-
-#if 0
-static int vibe_set_pwm_freq(int nForce)
-{
-#if 1
-	/* Put the MND counter in reset mode for programming */
-	HWIO_OUTM(GP_NS_REG, HWIO_GP_NS_REG_MNCNTR_EN_BMSK, 0);
-	HWIO_OUTM(GP_NS_REG, HWIO_GP_NS_REG_PRE_DIV_SEL_BMSK, 0 << HWIO_GP_NS_REG_PRE_DIV_SEL_SHFT); /* P: 0 => Freq/1, 1 => Freq/2, 4 => Freq/4 */
-	HWIO_OUTM(GP_NS_REG, HWIO_GP_NS_REG_SRC_SEL_BMSK, 0 << HWIO_GP_NS_REG_SRC_SEL_SHFT); /* S : 0 => TXCO(19.2MHz), 1 => Sleep XTAL(32kHz) */
-	HWIO_OUTM(GP_NS_REG, HWIO_GP_NS_REG_MNCNTR_MODE_BMSK, 2 << HWIO_GP_NS_REG_MNCNTR_MODE_SHFT); /* Dual-edge mode */
-	HWIO_OUTM(GP_MD_REG, HWIO_GP_MD_REG_M_VAL_BMSK, g_nLRA_GP_CLK_M << HWIO_GP_MD_REG_M_VAL_SHFT);
-	g_nForce_32 = ((nForce * g_nLRA_GP_CLK_PWM_MUL) >> 8) + g_nLRA_GP_CLK_D;
-	//		printk("%s, g_nForce_32 : %d\n",__FUNCTION__,g_nForce_32);
-	HWIO_OUTM(GP_MD_REG, HWIO_GP_MD_REG_D_VAL_BMSK, ( ~((VibeInt16)g_nForce_32 << 1) ) << HWIO_GP_MD_REG_D_VAL_SHFT);
-	HWIO_OUTM(GP_NS_REG, HWIO_GP_NS_REG_GP_N_VAL_BMSK, ~(g_nLRA_GP_CLK_N - g_nLRA_GP_CLK_M) << HWIO_GP_NS_REG_GP_N_VAL_SHFT);
-	HWIO_OUTM(GP_NS_REG, HWIO_GP_NS_REG_MNCNTR_EN_BMSK, 1 << HWIO_GP_NS_REG_MNCNTR_EN_SHFT);                    /* Enable M/N counter */
-	printk("%x, %x, %x\n",( ~((VibeInt16)g_nForce_32 << 1) ) << HWIO_GP_MD_REG_D_VAL_SHFT,~(g_nLRA_GP_CLK_N - g_nLRA_GP_CLK_M) << HWIO_GP_NS_REG_GP_N_VAL_SHFT,1 << HWIO_GP_NS_REG_MNCNTR_EN_SHFT);
 #else
-	clk_set_rate(android_vib_clk,32583);
-#endif	
-	return VIBE_S_SUCCESS;
-}
-
-
 static void set_pmic_vibrator(int on)
 {
-	//	printk("[VIB] %s, input : %s\n",__func__,on ? "ON":"OFF");
-	if (on) {
-		clk_enable(android_vib_clk);
-		gpio_direction_output(VIB_ON, VIBRATION_ON);
-		is_vibe_on = 1;
-	} else {
-		if(is_vibe_on) {
-			gpio_direction_output(VIB_ON, VIBRATION_OFF);
-			clk_disable(android_vib_clk);
-			is_vibe_on = 0;
+	static struct msm_rpc_endpoint *vib_endpoint;
+	struct set_vib_on_off_req {
+		struct rpc_request_hdr hdr;
+		uint32_t data;
+	} req;
+
+	if (!vib_endpoint) {
+		vib_endpoint = msm_rpc_connect(PM_LIBPROG, PM_LIBVERS, 0);
+		if (IS_ERR(vib_endpoint)) {
+			printk(KERN_ERR "init vib rpc failed!\n");
+			vib_endpoint = 0;
+			return;
 		}
 	}
 
+
+	if (on)
+		req.data = cpu_to_be32(PMIC_VIBRATOR_LEVEL);
+	else
+		req.data = cpu_to_be32(0);
+
+	msm_rpc_call(vib_endpoint, HTC_PROCEDURE_SET_VIB_ON_OFF, &req,
+		sizeof(req), 5 * HZ);
 }
 #endif
 
-#if 0
 static void pmic_vibrator_on(struct work_struct *work)
 {
-	set_pmic_vibrator(VIBRATION_ON);
+	set_pmic_vibrator(1);
 }
 
 static void pmic_vibrator_off(struct work_struct *work)
 {
-	set_pmic_vibrator(VIBRATION_OFF);
+	set_pmic_vibrator(0);
 }
 
 static void timed_vibrator_on(struct timed_output_dev *sdev)
@@ -263,41 +105,21 @@
 {
 	schedule_work(&work_vibrator_off);
 }
-//#else
-static void pmic_vibrator_on(void)
-{
-	set_pmic_vibrator(VIBRATION_ON);
-	msm_vibrator_power(VIBRATION_ON);
-}
-
-static void pmic_vibrator_off(void)
-{
-	msm_vibrator_power(VIBRATION_OFF);
-	set_pmic_vibrator(VIBRATION_OFF);
-}
-
-#endif
 
 static void vibrator_enable(struct timed_output_dev *dev, int value)
 {
-	unsigned long flags;
-
 	hrtimer_cancel(&vibe_timer);
-	printk(KERN_ERR "[VIB] enable %d\n", value);
-	if (value == 0) {
-		msm_vibrator_power(VIBRATION_OFF);
-	}
-	else {
-		if(value < 0)
-			value = ~value;
-		printk(KERN_ERR "[VIB] ON, %d ms\n", value);
 
+	if (value == 0)
+		timed_vibrator_off(dev);
+	else {
 		value = (value > 15000 ? 15000 : value);
-		msm_vibrator_power(VIBRATION_ON);
+
+		timed_vibrator_on(dev);
 
 		hrtimer_start(&vibe_timer,
-				ktime_set(value / 1000, (value % 1000) * 1000000),
-				HRTIMER_MODE_REL);
+			      ktime_set(value / 1000, (value % 1000) * 1000000),
+			      HRTIMER_MODE_REL);
 	}
 }
 
@@ -305,74 +127,16 @@
 {
 	if (hrtimer_active(&vibe_timer)) {
 		ktime_t r = hrtimer_get_remaining(&vibe_timer);
-		return (ktime_to_ms(r));
-	} else
-		return 0;
-}
-
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_KYLE_I)
-static int vibrator_timer_do_work(struct work_struct *ignored)
-{
-	unsigned int remain;
-
-	printk(KERN_DEBUG "[VIB] %s\n", __func__);
-
-	if (hrtimer_active(&vibe_timer)) {
-		ktime_t r = hrtimer_get_remaining(&vibe_timer);
-		remain = r.tv.sec * 1000000 + r.tv.nsec;
-		remain = remain / 1000;
-		if (r.tv.sec < 0)
-			remain = 0;
-		printk(KERN_DEBUG "[VIB] hrtimer active, remain:%d\n", remain);
-
-		if (!remain)
-			msm_vibrator_power(VIBRATION_OFF);
-	}
-	else {
-		printk(KERN_DEBUG "[VIB] hrtimer not active\n");
-		msm_vibrator_power(VIBRATION_OFF);
+		struct timeval t = ktime_to_timeval(r);
+		return t.tv_sec * 1000 + t.tv_usec / 1000;
 	}
-
 	return 0;
 }
 
-
-static DECLARE_WORK(vibrator_timer_work, vibrator_timer_do_work);
-#endif
-
-
 static enum hrtimer_restart vibrator_timer_func(struct hrtimer *timer)
 {
-#if 0
 	timed_vibrator_off(NULL);
 	return HRTIMER_NORESTART;
-#else
-	unsigned int remain;
-
-	printk("[VIB] %s\n",__func__);
-#if !defined(CONFIG_MACH_AMAZING_CDMA) && !defined(CONFIG_MACH_KYLE) && !defined(CONFIG_MACH_KYLE_I)
-	if(hrtimer_active(&vibe_timer)) {
-		ktime_t r = hrtimer_get_remaining(&vibe_timer);
-		remain=ktime_to_ms(r);
-		remain = remain / 1000;
-		if(r.tv.sec < 0) {
-			remain = 0;
-		}
-		printk("[VIB] hrtimer active, remain:%d\n",remain);
-		if(!remain) {
-			msm_vibrator_power(VIBRATION_OFF);
-		}
-
-	} else {
-		printk("[VIB] hrtimer not active\n");
-		msm_vibrator_power(VIBRATION_OFF);
-	}
-#else
-	schedule_work(&vibrator_timer_work);
-#endif
-
-	return HRTIMER_NORESTART;
-#endif
 }
 
 static struct timed_output_dev pmic_vibrator = {
@@ -381,85 +145,17 @@
 	.enable = vibrator_enable,
 };
 
-static int msm_vibrator_power_work()
+void __init msm_init_pmic_vibrator(void)
 {
-	return(msm_vibrator_power(VIBRATION_OFF));
-}
-
-static int msm_vibrator_probe(struct platform_device *pdev)
-{
-	int rc;
+	INIT_WORK(&work_vibrator_on, pmic_vibrator_on);
+	INIT_WORK(&work_vibrator_off, pmic_vibrator_off);
 
-#if !defined(CONFIG_MACH_AMAZING_CDMA) && !defined(CONFIG_MACH_KYLE) && !defined(CONFIG_MACH_KYLE_I)
-	INIT_WORK(&vibe_work, msm_vibrator_power_work);
-#endif
 	hrtimer_init(&vibe_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
 	vibe_timer.function = vibrator_timer_func;
 
-	rc = timed_output_dev_register(&pmic_vibrator);
-
-	if (rc < 0)
-		goto err_read_vib;
-#if 0
-	msm_vibrator_power(VIBRATION_ON);
-
-	/* Vibrator init sequence
-	 * 1. power on ( vreg get )
-	 * 2. clock get & enable ( gp_clk )
-	 * 3. VIB_EN on
-	 */
-
-	android_vib_clk = clk_get(NULL,"gp_clk");
-
-	if(IS_ERR(android_vib_clk)) {
-		printk("android vib clk failed!!!\n");
-	} else {
-		printk("THNAK YOU!!\n");
-	}
-	vibe_set_pwm_freq(216);
-#endif
-	return 0;
-
-err_read_vib:
-	printk(KERN_ERR "[VIB] timed_output_dev_register fail (rc=%d)\n", rc);
-	return rc;
+	timed_output_dev_register(&pmic_vibrator);
 }
 
-static int __init msm_init_pmic_vibrator(void)
-{
-	int nRet;
-
-	nRet = platform_driver_register(&msm_vibrator_platdrv);
-
-	printk("[VIB] platform driver register result : %d\n",nRet);
-	if (nRet)
-	{ 
-		printk("[VIB] platform_driver_register failed\n");
-	}
-#if !defined(CONFIG_MACH_AMAZING_CDMA) && !defined(CONFIG_MACH_KYLE_I)
-	vreg_msm_vibrator = regulator_get(NULL, "ldo01");
-
-	if (IS_ERR (vreg_msm_vibrator)) {
-		printk(KERN_ERR "%s: vreg get failed (%ld)\n",
-				__func__, PTR_ERR(vreg_msm_vibrator));
-		return PTR_ERR(vreg_msm_vibrator);
-	}
-#endif
-
-	return nRet;
-
-}
-
-void __exit msm_exit_pmic_vibrator(void)
-{
-	platform_driver_unregister(&msm_vibrator_platdrv);
-
-}
-
-module_init(msm_init_pmic_vibrator);
-module_exit(msm_exit_pmic_vibrator);
-
-
 MODULE_DESCRIPTION("timed output pmic vibrator device");
 MODULE_LICENSE("GPL");
 
diff -ru final2/arch/arm/mach-msm/pm2.c ics/arch/arm/mach-msm/pm2.c
--- final2/arch/arm/mach-msm/pm2.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/pm2.c	2013-04-19 11:37:14.000000000 +0200
@@ -29,9 +29,6 @@
 #include <linux/uaccess.h>
 #include <linux/io.h>
 #include <linux/memory.h>
-
-#include <mach/vreg.h>
-#include <mach/gpio-v1.h>
 #ifdef CONFIG_HAS_WAKELOCK
 #include <linux/wakelock.h>
 #endif
@@ -65,8 +62,6 @@
 #include "spm.h"
 #include "sirc.h"
 #include "pm-boot.h"
-#include <linux/sec_param.h>
-#include <linux/regulator/consumer.h>
 
 /******************************************************************************
  * Debug Definitions
@@ -82,8 +77,7 @@
 	MSM_PM_DEBUG_IDLE = 1U << 6,
 };
 
-static int msm_pm_debug_mask = MSM_PM_DEBUG_POWER_COLLAPSE |
-					MSM_PM_DEBUG_SMSM_STATE;
+static int msm_pm_debug_mask;
 module_param_named(
 	debug_mask, msm_pm_debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP
 );
@@ -177,9 +171,6 @@
 static struct attribute **msm_pm_mode_attrs[MSM_PM_SLEEP_MODE_NR];
 static struct kobj_attribute *msm_pm_mode_kobj_attrs[MSM_PM_SLEEP_MODE_NR];
 
-static DEFINE_SPINLOCK(pm_lock);
-int power_off_done;
-
 /*
  * Write out the attribute.
  */
@@ -972,7 +963,6 @@
  *
  *****************************************************************************/
 static struct msm_pm_smem_t *msm_pm_smem_data;
-static uint32_t *msm_pm_reset_vector;
 static atomic_t msm_pm_init_done = ATOMIC_INIT(0);
 
 static int msm_pm_modem_busy(void)
@@ -1004,12 +994,9 @@
 	int collapsed = 0;
 	int ret;
 
-	if (!from_idle)
-		MSM_PM_DPRINTK(MSM_PM_DEBUG_SUSPEND|MSM_PM_DEBUG_POWER_COLLAPSE,
-				KERN_INFO,
-				"%s(): idle %d, delay %u, limit %u\n",
-				__func__, (int)from_idle,
-				sleep_delay, sleep_limit);
+	MSM_PM_DPRINTK(MSM_PM_DEBUG_SUSPEND|MSM_PM_DEBUG_POWER_COLLAPSE,
+		KERN_INFO, "%s(): idle %d, delay %u, limit %u\n", __func__,
+		(int)from_idle, sleep_delay, sleep_limit);
 
 	if (!(smsm_get_state(SMSM_POWER_MASTER_DEM) & DEM_MASTER_SMSM_READY)) {
 		MSM_PM_DPRINTK(
@@ -1038,8 +1025,7 @@
 			DEM_SLAVE_SMSM_PWRC | DEM_SLAVE_SMSM_PWRC_SUSPEND);
 
 	MSM_PM_DEBUG_PRINT_STATE("msm_pm_power_collapse(): PWRC");
-	if (!from_idle)
-		MSM_PM_DEBUG_PRINT_SLEEP_INFO();
+	MSM_PM_DEBUG_PRINT_SLEEP_INFO();
 
 	memset(state_grps, 0, sizeof(state_grps));
 	state_grps[0].group_id = SMSM_POWER_MASTER_DEM;
@@ -1070,14 +1056,11 @@
 
 	ret = msm_irq_enter_sleep2(true, from_idle);
 	if (ret < 0) {
-		if (!from_idle)
-			MSM_PM_DPRINTK(
-					MSM_PM_DEBUG_SUSPEND|
-					MSM_PM_DEBUG_POWER_COLLAPSE,
-					KERN_INFO,
-					"%s(): msm_irq_enter_sleep2"
-					" aborted, %d\n",
-					__func__, ret);
+		MSM_PM_DPRINTK(
+			MSM_PM_DEBUG_SUSPEND|MSM_PM_DEBUG_POWER_COLLAPSE,
+			KERN_INFO,
+			"%s(): msm_irq_enter_sleep2 aborted, %d\n", __func__,
+			ret);
 		goto power_collapse_early_exit;
 	}
 
@@ -1123,18 +1106,13 @@
 		local_fiq_enable();
 	}
 
-	if (!from_idle)
-		MSM_PM_DPRINTK(MSM_PM_DEBUG_SUSPEND |
-				MSM_PM_DEBUG_POWER_COLLAPSE,
-				KERN_INFO,
-				"%s(): msm_pm_collapse returned %d\n",
-				__func__, collapsed);
+	MSM_PM_DPRINTK(MSM_PM_DEBUG_SUSPEND | MSM_PM_DEBUG_POWER_COLLAPSE,
+		KERN_INFO,
+		"%s(): msm_pm_collapse returned %d\n", __func__, collapsed);
 
 	MSM_PM_DPRINTK(MSM_PM_DEBUG_CLOCK, KERN_INFO,
 		"%s(): restore clock rate to %lu\n", __func__,
 		saved_acpuclk_rate);
-	if (acpuclk_max_rate > 0)
-		saved_acpuclk_rate = acpuclk_max_rate;
 	if (acpuclk_set_rate(smp_processor_id(), saved_acpuclk_rate,
 			SETRATE_PC) < 0)
 		printk(KERN_ERR "%s(): failed to restore clock rate(%lu)\n",
@@ -1215,8 +1193,7 @@
 	/* DEM Master == RUN */
 
 	MSM_PM_DEBUG_PRINT_STATE("msm_pm_power_collapse(): WFPI RUN");
-	if (!from_idle)
-		MSM_PM_DEBUG_PRINT_SLEEP_INFO();
+	MSM_PM_DEBUG_PRINT_SLEEP_INFO();
 
 	msm_irq_exit_sleep2(msm_pm_smem_data->irq_mask,
 		msm_pm_smem_data->wakeup_reason,
@@ -1667,7 +1644,6 @@
 #endif
 
 		clock_debug_print_enabled();
-		regulator_showall_enabled();
 
 #ifdef CONFIG_MSM_SLEEP_TIME_OVERRIDE
 		if (msm_pm_sleep_time_override > 0) {
@@ -1741,138 +1717,40 @@
 /******************************************************************************
  * Restart Definitions
  *****************************************************************************/
-#define SEC_DEBUG_LEVEL_LOW 0x4674AEAF
-#define SEC_DEBUG_LEVEL_MID 0x4674BEBF
-#define SEC_DEBUG_LEVEL_HIGH 0x4674CECF
 
 static uint32_t restart_reason = 0x776655AA;
 
 static void msm_pm_power_off(void)
 {
-	unsigned long flags;
-	unsigned int power_off_reason;
-	unsigned size = 0;
- 	samsung_vendor1_id *smem_vendor1 = \
-		(samsung_vendor1_id *)smem_get_entry(SMEM_ID_VENDOR1, &size);	
-
-	printk(KERN_INFO " %s\n", __func__);
-   
-    if (smem_vendor1) {
-    	smem_vendor1->AP_reserved[0] = 0;
-    } else {
-    	printk(KERN_EMERG "smem_flag is NULL\n");
-    }
-
 	msm_rpcrouter_close();
-
-#if defined(CONFIG_SEC_DEBUG) && defined(CONFIG_SEC_MISC)
-	sec_get_param(param_power_off_reason, &power_off_reason);
-	power_off_reason = power_off_reason | 0x40;
-	sec_set_param(param_power_off_reason, &power_off_reason);
-#endif
-	printk(KERN_INFO " %s before proc_comm\n", __func__);
 	msm_proc_comm(PCOM_POWER_DOWN, 0, 0);
-
-	power_off_done = 1;
-
-	spin_lock_irqsave(&pm_lock, flags);
 	for (;;)
 		;
-	spin_unlock_irqrestore(&pm_lock, flags);
 }
 
 static void msm_pm_restart(char str, const char *cmd)
 {
-	unsigned size;
-	unsigned long flags;
-	unsigned int power_off_reason;
-	samsung_vendor1_id *smem_vendor1 = \
-		(samsung_vendor1_id *)smem_get_entry(SMEM_ID_VENDOR1, &size);
-
-	if (smem_vendor1) {
-		smem_vendor1->silent_reset = 0xAEAEAEAE;
-		smem_vendor1->reboot_reason = restart_reason;
-		smem_vendor1->AP_reserved[0] = 0;	// for sudden reset ramdump mode
-	} else {
-		printk(KERN_EMERG "smem_flag is NULL\n");
-	}
-
-#if defined(CONFIG_MACH_KYLE)
-	printk(KERN_EMERG "msm_batt_progress is %d\n", msm_batt_progress);
-	while (msm_batt_progress)
-		;
-	printk(KERN_EMERG "msm_batt_progress is %d\n", msm_batt_progress);
-#else
 	msm_rpcrouter_close();
-#endif
-
-#if defined(CONFIG_SEC_DEBUG) && defined(CONFIG_SEC_MISC)
-	sec_get_param(param_power_off_reason, &power_off_reason);
-	power_off_reason = power_off_reason | 0x10;
-	sec_set_param(param_power_off_reason, &power_off_reason);
-#endif
-
-#if defined(CONFIG_MACH_KYLE)
-	msm_proc_comm(PCOM_RESET_CHIP_IMM, &restart_reason, 0);
-#else
 	msm_proc_comm(PCOM_RESET_CHIP, &restart_reason, 0);
-#endif
 
-	power_off_done = 1;
-
-	spin_lock_irqsave(&pm_lock, flags);
 	for (;;)
 		;
-	spin_unlock_irqrestore(&pm_lock, flags);
 }
 
 static int msm_reboot_call
 	(struct notifier_block *this, unsigned long code, void *_cmd)
 {
-	int dump_enable_flag;
-	unsigned size;
-	unsigned int debug_level, rory_control;
-	unsigned long value;
-
-	samsung_vendor1_id *smem_vendor1 = \
-		(samsung_vendor1_id *)smem_get_entry(SMEM_ID_VENDOR1, &size);
-
 	if ((code == SYS_RESTART) && _cmd) {
 		char *cmd = _cmd;
 		if (!strcmp(cmd, "bootloader")) {
 			restart_reason = 0x77665500;
 		} else if (!strcmp(cmd, "recovery")) {
 			restart_reason = 0x77665502;
-		} else if (!strcmp(cmd, "recovery_done")) {
-			restart_reason = 0x77665503;
 		} else if (!strcmp(cmd, "eraseflash")) {
 			restart_reason = 0x776655EF;
-		} else if (!strcmp(cmd, "download")) {
-			restart_reason = 0x776655FF;
-		} else if (!strncmp(cmd, "sud", 3)) {
-			restart_reason = 0xabcf0000 | (cmd[3] - '0');
-                } else if (!strncmp(cmd, "oem-", 4)) {
+		} else if (!strncmp(cmd, "oem-", 4)) {
 			unsigned code = simple_strtoul(cmd + 4, 0, 16) & 0xff;
 			restart_reason = 0x6f656d00 | code;
-		} else if (!strncmp(cmd, "arm11_fota", 10)) {
-			restart_reason = 0x77665504;
-		} else if (!strncmp(cmd, "debug", 5)
-				&& !kstrtoul(cmd + 5, 0, &value)) {
-			restart_reason = 0xabcd0000 | value;
-
-			if (value == 0x4f4c) {
-				debug_level = SEC_DEBUG_LEVEL_LOW;
-				dump_enable_flag = 0;
-			} else if (value == 0x494d) {
-				debug_level = SEC_DEBUG_LEVEL_MID;
-				dump_enable_flag = 1;
-			} else if (value == 0x4948) {
-				debug_level = SEC_DEBUG_LEVEL_HIGH;
-				dump_enable_flag = 2;
-			}
-
-			sec_get_param(param_index_debuglevel, &debug_level);
-			smem_vendor1->ram_dump_level = debug_level;
 		} else {
 			restart_reason = 0x77665501;
 		}
@@ -1966,12 +1844,7 @@
 	atomic_set(&msm_pm_init_done, 1);
 	suspend_set_ops(&msm_pm_ops);
 
-	ret = msm_pm_mode_sysfs_add();
-	if (ret) {
-		printk(KERN_ERR "%s: failed to add sysfs node, %d\n",
-			__func__, ret);
-		return ret;
-	}
+	msm_pm_mode_sysfs_add();
 #ifdef CONFIG_MSM_IDLE_STATS
 	d_entry = create_proc_entry("msm_pm_stats",
 			S_IRUGO | S_IWUSR | S_IWGRP, NULL);
diff -ru final2/arch/arm/mach-msm/pm.h ics/arch/arm/mach-msm/pm.h
--- final2/arch/arm/mach-msm/pm.h	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/pm.h	2013-04-19 11:37:14.000000000 +0200
@@ -27,10 +27,6 @@
 #define msm_secondary_startup NULL
 #endif
 
-#if defined(CONFIG_MACH_KYLE)
-extern int msm_batt_progress;
-#endif
-
 enum msm_pm_sleep_mode {
 	MSM_PM_SLEEP_MODE_POWER_COLLAPSE_SUSPEND,
 	MSM_PM_SLEEP_MODE_POWER_COLLAPSE,
diff -ru final2/arch/arm/mach-msm/pmic_debugfs.c ics/arch/arm/mach-msm/pmic_debugfs.c
--- final2/arch/arm/mach-msm/pmic_debugfs.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/pmic_debugfs.c	2013-04-19 11:37:14.000000000 +0200
@@ -1065,6 +1065,7 @@
 	if (copy_from_user(debug_buf, buff, count))
 		return -EFAULT;
 
+
 	debug_buf[count] = 0;	/* end of string */
 
 	pd = &pmic_debug[debug_proc];
diff -ru final2/arch/arm/mach-msm/proc_comm.c ics/arch/arm/mach-msm/proc_comm.c
--- final2/arch/arm/mach-msm/proc_comm.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/proc_comm.c	2013-04-19 11:37:14.000000000 +0200
@@ -80,14 +80,6 @@
 	unsigned base = (unsigned)MSM_SHARED_RAM_BASE;
 	unsigned long flags;
 
-#ifdef CONFIG_SEC_DEBUG
-	samsung_vendor1_id *smem_vendor1 = NULL;
-	unsigned size;
-	smem_vendor1 = (samsung_vendor1_id *)smem_get_entry\
-			(SMEM_ID_VENDOR1, &size);
-	smem_vendor1->apps_dump.apps = 0xf0;
-#endif /* CONFIG_SEC_DEBUG */
-
 	spin_lock_irqsave(&proc_comm_lock, flags);
 
 again:
diff -ru final2/arch/arm/mach-msm/proc_comm.h ics/arch/arm/mach-msm/proc_comm.h
--- final2/arch/arm/mach-msm/proc_comm.h	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/proc_comm.h	2013-04-19 11:37:14.000000000 +0200
@@ -141,44 +141,14 @@
 	PCOM_CLKCTL_RPC_SET_EXT_CONFIG,
 };
 
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
 enum {
 	PCOM_OEM_FIRST_CMD = 0x10000000,
 	PCOM_OEM_TEST_CMD = PCOM_OEM_FIRST_CMD,
-	PCOM_OEM_CHARGING_CURRENT,
-	PCOM_OEM_CHARGING_INFO,
-	PCOM_OEM_VF_GET,
-	PCOM_OEM_TEMP_ADC_GET,
-	PCOM_OEM_TEMP_DEGREE_GET,
-	PCOM_OEM_BATT_AVER_GET,
-	PCOM_OEM_CHARGE_STATE_GET,
-	PCOM_OEM_FUEL_ALERT_CHECK,
-	PCOM_OEM_POWER_KEY_GET,
-#ifdef CONFIG_RTC_AUTO_PWRON
-	PCOM_OEM_SYS_CMD,
-#endif
-	PCOM_OEM_MICBIAS_ONOFF,
-	PCOM_OEM_CHARGING_INFO_SET,
-	PCOM_OEM_CALL_STATE_GET,
-	PCOM_OEM_TRICKEL_CHARGING_CURRENT_SET,
-	PCOM_OEM_CUT_OFF_CURRENT_SET,
-	PCOM_OEM_USB_ATTACHED_GET,
-	PCOM_OEM_USB_TYPE_SET,
-	PCOM_OEM_KEYLED_SET,
-	PCOM_OEM_SAMSUNG_LAST,
-	PCOM_OEM_LAST = PCOM_OEM_SAMSUNG_LAST,
-};
-#else
-enum {
-	PCOM_OEM_FIRST_CMD = 0x10000000,
-	PCOM_OEM_TEST_CMD = PCOM_OEM_FIRST_CMD,
-	PCOM_OEM_CHARGING_INFO,
-	PCOM_OEM_POWER_KEY_GET,
-	PCOM_OEM_SYS_CMD,
-	PCOM_OEM_SAMSUNG_LAST,
-	PCOM_OEM_LAST = PCOM_OEM_SAMSUNG_LAST,
+
+	/* add OEM PROC COMM commands here */
+
+	PCOM_OEM_LAST = PCOM_OEM_TEST_CMD,
 };
-#endif
 
 enum {
 	PCOM_INVALID_STATUS = 0x0,
diff -ru final2/arch/arm/mach-msm/qdsp5/adsp_video_verify_cmd.c ics/arch/arm/mach-msm/qdsp5/adsp_video_verify_cmd.c
--- final2/arch/arm/mach-msm/qdsp5/adsp_video_verify_cmd.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/qdsp5/adsp_video_verify_cmd.c	2013-04-19 11:37:14.000000000 +0200
@@ -48,7 +48,7 @@
 {
 	void *phys_addr;
 	unsigned long phys_size;
-	unsigned long kvaddr = 0;
+	unsigned long kvaddr;
 
 	phys_addr = high_low_short_to_ptr(*high, *low);
 	phys_size = (unsigned long)high_low_short_to_ptr(size_high, size_low);
diff -ru final2/arch/arm/mach-msm/qdsp5/audio_aac_in.c ics/arch/arm/mach-msm/qdsp5/audio_aac_in.c
--- final2/arch/arm/mach-msm/qdsp5/audio_aac_in.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/qdsp5/audio_aac_in.c	2013-04-19 11:37:14.000000000 +0200
@@ -835,15 +835,13 @@
 		}
 		/* Allow only single frame */
 		if (audio->mode == MSM_AUD_ENC_MODE_TUNNEL) {
-			if (cfg.buffer_size != (FRAME_SIZE - 8)) {
+			if (cfg.buffer_size != (FRAME_SIZE - 8))
 				rc = -EINVAL;
 				break;
-			}
 		} else {
-			if (cfg.buffer_size != (AAC_FRAME_SIZE + 14)) {
+			if (cfg.buffer_size != (AAC_FRAME_SIZE + 14))
 				rc = -EINVAL;
 				break;
-			}
 		}
 		audio->buffer_size = cfg.buffer_size;
 		break;
diff -ru final2/arch/arm/mach-msm/qdsp5/audio_mvs.c ics/arch/arm/mach-msm/qdsp5/audio_mvs.c
--- final2/arch/arm/mach-msm/qdsp5/audio_mvs.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/qdsp5/audio_mvs.c	2013-04-19 11:37:14.000000000 +0200
@@ -1170,8 +1170,6 @@
 			       rpc_hdr_len);
 
 			break;
-		} else if ((audio->state == AUDIO_MVS_CLOSED)&&(rpc_hdr_len == 0)) {	
-			break;
 		} else if (rpc_hdr_len < RPC_COMMON_HDR_SZ) {
 			continue;
 		} else {
@@ -1338,12 +1336,8 @@
 	mutex_lock(&audio->lock);
 	if (audio->state == AUDIO_MVS_STARTED)
 		audio_mvs_stop(audio);
-	audio->state = AUDIO_MVS_CLOSED;
-	msm_rpc_read_wakeup(audio->rpc_endpt);
-	msm_rpc_close(audio->rpc_endpt);
-	audio->task = NULL;
 	audio_mvs_free_buf(audio);
-
+	audio->state = AUDIO_MVS_CLOSED;
 	mutex_unlock(&audio->lock);
 
 	MM_DBG("Release done\n");
diff -ru final2/arch/arm/mach-msm/qdsp5/audio_out.c ics/arch/arm/mach-msm/qdsp5/audio_out.c
--- final2/arch/arm/mach-msm/qdsp5/audio_out.c	2014-08-29 08:16:10.000240000 +0200
+++ ics/arch/arm/mach-msm/qdsp5/audio_out.c	2013-04-19 11:37:14.000000000 +0200
@@ -92,9 +92,7 @@
 
 
 
-//#define BUFSZ (960 * 5)
-#define BUFSZ ((960 * 5)*2)//[SGMC][rh.wang] [S7562 HKTW] enlarge buffer for mp3 play simetimes break problem
-
+#define BUFSZ (960 * 5)
 #define DMASZ (BUFSZ * 2)
 
 #define COMMON_OBJ_ID 6
diff -ru final2/arch/arm/mach-msm/qdsp5/Makefile ics/arch/arm/mach-msm/qdsp5/Makefile
--- final2/arch/arm/mach-msm/qdsp5/Makefile	2014-08-29 08:16:09.988240000 +0200
+++ ics/arch/arm/mach-msm/qdsp5/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -15,7 +15,5 @@
 obj-y += audio_evrc.o audio_qcelp.o audio_amrnb.o audio_aac.o audio_amrnb_in.o
 obj-y += audio_wma.o audio_voicememo.o audio_pcm.o audio_amrwb.o audio_wmapro.o
 obj-y += snd.o snd_adie.o
-ifndef CONFIG_DISABLE_FM_SUPPORT
 obj-$(CONFIG_ARCH_MSM7X27A) += audio_fm.o
-endif
 obj-$(CONFIG_ARCH_MSM7X27A) += audio_mvs.o
diff -ru final2/arch/arm/mach-msm/qdsp5/snd_adie.c ics/arch/arm/mach-msm/qdsp5/snd_adie.c
--- final2/arch/arm/mach-msm/qdsp5/snd_adie.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/qdsp5/snd_adie.c	2013-04-19 11:37:14.000000000 +0200
@@ -459,7 +459,7 @@
 	char name[sizeof "msm_snd_adie"];
 
 	snprintf(name, sizeof name, "msm_snd_adie");
-	dentry = debugfs_create_file(name, S_IFREG | S_IRUGO | S_IWUSR,
+	dentry = debugfs_create_file(name, S_IFREG | S_IRUGO | S_IWUGO,
 			NULL, NULL, &snd_adie_debug_fops);
 	if (IS_ERR(dentry))
 		MM_DBG("debugfs_create_file failed\n");
diff -ru final2/arch/arm/mach-msm/qdsp5/snd.c ics/arch/arm/mach-msm/qdsp5/snd.c
--- final2/arch/arm/mach-msm/qdsp5/snd.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/qdsp5/snd.c	2013-04-19 11:37:14.000000000 +0200
@@ -107,25 +107,12 @@
 	struct rpc_snd_agc_ctl_args args;
 };
 
-#if defined(CONFIG_MACH_KYLE)
-#define SAMSUNG_ALLSOUND_MUTE
-#endif
-
-#if defined(SAMSUNG_ALLSOUND_MUTE)
-#define SND_MUTE_RxMUTED 3
-#define SND_MUTE_RxUNMUTED   4
-#endif
-
 struct snd_endpoint *get_snd_endpoints(int *size);
 
 static inline int check_mute(int mute)
 {
-	return ((mute == SND_MUTE_MUTED) ||
-#if defined(SAMSUNG_ALLSOUND_MUTE)
-		(mute == SND_MUTE_RxMUTED) ||
-		(mute == SND_MUTE_RxUNMUTED) ||
-#endif
-		(mute == SND_MUTE_UNMUTED)) ? 0 : -EINVAL;
+	return (mute == SND_MUTE_MUTED ||
+		mute == SND_MUTE_UNMUTED) ? 0 : -EINVAL;
 }
 
 static int get_endpoint(struct snd_ctxt *snd, unsigned long arg)
@@ -210,15 +197,9 @@
 		vmsg.args.device = cpu_to_be32(vol.device);
 		vmsg.args.method = cpu_to_be32(vol.method);
 		if (vol.method != SND_METHOD_VOICE) {
-#if defined(CONFIG_MACH_KYLE_HKTW) || defined(CONFIG_MACH_KYLE_CHN) || defined(CONFIG_MACH_KYLE_I)
-			if (vol.method != SND_METHOD_MIDI){
-#endif				
 			MM_ERR("set volume: invalid method\n");
 			rc = -EINVAL;
 			break;
-#if defined(CONFIG_MACH_KYLE_HKTW) || defined(CONFIG_MACH_KYLE_CHN) || defined(CONFIG_MACH_KYLE_I)
-				}
-#endif				
 		}
 
 		vmsg.args.volume = cpu_to_be32(vol.volume);
@@ -516,17 +497,11 @@
 
 	vmsg.args.device = cpu_to_be32(vol.device);
 	vmsg.args.method = cpu_to_be32(vol.method);
-		if (vol.method != SND_METHOD_VOICE) {
-#if defined(CONFIG_MACH_KYLE_HKTW) || defined(CONFIG_MACH_KYLE_CHN) || defined(CONFIG_MACH_KYLE_I)
-			if (vol.method != SND_METHOD_MIDI){
-#endif						
-			MM_ERR("snd_ioctl set volume: invalid method\n");
-			rc = -EINVAL;
-			return rc;
-#if defined(CONFIG_MACH_KYLE_HKTW) || defined(CONFIG_MACH_KYLE_CHN) || defined(CONFIG_MACH_KYLE_I)			
-			}
-#endif	
-		}
+	if (vol.method != SND_METHOD_VOICE) {
+		MM_ERR("snd_ioctl set volume: invalid method\n");
+		rc = -EINVAL;
+		return rc;
+	}
 
 	vmsg.args.volume = cpu_to_be32(vol.volume);
 	vmsg.args.cb_func = -1;
diff -ru final2/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c ics/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c
--- final2/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c	2014-08-29 08:20:15.296248000 +0200
+++ ics/arch/arm/mach-msm/qdsp5v2/snddev_icodec.c	2013-04-19 11:37:14.000000000 +0200
@@ -293,11 +293,7 @@
 
 	for (i = 0; i < icodec->data->pmctl_id_sz; i++) {
 		pmic_hsed_enable(icodec->data->pmctl_id[i],
-#if defined(CONFIG_MACH_KYLE)
-			 PM_HSED_ENABLE_ALWAYS);
-#else
 			 PM_HSED_ENABLE_PWM_TCXO);
-#endif
 	}
 
 	/* enable MI2S TX master block */
@@ -897,11 +893,7 @@
 		ADIE_CODEC_DIGITAL_ANALOG_READY);
 
 		MM_INFO("Enable Handset Mic bias\n");
-#if defined(CONFIG_MACH_KYLE)
-		pmic_hsed_enable(PM_HSED_CONTROLLER_0, PM_HSED_ENABLE_ALWAYS);
-#else
 		pmic_hsed_enable(PM_HSED_CONTROLLER_0, PM_HSED_ENABLE_PWM_TCXO);
-#endif
 		/* enable MI2S TX master block */
 		/* enable MI2S TX bit clock */
 		clk_set_rate(drv->tx_mclk,
@@ -998,11 +990,7 @@
 			PMAPP_VREG_S4, PMAPP_SMPS_MODE_VOTE_PWM);
 
 		MM_INFO("Enable Handset Mic bias\n");
-#if defined(CONFIG_MACH_KYLE)
-		pmic_hsed_enable(PM_HSED_CONTROLLER_0, PM_HSED_ENABLE_ALWAYS);
-#else
 		pmic_hsed_enable(PM_HSED_CONTROLLER_0, PM_HSED_ENABLE_PWM_TCXO);
-#endif
 
 		/* enable MI2S TX master block */
 		/* enable MI2S TX bit clock */
diff -ru final2/arch/arm/mach-msm/restart.c ics/arch/arm/mach-msm/restart.c
--- final2/arch/arm/mach-msm/restart.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/restart.c	2013-04-19 11:37:14.000000000 +0200
@@ -206,8 +206,6 @@
 			__raw_writel(0x77665500, restart_reason);
 		} else if (!strncmp(cmd, "recovery", 8)) {
 			__raw_writel(0x77665502, restart_reason);
-		} else if (!strncmp(cmd, "download", 8)) {
-			writel(0x776655FF, restart_reason);
 		} else if (!strncmp(cmd, "oem-", 4)) {
 			unsigned long code;
 			code = simple_strtoul(cmd + 4, NULL, 16) & 0xff;
diff -ru final2/arch/arm/mach-msm/rmt_storage_client.c ics/arch/arm/mach-msm/rmt_storage_client.c
--- final2/arch/arm/mach-msm/rmt_storage_client.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/rmt_storage_client.c	2013-04-19 11:37:14.000000000 +0200
@@ -36,8 +36,6 @@
 #endif
 #include "smd_private.h"
 
-#define DEBUG
-
 enum {
 	RMT_STORAGE_EVNT_OPEN = 0,
 	RMT_STORAGE_EVNT_CLOSE,
@@ -128,9 +126,6 @@
 static struct sdio_smem_client *sdio_smem;
 #endif
 
-extern int in_recovery_mode;
-extern int charging_boot;
-
 #ifdef CONFIG_MSM_RMT_STORAGE_CLIENT_STATS
 struct rmt_storage_op_stats {
 	unsigned long count;
@@ -362,9 +357,7 @@
 	if (cid > MAX_NUM_CLIENTS) {
 		pr_err("%s: Max clients are reached\n", __func__);
 		cid = 0;
-		/* prevent fix */
-		ret = cid;
-		goto free_rs_client;
+		return cid;
 	}
 	__set_bit(cid, &rmc->cids);
 	pr_info("open partition %s handle=%d\n", event_args->path, cid);
@@ -491,7 +484,7 @@
 	if (event_type != RMT_STORAGE_EVNT_CLOSE)
 		return -1;
 
-	printk("%s: close callback received\n", __func__);
+	pr_debug("%s: close callback received\n", __func__);
 	ret = xdr_recv_pointer(xdr, (void **)&event,
 			sizeof(struct rmt_storage_event_params),
 			rmt_storage_parse_params);
@@ -526,7 +519,7 @@
 	if (event_type != RMT_STORAGE_EVNT_WRITE_BLOCK)
 		return -1;
 
-	printk("%s: write block callback received\n", __func__);
+	pr_debug("%s: write block callback received\n", __func__);
 	ret = xdr_recv_pointer(xdr, (void **)&event,
 			sizeof(struct rmt_storage_event_params),
 			rmt_storage_parse_params);
@@ -550,7 +543,7 @@
 	if (atomic_inc_return(&rmc->wcount) == 1)
 		wake_lock(&rmc->wlock);
 
-	printk("sec_addr = %u, data_addr = %x, num_sec = %d\n\n",
+	pr_debug("sec_addr = %u, data_addr = %x, num_sec = %d\n\n",
 		xfer->sector_addr, xfer->data_phy_addr,
 		xfer->num_sector);
 
@@ -598,7 +591,7 @@
 	if (event_type != RMT_STORAGE_EVNT_SEND_USER_DATA)
 		return -1;
 
-	printk("%s: send user data callback received\n", __func__);
+	pr_info("%s: send user data callback received\n", __func__);
 	ret = xdr_recv_pointer(xdr, (void **)&event,
 			sizeof(struct rmt_storage_event_params),
 			rmt_storage_parse_params);
@@ -628,7 +621,8 @@
 	xdr_recv_uint32(xdr, &event_type);
 	if (event_type != RMT_STORAGE_EVNT_WRITE_IOVEC)
 		return -EINVAL;
-	printk("%s: write iovec callback received\n", __func__);
+
+	pr_info("%s: write iovec callback received\n", __func__);
 	xdr_recv_uint32(xdr, &event_args->handle);
 	xdr_recv_uint32(xdr, &ent);
 	pr_debug("handle = %d\n", event_args->handle);
@@ -655,7 +649,7 @@
 	if (atomic_inc_return(&rmc->wcount) == 1)
 		wake_lock(&rmc->wlock);
 
-	printk("iovec transfer count = %d\n\n", event_args->xfer_cnt);
+	pr_debug("iovec transfer count = %d\n\n", event_args->xfer_cnt);
 	return RMT_STORAGE_NO_ERROR;
 }
 
@@ -673,7 +667,7 @@
 	if (event_type != RMT_STORAGE_EVNT_READ_IOVEC)
 		return -EINVAL;
 
-	printk("%s: read iovec callback received\n", __func__);
+	pr_info("%s: read iovec callback received\n", __func__);
 	xdr_recv_uint32(xdr, &event_args->handle);
 	xdr_recv_uint32(xdr, &ent);
 	pr_debug("handle = %d\n", event_args->handle);
@@ -700,7 +694,7 @@
 	if (atomic_inc_return(&rmc->wcount) == 1)
 		wake_lock(&rmc->wlock);
 
-	printk("iovec transfer count = %d\n\n", event_args->xfer_cnt);
+	pr_debug("iovec transfer count = %d\n\n", event_args->xfer_cnt);
 	return RMT_STORAGE_NO_ERROR;
 }
 
@@ -930,8 +924,6 @@
 		ret = -EBUSY;
 	spin_unlock(&rmc->lock);
 
-	printk("%s \n", __func__);
-
 	return ret;
 }
 
@@ -941,7 +933,6 @@
 	rmc->open_excl = 0;
 	spin_unlock(&rmc->lock);
 
-	printk("%s \n", __func__);
 	return 0;
 }
 
@@ -1070,34 +1061,20 @@
 		return -EINVAL;
 	xdr_recv_int32(xdr, &args->data);
 	srv->sync_token = args->data;
-	printk(" %s \n", __func__);
 	return 0;
 }
 
-static int force_sync_called;
-
 static int rmt_storage_force_sync(struct msm_rpc_client *client)
 {
 	struct rmt_storage_sync_recv_arg args;
 	int rc;
-
-	pr_info("%s: msm_rpc_client_req2()\n", __func__);
-
 	rc = msm_rpc_client_req2(client,
 			RMT_STORAGE_FORCE_SYNC_PROC, NULL, NULL,
 			rmt_storage_receive_sync_arg, &args, -1);
-
-	pr_info("%s: rc = (%d)\n", __func__, rc);
-
 	if (rc) {
 		pr_err("%s: force sync RPC req failed: %d\n", __func__, rc);
 		return rc;
 	}
-	printk("%s \n", __func__);
-
-	force_sync_called = 1;
-	pr_info("%s: set force_sync_called\n", __func__);
-
 	return 0;
 }
 
@@ -1130,7 +1107,6 @@
 	struct rmt_storage_srv *srv;
 	int rc;
 
-	printk(" %s \n", __func__);
 	srv = rmt_storage_get_srv(client->prog);
 	if (!srv)
 		return -EINVAL;
@@ -1147,7 +1123,6 @@
 		pr_err("%s: sync status RPC req failed: %d\n", __func__, rc);
 		return rc;
 	}
-	printk(" %s done\n", __func__);
 	return recv_args.data;
 }
 
@@ -1347,7 +1322,6 @@
 		return -EINVAL;
 	}
 
-	printk("%s \n", __func__);
 	return rmt_storage_force_sync(srv->rpc_client);
 }
 
@@ -1362,19 +1336,13 @@
 	struct rpcsvr_platform_device *rpc_pdev;
 	struct rmt_storage_srv *srv;
 
-	if (force_sync_called != 1) {
-		pr_err("rmt_storage - %s: cat force_sync first\n", __func__);
-		return snprintf(buf, PAGE_SIZE, "%d\n", -EPERM);
-	}
-
-	printk(" %s \n", __func__);
 	pdev = container_of(dev, struct platform_device, dev);
 	rpc_pdev = container_of(pdev, struct rpcsvr_platform_device, base);
 	srv = rmt_storage_get_srv(rpc_pdev->prog);
 	if (!srv) {
 		pr_err("%s: Unable to find prog=0x%x\n", __func__,
 		       rpc_pdev->prog);
-		return snprintf(buf, PAGE_SIZE, "%d\n", -EINVAL);
+		return -EINVAL;
 	}
 	return snprintf(buf, PAGE_SIZE, "%d\n",
 			rmt_storage_get_sync_status(srv->rpc_client));
@@ -1449,7 +1417,7 @@
 	srv = rmt_storage_get_srv(client->prog);
 	if (!srv)
 		return;
-	printk("%s: Modem restart for 0x%08x\n", __func__, srv->prog);
+	pr_debug("%s: Modem restart for 0x%08x\n", __func__, srv->prog);
 	cancel_delayed_work_sync(&srv->restart_work);
 }
 
@@ -1462,7 +1430,7 @@
 	srv = rmt_storage_get_srv(client->prog);
 	if (!srv)
 		return;
-	printk("%s: Scheduling restart for 0x%08x\n", __func__, srv->prog);
+	pr_debug("%s: Scheduling restart for 0x%08x\n", __func__, srv->prog);
 	queue_delayed_work(rmc->workq, &srv->restart_work,
 			msecs_to_jiffies(RESTART_WORK_DELAY_MS));
 }
@@ -1475,58 +1443,44 @@
 				 RMT_STORAGE_REGISTER_OPEN_PROC,
 				 RMT_STORAGE_EVNT_OPEN,
 				 rmt_storage_event_open_cb);
-	if (ret) {
-		printk(" %s: open event failed \n", __func__);
+	if (ret)
 		return ret;
-	}
 	ret = rmt_storage_reg_cb(client,
 				 RMT_STORAGE_REGISTER_CB_PROC,
 				 RMT_STORAGE_EVNT_CLOSE,
 				 rmt_storage_event_close_cb);
-	if (ret) {
-		printk(" %s: close event failed \n", __func__);
+	if (ret)
 		return ret;
-	}
 	ret = rmt_storage_reg_cb(client,
 				 RMT_STORAGE_REGISTER_CB_PROC,
 				 RMT_STORAGE_EVNT_WRITE_BLOCK,
 				 rmt_storage_event_write_block_cb);
-	if (ret) {
-		printk(" %s: open event failed \n", __func__);
+	if (ret)
 		return ret;
-	}
 	ret = rmt_storage_reg_cb(client,
 				 RMT_STORAGE_REGISTER_CB_PROC,
 				 RMT_STORAGE_EVNT_GET_DEV_ERROR,
 				 rmt_storage_event_get_err_cb);
-	if (ret) {
-		printk(" %s: open event failed \n", __func__);
+	if (ret)
 		return ret;
-	}
 	ret = rmt_storage_reg_cb(client,
 				 RMT_STORAGE_REGISTER_WRITE_IOVEC_PROC,
 				 RMT_STORAGE_EVNT_WRITE_IOVEC,
 				 rmt_storage_event_write_iovec_cb);
-	if (ret) {
-		printk(" %s: open event failed \n", __func__);
+	if (ret)
 		return ret;
-	}
 	ret = rmt_storage_reg_cb(client,
 				 RMT_STORAGE_REGISTER_READ_IOVEC_PROC,
 				 RMT_STORAGE_EVNT_READ_IOVEC,
 				 rmt_storage_event_read_iovec_cb);
-	if (ret) {
-		printk(" %s: open event failed \n", __func__);
+	if (ret)
 		return ret;
-	}
 	ret = rmt_storage_reg_cb(client,
 				 RMT_STORAGE_REGISTER_CB_PROC,
 				 RMT_STORAGE_EVNT_SEND_USER_DATA,
 				 rmt_storage_event_user_data_cb);
-	if (ret) {
-		printk(" %s: open event failed \n", __func__);
+	if (ret)
 		return ret;
-	}
 	ret = rmt_storage_reg_cb(client,
 				 RMT_STORAGE_REGISTER_ALLOC_RMT_BUF_PROC,
 				 RMT_STORAGE_EVNT_ALLOC_RMT_BUF,
@@ -1535,7 +1489,7 @@
 		pr_info("%s: Unable (%d) registering aloc_rmt_buf\n",
 			__func__, ret);
 
-	printk("%s: Callbacks (re)registered for 0x%08x\n\n", __func__,
+	pr_debug("%s: Callbacks (re)registered for 0x%08x\n\n", __func__,
 		 client->prog);
 	return 0;
 }
@@ -1577,18 +1531,8 @@
 		return -ENXIO;
 	}
 
-	ret = rmt_storage_init_ramfs(srv);
-	if (ret) {
-		pr_err("%s: rmt_storage_init_ramfs fail\n",
-			__func__);
-		return ret;
-	}
-	ret = rmt_storage_get_ramfs(srv);
-	if (ret) {
-		pr_err("%s: rmt_storage_get_ramfs fail\n",
-			__func__);
-		return ret;
-	}
+	rmt_storage_init_ramfs(srv);
+	rmt_storage_get_ramfs(srv);
 
 	INIT_DELAYED_WORK(&srv->restart_work, rmt_storage_restart_work);
 
@@ -1617,7 +1561,6 @@
 	if (ret)
 		goto unregister_client;
 
-	printk("%s  registered all the call back \n", __func__);
 	/* For targets that poll SMEM, set status to ready */
 	rmt_storage_set_client_status(srv, 1);
 
@@ -1723,9 +1666,6 @@
 #endif
 	int ret = 0;
 
-	if (in_recovery_mode == 1 || charging_boot == 1)
-		return 0;
-
 	rmc = kzalloc(sizeof(struct rmt_storage_client_info), GFP_KERNEL);
 	if (!rmc) {
 		pr_err("%s: Unable to allocate memory\n", __func__);
@@ -1775,10 +1715,8 @@
 
 	rmc->workq = create_singlethread_workqueue("rmt_storage");
 	if (!rmc->workq)
-	{
-		ret = -ENOMEM;
-		goto unreg_mdm_rpc;
-	}
+		return -ENOMEM;
+
 #ifdef CONFIG_MSM_RMT_STORAGE_CLIENT_STATS
 	stats_dentry = debugfs_create_file("rmt_storage_stats", 0444, 0,
 					NULL, &debug_ops);
diff -ru final2/arch/arm/mach-msm/rpc_server_handset.c ics/arch/arm/mach-msm/rpc_server_handset.c
--- final2/arch/arm/mach-msm/rpc_server_handset.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/rpc_server_handset.c	2013-04-19 11:37:14.000000000 +0200
@@ -2,17 +2,14 @@
  *
  * Copyright (c) 2008-2010, The Linux Foundation. All rights reserved.
  *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, you can find it at http://www.fsf.org.
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  */
 
 #include <linux/slab.h>
@@ -28,13 +25,7 @@
 #include <mach/board.h>
 #include <mach/rpc_server_handset.h>
 
-#if defined(CONFIG_MACH_KYLE)
-#define RPC_JACK_WATERPROOF
-#endif
-
 #define DRIVER_NAME	"msm-handset"
-#define FEATURE_HEADSET_AP_DETECT
-#undef HS_DEBUG
 
 #define HS_SERVER_PROG 0x30000062
 #define HS_SERVER_VERS 0x00010001
@@ -50,28 +41,21 @@
 #define RPC_KEYPAD_NULL_PROC 0
 #define RPC_KEYPAD_PASS_KEY_CODE_PROC 2
 #define RPC_KEYPAD_SET_PWR_KEY_STATE_PROC 3
-#define HS_PWR_K				0x6F	/* Power key */
-#define HS_END_K				0x51	/* End key or Power key */
-#define HS_HEADSET_K  			0x7E 	/* 4pole headset */
-#define HS_STEREO_HEADSET_K		0x82
-#define HS_HEADSET_SWITCH_K		0x84	/* sendend key */
-#define HS_HEADSET_SWITCH_2_K	0xF0	/* Volume up key */
-#define HS_HEADSET_SWITCH_3_K	0xF1	/* Volume down key */
-#define HS_HEADSET_HEADPHONE_K	0xF6	/* 3pole headset */
+
+#define HS_PWR_K		0x6F	/* Power key */
+#define HS_END_K		0x51	/* End key or Power key */
+#define HS_STEREO_HEADSET_K	0x82
+#define HS_HEADSET_SWITCH_K	0x84
+#define HS_HEADSET_SWITCH_2_K	0xF0
+#define HS_HEADSET_SWITCH_3_K	0xF1
+#define HS_HEADSET_HEADPHONE_K	0xF6
 #define HS_HEADSET_MICROPHONE_K 0xF7
-#ifdef RPC_JACK_WATERPROOF
-#define HS_FOREIGN_SUBSTANCE_K 0xF8     /* Foreign Substance detection */
-#endif
-#define HS_REL_K				0xFF	/* key release */
-
-#define SW_HEADPHONE_INSERT_W_MIC 1 	/* HS with mic */
-#ifdef RPC_JACK_WATERPROOF
-#define SW_FOREIGN_SUBSTANCE_INSERT 1000   /* Foreign Substance */
-#endif
+#define HS_REL_K		0xFF	/* key release */
+
+#define SW_HEADPHONE_INSERT_W_MIC 1 /* HS with mic */
 
 #define KEY(hs_key, input_key) ((hs_key << 24) | input_key)
 
-#if 0
 enum hs_event {
 	HS_EVNT_EXT_PWR = 0,	/* External Power status        */
 	HS_EVNT_HSD,		/* Headset Detection            */
@@ -88,33 +72,6 @@
 	HS_EVNT_MAX		/* Force enum to be an 32-bit number */
 };
 
-#else
-
-enum hs_event {
-	HS_EVNT_EXT_PWR = 0,
-	HS_EVNT_HSD,
-	HS_EVNT_HSTD,
-	HS_EVNT_HSSD,
-	HS_EVNT_KPD,
-	HS_EVNT_PWR_END,
-	HS_EVNT_FLIP,
-	HS_EVNT_CHARGER,
-	HS_EVNT_ENV,
-	HS_EVNT_REM,
-	HS_EVNT_DIAG,
-	HS_EVNT_ACCESSORY_DETECT,
-	HS_EVNT_HPD,
-	HS_EVNT_MIC_DETECT,
-	HS_EVNT_ACC_TYPE_DETECT,
-#ifdef RPC_JACK_WATERPROOF
-	HS_EVNT_FSD,
-#endif
-	HS_EVNT_LAST,
-	HS_EVNT_MAX = 0x7FFFFFFF,
-};
-
-#endif
-
 enum hs_src_state {
 	HS_SRC_STATE_UNKWN = 0,
 	HS_SRC_STATE_LO,
@@ -225,36 +182,16 @@
 
 static const uint32_t hs_key_map[] = {
 	KEY(HS_PWR_K, KEY_POWER),
-	KEY(HS_END_K, KEY_POWER),
-#if 0
+	KEY(HS_END_K, KEY_END),
 	KEY(HS_STEREO_HEADSET_K, SW_HEADPHONE_INSERT_W_MIC),
+	KEY(HS_HEADSET_HEADPHONE_K, SW_HEADPHONE_INSERT),
 	KEY(HS_HEADSET_MICROPHONE_K, SW_MICROPHONE_INSERT),
-	KEY(HS_HEADSET_HEADPHONE_K, SW_HEADPHONE_INSERT), 			/* 3pole headset */
-	KEY(HS_HEADSET_K, SW_HEADPHONE_INSERT_W_MIC), 				/* 4pole headset */	
-#else
-	KEY(HS_HEADSET_HEADPHONE_K, SW_HEADPHONE_INSERT), 	/* 3pole headset */
-	KEY(HS_STEREO_HEADSET_K,
-	SW_HEADPHONE_INSERT_W_MIC),    /* 4pole headset */
-#ifdef RPC_JACK_WATERPROOF
-	KEY(HS_FOREIGN_SUBSTANCE_K,
-	SW_FOREIGN_SUBSTANCE_INSERT),    /* Foreign Substance insert */
-#endif
-#endif
 	KEY(HS_HEADSET_SWITCH_K, KEY_MEDIA),
 	KEY(HS_HEADSET_SWITCH_2_K, KEY_VOLUMEUP),
 	KEY(HS_HEADSET_SWITCH_3_K, KEY_VOLUMEDOWN),
 	0
 };
 
-int current_jack_type = 2;		/* report current jack type */
-int current_key_state;		/* report current key state */
-
-/* To support samsung factory test */
-struct switch_dev switch_sendend = {
-	.name = "send_end",
-};
-
-
 enum {
 	NO_DEVICE	= 0,
 	MSM_HEADSET	= 1,
@@ -286,27 +223,6 @@
 static struct msm_rpc_client *rpc_client;
 static struct msm_handset *hs;
 
-extern struct class *sec_class;
-struct device *pwr_dev;
-static int key_count;
-
-static ssize_t keyshort_test(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int count;
-	if(key_count) {
-		count = sprintf(buf, "PRESS\n");
-	}
-	else {
-		count = sprintf(buf, "RELEASE\n");
-	}
-
-	return count;
-}
-#if defined(CONFIG_MACH_KYLE)
-static DEVICE_ATTR(sec_power_key_pressed, 0664, keyshort_test, NULL);
-#else
-static DEVICE_ATTR(sec_pwrkey_pressed, 0664, keyshort_test, NULL);
-#endif
 static int hs_find_key(uint32_t hscode)
 {
 	int i, key;
@@ -314,10 +230,8 @@
 	key = KEY(hscode, 0);
 
 	for (i = 0; hs_key_map[i] != 0; i++) {
-		if ((hs_key_map[i] & 0xff000000) == key){
-			printk("the value of i is %d", i);
+		if ((hs_key_map[i] & 0xff000000) == key)
 			return hs_key_map[i] & 0x00ffffff;
-		}
 	}
 	return -1;
 }
@@ -349,7 +263,6 @@
  * key-press = (key_code, 0)
  * key-release = (key_code, 0xff)
  */
-int get_msm7x27a_det_jack_state(void);
 static void report_hs_key(uint32_t key_code, uint32_t key_parm)
 {
 	int key, temp_key_code;
@@ -359,79 +272,19 @@
 	else
 		key = hs_find_key(key_code);
 
-#ifndef CONFIG_MACH_KYLE
-	printk("[KEY] key_parm: %d, key_code: %d, key: %d\n", key_parm, key_code, key);
-#endif
-
 	temp_key_code = key_code;
 
-	if (key_parm == HS_REL_K) {
+	if (key_parm == HS_REL_K)
 		key_code = key_parm;
-	}
+
 	switch (key) {
 	case KEY_POWER:
-		input_report_key(hs->ipdev, key, (key_code != HS_REL_K));
-		printk(" report power key\n ");
-#ifdef HS_DEBUG
-		pr_info("%s KEY_POWER %d\n", __func__, (key_code != HS_REL_K));
-#else
-		pr_info("%s %d\n", __func__, (key_code != HS_REL_K));
-#endif
-		key_count = (key_code != HS_REL_K);
-		break;
+	case KEY_END:
 	case KEY_MEDIA:
-		input_report_key(hs->ipdev, key, (key_code != HS_REL_K));
-#ifdef HS_DEBUG
-		pr_info("%s KEY_MEDIA %d\n", __func__, (key_code != HS_REL_K));
-#else
-		pr_info("%s %d\n", __func__, (key_code != HS_REL_K));
-#endif
-		switch_set_state(&switch_sendend, (key_code != HS_REL_K));
-	/* inform current_key_state to sec_jack driver for factory test */
-		current_key_state = (key_code != HS_REL_K);
-		break;
 	case KEY_VOLUMEUP:
-		input_report_key(hs->ipdev, key, (key_code != HS_REL_K));
-#ifdef HS_DEBUG
-		pr_info("%s KEY_VOL+ %d\n", __func__, (key_code != HS_REL_K));
-#else
-		pr_info("%s %d\n", __func__, (key_code != HS_REL_K));
-#endif
-		break;
 	case KEY_VOLUMEDOWN:
 		input_report_key(hs->ipdev, key, (key_code != HS_REL_K));
-#ifdef HS_DEBUG
-		pr_info("%s KEY_VOL- %d\n", __func__, (key_code != HS_REL_K));
-#else
-		pr_info("%s %d\n", __func__, (key_code != HS_REL_K));
-#endif
-		break;
-	case KEY_END:
-		printk(" report END Key\n");
-		input_report_key(hs->ipdev, key, (key_code != HS_REL_K));
-#ifdef HS_DEBUG
-		pr_info("%s KEY_END %d\n", __func__, (key_code != HS_REL_K));
-#else
-		pr_info("%s %d\n", __func__, (key_code != HS_REL_K));
-#endif
 		break;
-#ifdef FEATURE_HEADSET_AP_DETECT
-	case SW_HEADPHONE_INSERT: 		/* 3pole headset */
-		current_jack_type = 2;
-		pr_info("%s 3pole %d\n", __func__, key);
-		break;
-
-	case SW_HEADPHONE_INSERT_W_MIC:	/* 4pole headset */
-		current_jack_type = 1;
-		pr_info("%s 4pole %d\n", __func__, key);
-		break;
-#ifdef RPC_JACK_WATERPROOF
-	case SW_FOREIGN_SUBSTANCE_INSERT: /* Foreign Substance insert */
-		pr_info("%s foreign stuff %d\n", __func__, key);
-		current_jack_type = 3;
-		break;
-#endif
-#else
 	case SW_HEADPHONE_INSERT_W_MIC:
 		hs->mic_on = hs->hs_on = (key_code != HS_REL_K) ? 1 : 0;
 		input_report_switch(hs->ipdev, SW_HEADPHONE_INSERT,
@@ -451,13 +304,10 @@
 		input_report_switch(hs->ipdev, key, hs->mic_on);
 		update_state();
 		break;
-#endif
 	case -1:
 		printk(KERN_ERR "%s: No mapping for remote handset event %d\n",
 				 __func__, temp_key_code);
 		return;
-	default:
-		pr_err("%s another value %d\n", __func__, key);
 	}
 	input_sync(hs->ipdev);
 }
@@ -534,14 +384,8 @@
 
 	req->hs_event_data_ptr	= cpu_to_be32(0x1);
 	req->data.ver		= cpu_to_be32(HS_EVENT_DATA_VER);
-#if 0
 	req->data.event_type	= cpu_to_be32(HS_EVNT_HSD);
 	req->data.enum_disc	= cpu_to_be32(HS_EVNT_HSD);
-#else
-
-	req->data.event_type = cpu_to_be32(HS_EVNT_ACCESSORY_DETECT);
-	req->data.enum_disc = cpu_to_be32(HS_EVNT_ACCESSORY_DETECT);
-#endif
 	req->data.data_length	= cpu_to_be32(0x1);
 	req->data.data		= cpu_to_be32(*(enum hs_src_state *)data);
 	req->data.data_size	= cpu_to_be32(sizeof(enum hs_src_state));
@@ -568,8 +412,6 @@
 	int rc = -1;
 	enum hs_src_state status;
 
-	pr_info("%s %d\n", __func__, connected);
-
 	if (connected == true)
 		status = HS_SRC_STATE_HI;
 	else
@@ -764,19 +606,12 @@
 	if (!hs)
 		return -ENOMEM;
 
-#ifndef FEATURE_HEADSET_AP_DETECT
 	hs->sdev.name	= "h2w";
 	hs->sdev.print_name = msm_headset_print_name;
 
 	rc = switch_dev_register(&hs->sdev);
 	if (rc)
 		goto err_switch_dev_register;
-#endif
-	rc = switch_dev_register(&switch_sendend);
-	if (rc < 0) {
-		pr_err("%s : Failed to register switch device\n", __func__);
-		goto err_switch_dev_register;
-	}
 
 	ipdev = input_allocate_device();
 	if (!ipdev) {
@@ -802,10 +637,11 @@
 	input_set_capability(ipdev, EV_KEY, KEY_MEDIA);
 	input_set_capability(ipdev, EV_KEY, KEY_VOLUMEUP);
 	input_set_capability(ipdev, EV_KEY, KEY_VOLUMEDOWN);
-	//input_set_capability(ipdev, EV_SW, SW_HEADPHONE_INSERT);
-	//input_set_capability(ipdev, EV_SW, SW_MICROPHONE_INSERT);
+	input_set_capability(ipdev, EV_SW, SW_HEADPHONE_INSERT);
+	input_set_capability(ipdev, EV_SW, SW_MICROPHONE_INSERT);
 	input_set_capability(ipdev, EV_KEY, KEY_POWER);
 	input_set_capability(ipdev, EV_KEY, KEY_END);
+
 	rc = input_register_device(ipdev);
 	if (rc) {
 		dev_err(&ipdev->dev,
@@ -820,23 +656,7 @@
 		dev_err(&ipdev->dev, "rpc init failure\n");
 		goto err_hs_rpc_init;
 	}
-#if defined(CONFIG_MACH_KYLE)
-	pwr_dev = device_create(sec_class, NULL, 0, NULL, "sec_power_key");
-#else
-	pwr_dev = device_create(sec_class, NULL, 0, NULL, "sec_pwrkey");
-#endif
-	if (!pwr_dev)
-		printk("Failed to create device(pwr_key)!\n");
-#if defined(CONFIG_MACH_KYLE)
-	if (device_create_file(pwr_dev,
-		&dev_attr_sec_power_key_pressed) < 0) {
-			pr_info("Failed to create file(%s)!\n", \
-			dev_attr_sec_power_key_pressed.attr.name);
-	}
-#else
-	if (device_create_file(pwr_dev, &dev_attr_sec_pwrkey_pressed) < 0)
-		printk("Failed to create file(%s)!\n", dev_attr_sec_pwrkey_pressed.attr.name);
-#endif
+
 	return 0;
 
 err_hs_rpc_init:
@@ -845,9 +665,7 @@
 err_reg_input_dev:
 	input_free_device(ipdev);
 err_alloc_input_dev:
-#ifndef FEATURE_HEADSET_AP_DETECT
 	switch_dev_unregister(&hs->sdev);
-#endif
 err_switch_dev_register:
 	kfree(hs);
 	return rc;
@@ -858,10 +676,7 @@
 	struct msm_handset *hs = platform_get_drvdata(pdev);
 
 	input_unregister_device(hs->ipdev);
-#ifndef FEATURE_HEADSET_AP_DETECT
 	switch_dev_unregister(&hs->sdev);
-#endif
-	switch_dev_unregister(&switch_sendend);
 	kfree(hs);
 	hs_rpc_deinit();
 	return 0;
diff -ru final2/arch/arm/mach-msm/smd.c ics/arch/arm/mach-msm/smd.c
--- final2/arch/arm/mach-msm/smd.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/smd.c	2013-04-19 11:37:14.000000000 +0200
@@ -39,7 +39,6 @@
 #include <mach/subsystem_notif.h>
 #include <mach/socinfo.h>
 #include <asm/cacheflush.h>
-#include <linux/sec_debug.h>
 
 #include "smd_private.h"
 #include "proc_comm.h"
@@ -998,16 +997,9 @@
 		ch->send->fCTS = 1;
 		ch->send->fCD = 1;
 	} else {
-    //ALRAN 
-    if (strncmp("DATA5", ch->name, 5) && strncmp("DATA6", ch->name, 5) && 
-    strncmp("DATA7", ch->name, 5)) { //DATA5,6,7 and DATA5,6,7_CTRL 
-        ch->send->fDSR = 0; 
-        ch->send->fCTS = 0; 
-        ch->send->fCD = 0; 
-        pr_err("!!! SMD drop DTR [%s] from %d %s\n", ch->name, current->pid, current->comm); 
-    } 
-    pr_err("!!! SMD drop discard DTR [%s] from %d %s\n", ch->name, current->pid, current->comm); 
-    ////// 
+		ch->send->fDSR = 0;
+		ch->send->fCTS = 0;
+		ch->send->fCD = 0;
 	}
 	ch->send->state = n;
 	ch->send->fSTATE = 1;
@@ -2080,12 +2072,6 @@
 	return ret;
 }
 EXPORT_SYMBOL(smem_alloc2);
-#if 1 //trebon_dpram_port_temp remove this when CP side is ready
-void *smem_do_alloc(unsigned id, unsigned size_in)
-{
-	return smem_alloc2(id, size_in);
-}
-#endif
 
 void *smem_get_entry(unsigned id, unsigned *size)
 {
@@ -2273,7 +2259,6 @@
 	spin_unlock_irqrestore(&smem_lock, flags);
 }
 EXPORT_SYMBOL(smsm_reset_modem_cont);
-extern void sec_save_final_context(void);
 
 static void smsm_cb_snapshot(uint32_t use_wakelock)
 {
@@ -2402,13 +2387,6 @@
 				flush_cache_all();
 				outer_flush_all();
 			}
-
-#ifdef CONFIG_SEC_DEBUG
-			sec_save_final_context();
-			flush_cache_all();
-			outer_flush_all();
-#endif
-
 			modem_queue_start_reset_notify();
 
 		} else if (modm & SMSM_INIT) {
diff -ru final2/arch/arm/mach-msm/smd_debug.c ics/arch/arm/mach-msm/smd_debug.c
--- final2/arch/arm/mach-msm/smd_debug.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/smd_debug.c	2013-04-19 11:37:14.000000000 +0200
@@ -758,9 +758,32 @@
 
 	spin_lock_irqsave(&smem_lock, flags);
 
+	pr_info("SMEM_SMSM_SLEEP_DELAY: %x\n", sleep_delay);
+	pr_info("SMEM_SMSM_LIMIT_SLEEP: %x\n", sleep_limit);
+
 	ptr = smem_alloc(SMEM_SLEEP_POWER_COLLAPSE_DISABLED, sizeof(*ptr));
+	if (ptr)
+		pr_info("SMEM_SLEEP_POWER_COLLAPSE_DISABLED: %x\n", *ptr);
+	else
+		pr_info("SMEM_SLEEP_POWER_COLLAPSE_DISABLED: missing\n");
+
+	pr_info("SMEM_SMSM_INT_INFO %x %x %x\n",
+		irq_mask, pending_irqs, wakeup_reason);
 
 	gpio = smem_alloc(SMEM_GPIO_INT, sizeof(*gpio));
+	if (gpio) {
+		int i;
+		for (i = 0; i < NUM_GPIO_INT_REGISTERS; i++)
+			pr_info("SMEM_GPIO_INT: %d: e %x d %x p %x\n",
+				i, gpio->enabled[i], gpio->detection[i],
+				gpio->polarity[i]);
+
+		for (i = 0; i < GPIO_SMEM_NUM_GROUPS; i++)
+			pr_info("SMEM_GPIO_INT: %d: f %d: %d %d...\n",
+				i, gpio->num_fired[i], gpio->fired[i][0],
+				gpio->fired[i][1]);
+	} else
+		pr_info("SMEM_GPIO_INT: missing\n");
 
 	spin_unlock_irqrestore(&smem_lock, flags);
 }
diff -ru final2/arch/arm/mach-msm/smd_private.h ics/arch/arm/mach-msm/smd_private.h
--- final2/arch/arm/mach-msm/smd_private.h	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/smd_private.h	2013-04-19 11:37:14.000000000 +0200
@@ -19,7 +19,6 @@
 #include <linux/types.h>
 #include <linux/spinlock.h>
 #include <mach/msm_smsm.h>
-#include "smem_vendor_type.h"
 
 #define PC_APPS  0
 #define PC_MODEM 1
diff -ru final2/arch/arm/mach-msm/smd_rpcrouter.c ics/arch/arm/mach-msm/smd_rpcrouter.c
--- final2/arch/arm/mach-msm/smd_rpcrouter.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/smd_rpcrouter.c	2013-04-19 11:37:14.000000000 +0200
@@ -629,6 +629,9 @@
 	/* Endpoint with dst_pid = 0xffffffff corresponds to that of
 	** router port. So don't send a REMOVE CLIENT message while
 	** destroying it.*/
+	spin_lock_irqsave(&local_endpoints_lock, flags);
+	list_del(&ept->list);
+	spin_unlock_irqrestore(&local_endpoints_lock, flags);
 	if (ept->dst_pid != 0xffffffff) {
 		msg.cmd = RPCROUTER_CTRL_CMD_REMOVE_CLIENT;
 		msg.cli.pid = ept->pid;
@@ -660,9 +663,6 @@
 
 	wake_lock_destroy(&ept->read_q_wake_lock);
 	wake_lock_destroy(&ept->reply_q_wake_lock);
-	spin_lock_irqsave(&local_endpoints_lock, flags);
-	list_del(&ept->list);
-	spin_unlock_irqrestore(&local_endpoints_lock, flags);
 	kfree(ept);
 	return 0;
 }
@@ -692,16 +692,11 @@
 static struct msm_rpc_endpoint *rpcrouter_lookup_local_endpoint(uint32_t cid)
 {
 	struct msm_rpc_endpoint *ept;
-	unsigned long flags;
 
-	spin_lock_irqsave(&local_endpoints_lock, flags);
 	list_for_each_entry(ept, &local_endpoints, list) {
-		if (ept->cid == cid) {
-			spin_unlock_irqrestore(&local_endpoints_lock, flags);
+		if (ept->cid == cid)
 			return ept;
-		}
 	}
-	spin_unlock_irqrestore(&local_endpoints_lock, flags);
 	return NULL;
 }
 
@@ -1122,8 +1117,10 @@
 	}
 #endif
 
+	spin_lock_irqsave(&local_endpoints_lock, flags);
 	ept = rpcrouter_lookup_local_endpoint(hdr.dst_cid);
 	if (!ept) {
+		spin_unlock_irqrestore(&local_endpoints_lock, flags);
 		DIAG("no local ept for cid %08x\n", hdr.dst_cid);
 		kfree(frag);
 		goto done;
@@ -1133,7 +1130,7 @@
 	 * and if so, append this fragment to that packet.
 	 */
 	mid = PACMARK_MID(pm);
-	spin_lock_irqsave(&ept->incomplete_lock, flags);
+	spin_lock(&ept->incomplete_lock);
 	list_for_each_entry(pkt, &ept->incomplete, list) {
 		if (pkt->mid == mid) {
 			pkt->last->next = frag;
@@ -1141,15 +1138,16 @@
 			pkt->length += frag->length;
 			if (PACMARK_LAST(pm)) {
 				list_del(&pkt->list);
-				spin_unlock_irqrestore(&ept->incomplete_lock,
-						       flags);
+				spin_unlock(&ept->incomplete_lock);
 				goto packet_complete;
 			}
-			spin_unlock_irqrestore(&ept->incomplete_lock, flags);
+			spin_unlock(&ept->incomplete_lock);
+			spin_unlock_irqrestore(&local_endpoints_lock, flags);
 			goto done;
 		}
 	}
-	spin_unlock_irqrestore(&ept->incomplete_lock, flags);
+	spin_unlock(&ept->incomplete_lock);
+	spin_unlock_irqrestore(&local_endpoints_lock, flags);
 	/* This mid is new -- create a packet for it, and put it on
 	 * the incomplete list if this fragment is not a last fragment,
 	 * otherwise put it on the read queue.
@@ -1161,18 +1159,31 @@
 	pkt->mid = mid;
 	pkt->length = frag->length;
 
+	spin_lock_irqsave(&local_endpoints_lock, flags);
+	ept = rpcrouter_lookup_local_endpoint(hdr.dst_cid);
+	if (!ept) {
+		spin_unlock_irqrestore(&local_endpoints_lock, flags);
+		DIAG("no local ept for cid %08x\n", hdr.dst_cid);
+		kfree(frag);
+		kfree(pkt);
+		goto done;
+	}
 	if (!PACMARK_LAST(pm)) {
+		spin_lock(&ept->incomplete_lock);
 		list_add_tail(&pkt->list, &ept->incomplete);
+		spin_unlock(&ept->incomplete_lock);
+		spin_unlock_irqrestore(&local_endpoints_lock, flags);
 		goto done;
 	}
 
 packet_complete:
-	spin_lock_irqsave(&ept->read_q_lock, flags);
+	spin_lock(&ept->read_q_lock);
 	D("%s: take read lock on ept %p\n", __func__, ept);
 	wake_lock(&ept->read_q_wake_lock);
 	list_add_tail(&pkt->list, &ept->read_q);
 	wake_up(&ept->wait_q);
-	spin_unlock_irqrestore(&ept->read_q_lock, flags);
+	spin_unlock(&ept->read_q_lock);
+	spin_unlock_irqrestore(&local_endpoints_lock, flags);
 done:
 
 	if (hdr.confirm_rx) {
@@ -1534,22 +1545,12 @@
 	int first_pkt = 1;
 	uint32_t mid;
 	unsigned long flags;
-	long oldnice = current->static_prio - 120;
-
-	set_user_nice(current, -15);
 
 	/* snoop the RPC packet and enforce permissions */
 
 	/* has to have at least the xid and type fields */
-
-	if (power_off_done) {
-		set_user_nice(current, oldnice);
-		return 0;
-	}
-
 	if (count < (sizeof(uint32_t) * 2)) {
 		printk(KERN_ERR "rr_write: rejecting runt packet\n");
-		set_user_nice(current, oldnice);
 		return -EINVAL;
 	}
 
@@ -1558,12 +1559,10 @@
 		if (count < (sizeof(uint32_t) * 6)) {
 			printk(KERN_ERR
 			       "rr_write: rejecting runt call packet\n");
-			set_user_nice(current, oldnice);
 			return -EINVAL;
 		}
 		if (ept->dst_pid == 0xffffffff) {
 			printk(KERN_ERR "rr_write: not connected\n");
-			set_user_nice(current, oldnice);
 			return -ENOTCONN;
 		}
 		if ((ept->dst_prog != rq->prog) ||
@@ -1575,7 +1574,6 @@
 			       be32_to_cpu(rq->prog), be32_to_cpu(rq->vers),
 			       be32_to_cpu(ept->dst_prog),
 			       be32_to_cpu(ept->dst_vers));
-			set_user_nice(current, oldnice);
 			return -EINVAL;
 		}
 		hdr.dst_pid = ept->dst_pid;
@@ -1589,7 +1587,6 @@
 		if (!reply) {
 			printk(KERN_ERR
 			       "rr_write: rejecting, reply not found \n");
-			set_user_nice(current, oldnice);
 			return -EINVAL;
 		}
 		hdr.dst_pid = reply->pid;
@@ -1663,7 +1660,6 @@
 		spin_unlock_irqrestore(&ept->reply_q_lock, flags);
 	}
 
-	set_user_nice(current, oldnice);
 	return count;
 }
 EXPORT_SYMBOL(msm_rpc_write);
@@ -1678,8 +1674,6 @@
 	char *buf;
 	int rc;
 
-	if (power_off_done)
-		return 0;
 	rc = __msm_rpc_read(ept, &frag, user_len, timeout);
 	if (rc <= 0)
 		return rc;
@@ -2535,4 +2529,3 @@
 MODULE_DESCRIPTION("MSM RPC Router");
 MODULE_AUTHOR("San Mehat <san@android.com>");
 MODULE_LICENSE("GPL");
-
diff -ru final2/arch/arm/mach-msm/smd_rpcrouter.h ics/arch/arm/mach-msm/smd_rpcrouter.h
--- final2/arch/arm/mach-msm/smd_rpcrouter.h	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/smd_rpcrouter.h	2013-04-19 11:37:14.000000000 +0200
@@ -256,7 +256,6 @@
 extern dev_t msm_rpcrouter_devno;
 extern struct completion rpc_remote_router_up;
 extern struct class *msm_rpcrouter_class;
-extern int power_off_done;
 
 void xdr_init(struct msm_rpc_xdr *xdr);
 void xdr_init_input(struct msm_rpc_xdr *xdr, void *buf, uint32_t size);
Nur in final2/arch/arm/mach-msm: smd_rpc_sym.c.
diff -ru final2/arch/arm/mach-msm/smd_tty.c ics/arch/arm/mach-msm/smd_tty.c
--- final2/arch/arm/mach-msm/smd_tty.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/smd_tty.c	2013-04-19 11:37:14.000000000 +0200
@@ -554,7 +554,6 @@
 			legacy_ds |= cpu_is_msm7x01() || cpu_is_msm7x25();
 			legacy_ds |= cpu_is_msm7x27() || cpu_is_msm7x30();
 			legacy_ds |= cpu_is_qsd8x50() || cpu_is_msm8x55();
-			legacy_ds |= cpu_is_msm7x25aa() || cpu_is_msm7x27aa();
 			/*
 			 * use legacy mode for 8660 Standalone (subtype 0)
 			 */
Nur in final2/arch/arm/mach-msm: smem_vendor_type.h.
diff -ru final2/arch/arm/mach-msm/socinfo.c ics/arch/arm/mach-msm/socinfo.c
--- final2/arch/arm/mach-msm/socinfo.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/socinfo.c	2013-04-19 11:37:14.000000000 +0200
@@ -549,15 +549,6 @@
 	return 0;
 }
 
-static void __init socinfo_remove_files(struct sys_device *dev,
-					struct sysdev_attribute files[],
-					int size)
-{
-	int i;
-	for (i = 0; i < size; i++)
-		sysdev_remove_file(dev, &files[i]);
-}
-
 static int __init socinfo_init_sysdev(void)
 {
 	int err;
@@ -570,113 +561,46 @@
 	err = sysdev_class_register(&soc_sysdev_class);
 	if (err) {
 		pr_err("%s: sysdev_class_register fail (%d)\n",
-		__func__, err);
-		goto ret;
+		       __func__, err);
+		return err;
 	}
-
 	err = sysdev_register(&soc_sys_device);
 	if (err) {
 		pr_err("%s: sysdev_register fail (%d)\n",
 		       __func__, err);
-		goto sys_class;
+		return err;
 	}
-
-	err = socinfo_create_files(&soc_sys_device, socinfo_v1_files,
+	socinfo_create_files(&soc_sys_device, socinfo_v1_files,
 				ARRAY_SIZE(socinfo_v1_files));
-
-	if (err) {
-		pr_err("%s: socinfo_create_files fail (%d)\n",
-		       __func__, err);
-		goto sys_reg;
-	}
-
 	if (socinfo->v1.format < 2)
-		goto sys_reg ;
-
-	err = socinfo_create_files(&soc_sys_device, socinfo_v2_files,
+		return err;
+	socinfo_create_files(&soc_sys_device, socinfo_v2_files,
 				ARRAY_SIZE(socinfo_v2_files));
 
-	if (err) {
-		pr_err("%s: socinfo_create_files fail (%d)\n",
-		       __func__, err);
-		goto soc_info2;
-	}
-
 	if (socinfo->v1.format < 3)
-		goto soc_info2;
+		return err;
 
-	err = socinfo_create_files(&soc_sys_device, socinfo_v3_files,
+	socinfo_create_files(&soc_sys_device, socinfo_v3_files,
 				ARRAY_SIZE(socinfo_v3_files));
 
-	if (err) {
-		pr_err("%s: socinfo_create_files fail (%d)\n",
-		       __func__, err);
-		goto soc_info3;
-	}
-
 	if (socinfo->v1.format < 4)
-		goto soc_info3;
+		return err;
 
-	err = socinfo_create_files(&soc_sys_device, socinfo_v4_files,
+	socinfo_create_files(&soc_sys_device, socinfo_v4_files,
 				ARRAY_SIZE(socinfo_v4_files));
 
-	if (err) {
-		pr_err("%s: socinfo_create_files fail (%d)\n",
-		       __func__, err);
-		goto soc_info4;
-	}
-
-#ifdef CONFIG_MACH_KYLE
-	goto ret;
-#endif
-
 	if (socinfo->v1.format < 5)
-		goto soc_info4;
+		return err;
 
-	err = socinfo_create_files(&soc_sys_device, socinfo_v5_files,
+	socinfo_create_files(&soc_sys_device, socinfo_v5_files,
 				ARRAY_SIZE(socinfo_v5_files));
 
-	if (err) {
-		pr_err("%s: socinfo_create_files fail (%d)\n",
-		       __func__, err);
-		goto soc_info5;
-	}
-
 	if (socinfo->v1.format < 6)
-		goto soc_info5;
+		return err;
 
-	err = socinfo_create_files(&soc_sys_device, socinfo_v6_files,
+	return socinfo_create_files(&soc_sys_device, socinfo_v6_files,
 				ARRAY_SIZE(socinfo_v6_files));
 
-	if (err) {
-		pr_err("%s: socinfo_create_files fail (%d)\n",
-		       __func__, err);
-		goto soc_info6;
-	}
-
-	goto ret;
-
-soc_info6:
-	socinfo_remove_files(&soc_sys_device, socinfo_v5_files,
-				ARRAY_SIZE(socinfo_v1_files));
-soc_info5:
-	socinfo_remove_files(&soc_sys_device, socinfo_v4_files,
-				ARRAY_SIZE(socinfo_v1_files));
-soc_info4:
-	socinfo_remove_files(&soc_sys_device, socinfo_v3_files,
-				ARRAY_SIZE(socinfo_v1_files));
-soc_info3:
-	socinfo_remove_files(&soc_sys_device, socinfo_v2_files,
-				ARRAY_SIZE(socinfo_v1_files));
-soc_info2:
-	socinfo_remove_files(&soc_sys_device, socinfo_v1_files,
-				ARRAY_SIZE(socinfo_v1_files));
-sys_reg:
-	sysdev_unregister(&soc_sys_device);
-sys_class:
-	sysdev_class_unregister(&soc_sysdev_class);
-ret:
-	return err;
 }
 
 arch_initcall(socinfo_init_sysdev);
diff -ru final2/arch/arm/mach-msm/timer.c ics/arch/arm/mach-msm/timer.c
--- final2/arch/arm/mach-msm/timer.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/arch/arm/mach-msm/timer.c	2013-04-19 11:37:14.000000000 +0200
@@ -31,7 +31,6 @@
 #include <mach/msm_iomap.h>
 #include <mach/irqs.h>
 #include <mach/socinfo.h>
-#include <linux/sec_debug.h>
 
 #if defined(CONFIG_MSM_SMD)
 #include "smd_private.h"
@@ -204,9 +203,6 @@
 	if (evt->event_handler == NULL)
 		return IRQ_HANDLED;
 	evt->event_handler(evt);
-#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
-	sec_debug_timer_log(2222, (int)irqs_disabled(),	(void *)evt->event_handler);
-#endif /* CONFIG_SEC_DEBUG_SCHED_LOG */
 	return IRQ_HANDLED;
 }
 
@@ -782,6 +778,8 @@
 		msm_timer_sync_to_gpt(clock, 0);
 
 	count = msm_read_timer_count(clock, LOCAL_TIMER);
+	if (clock_state->stopped++ == 0)
+		clock_state->stopped_tick = count + clock_state->sleep_offset;
 	alarm = clock_state->alarm;
 	delta = alarm - count;
 	if (delta <= -(int32_t)((clock->freq << clock->shift) >> 10)) {
@@ -790,8 +788,6 @@
 			"reprogram it\n", delta);
 		msm_timer_reactivate_alarm(clock);
 	}
-	if (clock_state->stopped++ == 0)
-		clock_state->stopped_tick = count + clock_state->sleep_offset;
 	if (delta <= 0)
 		return 0;
 	return clocksource_cyc2ns((alarm - count) >> clock->shift,
Nur in final2/arch/arm/mach-msm: wlan-prealloc.c.
diff -ru final2/arch/arm/mm/mmu.c ics/arch/arm/mm/mmu.c
--- final2/arch/arm/mm/mmu.c	2014-08-29 08:16:10.428240000 +0200
+++ ics/arch/arm/mm/mmu.c	2013-04-19 11:37:14.000000000 +0200
@@ -1219,7 +1219,7 @@
 	empty_zero_page = virt_to_page(zero_page);
 	__flush_dcache_page(NULL, empty_zero_page);
 
-#if defined(CONFIG_ARCH_MSM7X27) || defined(CONFIG_ARCH_MSM7X27A)
+#if defined(CONFIG_ARCH_MSM7X27)
 	/*
 	 * ensure that the strongly ordered page is mapped before the
 	 * first call to write_to_strongly_ordered_memory. This page
diff -ru final2/arch/microblaze/boot/dts/system.dts ics/arch/microblaze/boot/dts/system.dts
--- final2/arch/microblaze/boot/dts/system.dts	2014-08-29 08:16:11.108240000 +0200
+++ ics/arch/microblaze/boot/dts/system.dts	2013-04-19 11:37:14.000000000 +0200
@@ -1 +1,367 @@
-../../platform/generic/system.dts
+/*
+ * Device Tree Generator version: 1.1
+ *
+ * (C) Copyright 2007-2008 Xilinx, Inc.
+ * (C) Copyright 2007-2009 Michal Simek
+ *
+ * Michal SIMEK <monstr@monstr.eu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * CAUTION: This file is automatically generated by libgen.
+ * Version: Xilinx EDK 10.1.03 EDK_K_SP3.6
+ *
+ * XPS project directory: Xilinx-ML505-ll_temac-sgdma-MMU-FDT-edk101
+ */
+
+/dts-v1/;
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "xlnx,microblaze";
+	hard-reset-gpios = <&LEDs_8Bit 2 1>;
+	model = "testing";
+	DDR2_SDRAM: memory@90000000 {
+		device_type = "memory";
+		reg = < 0x90000000 0x10000000 >;
+	} ;
+	aliases {
+		ethernet0 = &Hard_Ethernet_MAC;
+		serial0 = &RS232_Uart_1;
+	} ;
+	chosen {
+		bootargs = "console=ttyUL0,115200 highres=on";
+		linux,stdout-path = "/plb@0/serial@84000000";
+	} ;
+	cpus {
+		#address-cells = <1>;
+		#cpus = <0x1>;
+		#size-cells = <0>;
+		microblaze_0: cpu@0 {
+			clock-frequency = <125000000>;
+			compatible = "xlnx,microblaze-7.10.d";
+			d-cache-baseaddr = <0x90000000>;
+			d-cache-highaddr = <0x9fffffff>;
+			d-cache-line-size = <0x10>;
+			d-cache-size = <0x2000>;
+			device_type = "cpu";
+			i-cache-baseaddr = <0x90000000>;
+			i-cache-highaddr = <0x9fffffff>;
+			i-cache-line-size = <0x10>;
+			i-cache-size = <0x2000>;
+			model = "microblaze,7.10.d";
+			reg = <0>;
+			timebase-frequency = <125000000>;
+			xlnx,addr-tag-bits = <0xf>;
+			xlnx,allow-dcache-wr = <0x1>;
+			xlnx,allow-icache-wr = <0x1>;
+			xlnx,area-optimized = <0x0>;
+			xlnx,cache-byte-size = <0x2000>;
+			xlnx,d-lmb = <0x1>;
+			xlnx,d-opb = <0x0>;
+			xlnx,d-plb = <0x1>;
+			xlnx,data-size = <0x20>;
+			xlnx,dcache-addr-tag = <0xf>;
+			xlnx,dcache-always-used = <0x1>;
+			xlnx,dcache-byte-size = <0x2000>;
+			xlnx,dcache-line-len = <0x4>;
+			xlnx,dcache-use-fsl = <0x1>;
+			xlnx,debug-enabled = <0x1>;
+			xlnx,div-zero-exception = <0x1>;
+			xlnx,dopb-bus-exception = <0x0>;
+			xlnx,dynamic-bus-sizing = <0x1>;
+			xlnx,edge-is-positive = <0x1>;
+			xlnx,family = "virtex5";
+			xlnx,endianness = <0x1>;
+			xlnx,fpu-exception = <0x1>;
+			xlnx,fsl-data-size = <0x20>;
+			xlnx,fsl-exception = <0x0>;
+			xlnx,fsl-links = <0x0>;
+			xlnx,i-lmb = <0x1>;
+			xlnx,i-opb = <0x0>;
+			xlnx,i-plb = <0x1>;
+			xlnx,icache-always-used = <0x1>;
+			xlnx,icache-line-len = <0x4>;
+			xlnx,icache-use-fsl = <0x1>;
+			xlnx,ill-opcode-exception = <0x1>;
+			xlnx,instance = "microblaze_0";
+			xlnx,interconnect = <0x1>;
+			xlnx,interrupt-is-edge = <0x0>;
+			xlnx,iopb-bus-exception = <0x0>;
+			xlnx,mmu-dtlb-size = <0x4>;
+			xlnx,mmu-itlb-size = <0x2>;
+			xlnx,mmu-tlb-access = <0x3>;
+			xlnx,mmu-zones = <0x10>;
+			xlnx,number-of-pc-brk = <0x1>;
+			xlnx,number-of-rd-addr-brk = <0x0>;
+			xlnx,number-of-wr-addr-brk = <0x0>;
+			xlnx,opcode-0x0-illegal = <0x1>;
+			xlnx,pvr = <0x2>;
+			xlnx,pvr-user1 = <0x0>;
+			xlnx,pvr-user2 = <0x0>;
+			xlnx,reset-msr = <0x0>;
+			xlnx,sco = <0x0>;
+			xlnx,unaligned-exceptions = <0x1>;
+			xlnx,use-barrel = <0x1>;
+			xlnx,use-dcache = <0x1>;
+			xlnx,use-div = <0x1>;
+			xlnx,use-ext-brk = <0x1>;
+			xlnx,use-ext-nm-brk = <0x1>;
+			xlnx,use-extended-fsl-instr = <0x0>;
+			xlnx,use-fpu = <0x2>;
+			xlnx,use-hw-mul = <0x2>;
+			xlnx,use-icache = <0x1>;
+			xlnx,use-interrupt = <0x1>;
+			xlnx,use-mmu = <0x3>;
+			xlnx,use-msr-instr = <0x1>;
+			xlnx,use-pcmp-instr = <0x1>;
+		} ;
+	} ;
+	mb_plb: plb@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "xlnx,plb-v46-1.03.a", "xlnx,plb-v46-1.00.a", "simple-bus";
+		ranges ;
+		FLASH: flash@a0000000 {
+			bank-width = <2>;
+			compatible = "xlnx,xps-mch-emc-2.00.a", "cfi-flash";
+			reg = < 0xa0000000 0x2000000 >;
+			xlnx,family = "virtex5";
+			xlnx,include-datawidth-matching-0 = <0x1>;
+			xlnx,include-datawidth-matching-1 = <0x0>;
+			xlnx,include-datawidth-matching-2 = <0x0>;
+			xlnx,include-datawidth-matching-3 = <0x0>;
+			xlnx,include-negedge-ioregs = <0x0>;
+			xlnx,include-plb-ipif = <0x1>;
+			xlnx,include-wrbuf = <0x1>;
+			xlnx,max-mem-width = <0x10>;
+			xlnx,mch-native-dwidth = <0x20>;
+			xlnx,mch-plb-clk-period-ps = <0x1f40>;
+			xlnx,mch-splb-awidth = <0x20>;
+			xlnx,mch0-accessbuf-depth = <0x10>;
+			xlnx,mch0-protocol = <0x0>;
+			xlnx,mch0-rddatabuf-depth = <0x10>;
+			xlnx,mch1-accessbuf-depth = <0x10>;
+			xlnx,mch1-protocol = <0x0>;
+			xlnx,mch1-rddatabuf-depth = <0x10>;
+			xlnx,mch2-accessbuf-depth = <0x10>;
+			xlnx,mch2-protocol = <0x0>;
+			xlnx,mch2-rddatabuf-depth = <0x10>;
+			xlnx,mch3-accessbuf-depth = <0x10>;
+			xlnx,mch3-protocol = <0x0>;
+			xlnx,mch3-rddatabuf-depth = <0x10>;
+			xlnx,mem0-width = <0x10>;
+			xlnx,mem1-width = <0x20>;
+			xlnx,mem2-width = <0x20>;
+			xlnx,mem3-width = <0x20>;
+			xlnx,num-banks-mem = <0x1>;
+			xlnx,num-channels = <0x0>;
+			xlnx,priority-mode = <0x0>;
+			xlnx,synch-mem-0 = <0x0>;
+			xlnx,synch-mem-1 = <0x0>;
+			xlnx,synch-mem-2 = <0x0>;
+			xlnx,synch-mem-3 = <0x0>;
+			xlnx,synch-pipedelay-0 = <0x2>;
+			xlnx,synch-pipedelay-1 = <0x2>;
+			xlnx,synch-pipedelay-2 = <0x2>;
+			xlnx,synch-pipedelay-3 = <0x2>;
+			xlnx,tavdv-ps-mem-0 = <0x1adb0>;
+			xlnx,tavdv-ps-mem-1 = <0x3a98>;
+			xlnx,tavdv-ps-mem-2 = <0x3a98>;
+			xlnx,tavdv-ps-mem-3 = <0x3a98>;
+			xlnx,tcedv-ps-mem-0 = <0x1adb0>;
+			xlnx,tcedv-ps-mem-1 = <0x3a98>;
+			xlnx,tcedv-ps-mem-2 = <0x3a98>;
+			xlnx,tcedv-ps-mem-3 = <0x3a98>;
+			xlnx,thzce-ps-mem-0 = <0x88b8>;
+			xlnx,thzce-ps-mem-1 = <0x1b58>;
+			xlnx,thzce-ps-mem-2 = <0x1b58>;
+			xlnx,thzce-ps-mem-3 = <0x1b58>;
+			xlnx,thzoe-ps-mem-0 = <0x1b58>;
+			xlnx,thzoe-ps-mem-1 = <0x1b58>;
+			xlnx,thzoe-ps-mem-2 = <0x1b58>;
+			xlnx,thzoe-ps-mem-3 = <0x1b58>;
+			xlnx,tlzwe-ps-mem-0 = <0x88b8>;
+			xlnx,tlzwe-ps-mem-1 = <0x0>;
+			xlnx,tlzwe-ps-mem-2 = <0x0>;
+			xlnx,tlzwe-ps-mem-3 = <0x0>;
+			xlnx,twc-ps-mem-0 = <0x2af8>;
+			xlnx,twc-ps-mem-1 = <0x3a98>;
+			xlnx,twc-ps-mem-2 = <0x3a98>;
+			xlnx,twc-ps-mem-3 = <0x3a98>;
+			xlnx,twp-ps-mem-0 = <0x11170>;
+			xlnx,twp-ps-mem-1 = <0x2ee0>;
+			xlnx,twp-ps-mem-2 = <0x2ee0>;
+			xlnx,twp-ps-mem-3 = <0x2ee0>;
+			xlnx,xcl0-linesize = <0x4>;
+			xlnx,xcl0-writexfer = <0x1>;
+			xlnx,xcl1-linesize = <0x4>;
+			xlnx,xcl1-writexfer = <0x1>;
+			xlnx,xcl2-linesize = <0x4>;
+			xlnx,xcl2-writexfer = <0x1>;
+			xlnx,xcl3-linesize = <0x4>;
+			xlnx,xcl3-writexfer = <0x1>;
+		} ;
+		Hard_Ethernet_MAC: xps-ll-temac@81c00000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "xlnx,compound";
+			ranges ;
+			ethernet@81c00000 {
+				compatible = "xlnx,xps-ll-temac-1.01.b", "xlnx,xps-ll-temac-1.00.a";
+				device_type = "network";
+				interrupt-parent = <&xps_intc_0>;
+				interrupts = < 5 2 >;
+				llink-connected = <&PIM3>;
+				local-mac-address = [ 00 0a 35 00 00 00 ];
+				reg = < 0x81c00000 0x40 >;
+				xlnx,bus2core-clk-ratio = <0x1>;
+				xlnx,phy-type = <0x1>;
+				xlnx,phyaddr = <0x1>;
+				xlnx,rxcsum = <0x0>;
+				xlnx,rxfifo = <0x1000>;
+				xlnx,temac-type = <0x0>;
+				xlnx,txcsum = <0x0>;
+				xlnx,txfifo = <0x1000>;
+			} ;
+		} ;
+		IIC_EEPROM: i2c@81600000 {
+			compatible = "xlnx,xps-iic-2.00.a";
+			interrupt-parent = <&xps_intc_0>;
+			interrupts = < 6 2 >;
+			reg = < 0x81600000 0x10000 >;
+			xlnx,clk-freq = <0x7735940>;
+			xlnx,family = "virtex5";
+			xlnx,gpo-width = <0x1>;
+			xlnx,iic-freq = <0x186a0>;
+			xlnx,scl-inertial-delay = <0x0>;
+			xlnx,sda-inertial-delay = <0x0>;
+			xlnx,ten-bit-adr = <0x0>;
+		} ;
+		LEDs_8Bit: gpio@81400000 {
+			compatible = "xlnx,xps-gpio-1.00.a";
+			interrupt-parent = <&xps_intc_0>;
+			interrupts = < 7 2 >;
+			reg = < 0x81400000 0x10000 >;
+			xlnx,all-inputs = <0x0>;
+			xlnx,all-inputs-2 = <0x0>;
+			xlnx,dout-default = <0x0>;
+			xlnx,dout-default-2 = <0x0>;
+			xlnx,family = "virtex5";
+			xlnx,gpio-width = <0x8>;
+			xlnx,interrupt-present = <0x1>;
+			xlnx,is-bidir = <0x1>;
+			xlnx,is-bidir-2 = <0x1>;
+			xlnx,is-dual = <0x0>;
+			xlnx,tri-default = <0xffffffff>;
+			xlnx,tri-default-2 = <0xffffffff>;
+			#gpio-cells = <2>;
+			gpio-controller;
+		} ;
+
+		gpio-leds {
+			compatible = "gpio-leds";
+
+			heartbeat {
+				label = "Heartbeat";
+				gpios = <&LEDs_8Bit 4 1>;
+				linux,default-trigger = "heartbeat";
+			};
+
+			yellow {
+				label = "Yellow";
+				gpios = <&LEDs_8Bit 5 1>;
+			};
+
+			red {
+				label = "Red";
+				gpios = <&LEDs_8Bit 6 1>;
+			};
+
+			green {
+				label = "Green";
+				gpios = <&LEDs_8Bit 7 1>;
+			};
+		} ;
+		RS232_Uart_1: serial@84000000 {
+			clock-frequency = <125000000>;
+			compatible = "xlnx,xps-uartlite-1.00.a";
+			current-speed = <115200>;
+			device_type = "serial";
+			interrupt-parent = <&xps_intc_0>;
+			interrupts = < 8 0 >;
+			port-number = <0>;
+			reg = < 0x84000000 0x10000 >;
+			xlnx,baudrate = <0x1c200>;
+			xlnx,data-bits = <0x8>;
+			xlnx,family = "virtex5";
+			xlnx,odd-parity = <0x0>;
+			xlnx,use-parity = <0x0>;
+		} ;
+		SysACE_CompactFlash: sysace@83600000 {
+			compatible = "xlnx,xps-sysace-1.00.a";
+			interrupt-parent = <&xps_intc_0>;
+			interrupts = < 4 2 >;
+			reg = < 0x83600000 0x10000 >;
+			xlnx,family = "virtex5";
+			xlnx,mem-width = <0x10>;
+		} ;
+		debug_module: debug@84400000 {
+			compatible = "xlnx,mdm-1.00.d";
+			reg = < 0x84400000 0x10000 >;
+			xlnx,family = "virtex5";
+			xlnx,interconnect = <0x1>;
+			xlnx,jtag-chain = <0x2>;
+			xlnx,mb-dbg-ports = <0x1>;
+			xlnx,uart-width = <0x8>;
+			xlnx,use-uart = <0x1>;
+			xlnx,write-fsl-ports = <0x0>;
+		} ;
+		mpmc@90000000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "xlnx,mpmc-4.02.a";
+			ranges ;
+			PIM3: sdma@84600180 {
+				compatible = "xlnx,ll-dma-1.00.a";
+				interrupt-parent = <&xps_intc_0>;
+				interrupts = < 2 2 1 2 >;
+				reg = < 0x84600180 0x80 >;
+			} ;
+		} ;
+		xps_intc_0: interrupt-controller@81800000 {
+			#interrupt-cells = <0x2>;
+			compatible = "xlnx,xps-intc-1.00.a";
+			interrupt-controller ;
+			reg = < 0x81800000 0x10000 >;
+			xlnx,kind-of-intr = <0x100>;
+			xlnx,num-intr-inputs = <0x9>;
+		} ;
+		xps_timer_1: timer@83c00000 {
+			compatible = "xlnx,xps-timer-1.00.a";
+			interrupt-parent = <&xps_intc_0>;
+			interrupts = < 3 2 >;
+			reg = < 0x83c00000 0x10000 >;
+			xlnx,count-width = <0x20>;
+			xlnx,family = "virtex5";
+			xlnx,gen0-assert = <0x1>;
+			xlnx,gen1-assert = <0x1>;
+			xlnx,one-timer-only = <0x0>;
+			xlnx,trig0-assert = <0x1>;
+			xlnx,trig1-assert = <0x1>;
+		} ;
+	} ;
+}  ;
Nur in ics/Documentation/DocBook: media.
diff -ru final2/drivers/block/loop.c ics/drivers/block/loop.c
--- final2/drivers/block/loop.c	2014-08-29 08:16:13.224240000 +0200
+++ ics/drivers/block/loop.c	2013-04-19 11:37:14.000000000 +0200
@@ -1289,6 +1289,7 @@
 {
 	struct loop_device *lo = bdev->bd_disk->private_data;
 	int err;
+
 	mutex_lock_nested(&lo->lo_ctl_mutex, 1);
 	switch (cmd) {
 	case LOOP_SET_FD:
@@ -1327,7 +1328,6 @@
 
 out_unlocked:
 	return err;
-
 }
 
 #ifdef CONFIG_COMPAT
diff -ru final2/drivers/bluetooth/bluecard_cs.c ics/drivers/bluetooth/bluecard_cs.c
--- final2/drivers/bluetooth/bluecard_cs.c	2014-08-29 08:16:13.240240000 +0200
+++ ics/drivers/bluetooth/bluecard_cs.c	2013-04-19 11:37:14.000000000 +0200
@@ -930,7 +930,7 @@
 	pcmcia_disable_device(link);
 }
 
-static const struct pcmcia_device_id bluecard_ids[] = {
+static struct pcmcia_device_id bluecard_ids[] = {
 	PCMCIA_DEVICE_PROD_ID12("BlueCard", "LSE041", 0xbaf16fbf, 0x657cc15e),
 	PCMCIA_DEVICE_PROD_ID12("BTCFCARD", "LSE139", 0xe3987764, 0x2524b59c),
 	PCMCIA_DEVICE_PROD_ID12("WSS", "LSE039", 0x0a0736ec, 0x24e6dfab),
diff -ru final2/drivers/bluetooth/bluesleep.c ics/drivers/bluetooth/bluesleep.c
--- final2/drivers/bluetooth/bluesleep.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/bluetooth/bluesleep.c	2013-04-19 11:37:14.000000000 +0200
@@ -13,6 +13,7 @@
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
 
+
    Copyright (C) 2006-2007 - Motorola
    Copyright (c) 2008-2010, The Linux Foundation. All rights reserved.
 
@@ -43,10 +44,9 @@
 #include <linux/param.h>
 #include <linux/bitops.h>
 #include <linux/termios.h>
-#include <linux/wakelock.h>
-#include <linux/rfkill.h>
 #include <mach/gpio.h>
 #include <mach/msm_serial_hs.h>
+
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h> /* event notifications */
 #include "hci_uart.h"
@@ -62,24 +62,12 @@
 #define VERSION		"1.1"
 #define PROC_DIR	"bluetooth/sleep"
 
-#ifdef CONFIG_BT_CSR_7820
-struct bluesleep_info {
-	unsigned host_wake;
-	unsigned host_wake_irq;
-	struct uart_port *uport;
-	struct wake_lock wake_lock;
-};
-static int ext_wake_active;
-static int bt_enter_sleep_mode_cnt;
-#else
 struct bluesleep_info {
 	unsigned host_wake;
 	unsigned ext_wake;
 	unsigned host_wake_irq;
 	struct uart_port *uport;
-	struct wake_lock wake_lock;
 };
-#endif
 
 /* work function */
 static void bluesleep_sleep_work(struct work_struct *work);
@@ -103,6 +91,7 @@
 
 /* global pointer to a single hci device. */
 static struct hci_dev *bluesleep_hdev;
+
 static struct bluesleep_info *bsi;
 
 /* module usage */
@@ -110,7 +99,6 @@
 
 /*
  * Local function prototypes
- * Local & Extern function prototypes
  */
 
 static int bluesleep_hci_event(struct notifier_block *this,
@@ -142,25 +130,14 @@
 /*
  * Local functions
  */
+
 static void hsuart_power(int on)
 {
-	#ifdef CONFIG_BT_CSR_7820
-	if (bsi->uport == NULL) {
-		BT_INFO("hsuart_power...but bsi->uport == NULL , so return");
-		return ;
-	}
-	#endif
-
-	BT_INFO("hsuart_power  isOn(%d)\n", on);
 	if (on) {
 		msm_hs_request_clock_on(bsi->uport);
-		#ifndef CONFIG_BT_CSR_7820
 		msm_hs_set_mctrl(bsi->uport, TIOCM_RTS);
-		#endif
 	} else {
-		#ifndef CONFIG_BT_CSR_7820
 		msm_hs_set_mctrl(bsi->uport, 0);
-		#endif
 		msm_hs_request_clock_off(bsi->uport);
 	}
 }
@@ -172,15 +149,9 @@
 static inline int bluesleep_can_sleep(void)
 {
 	/* check if MSM_WAKE_BT_GPIO and BT_WAKE_MSM_GPIO are both deasserted */
-	#ifdef CONFIG_BT_CSR_7820
-	return (ext_wake_active == 0) &&
-		!gpio_get_value(bsi->host_wake) &&
-		(bsi->uport != NULL);
-	#else
 	return gpio_get_value(bsi->ext_wake) &&
 		gpio_get_value(bsi->host_wake) &&
 		(bsi->uport != NULL);
-	#endif
 }
 
 void bluesleep_sleep_wakeup(void)
@@ -189,14 +160,7 @@
 		BT_DBG("waking up...");
 		/* Start the timer */
 		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-
-		#ifdef CONFIG_BT_CSR_7820
-		wake_lock(&bsi->wake_lock);
-		ext_wake_active = 1;
-		#else
-		gpio_set_value(bsi->ext_wake,  0);
-		#endif
-
+		gpio_set_value(bsi->ext_wake, 0);
 		clear_bit(BT_ASLEEP, &flags);
 		/*Activating UART */
 		hsuart_power(1);
@@ -215,42 +179,18 @@
 			BT_DBG("already asleep");
 			return;
 		}
-		#ifdef CONFIG_BT_CSR_7820
-		if (msm_hs_tx_empty(bsi->uport)) {
-			bt_enter_sleep_mode_cnt++;
-			BT_INFO("hsuart_power...bt_enter_sleep_mode_cnt ++");
-		} else {
-			bt_enter_sleep_mode_cnt = 0;
-			BT_INFO("hsuart_power...bt_enter_sleep_mode_cnt init");
-		}
-		#endif
 
-		if (msm_hs_tx_empty(bsi->uport)
-		#ifdef CONFIG_BT_CSR_7820
-		&& bt_enter_sleep_mode_cnt > 2
-		#endif
-		) {
+		if (msm_hs_tx_empty(bsi->uport)) {
 			BT_DBG("going to sleep...");
-			#ifdef CONFIG_BT_CSR_7820
-			bt_enter_sleep_mode_cnt = 0;
-			#endif
 			set_bit(BT_ASLEEP, &flags);
 			/*Deactivating UART */
 			hsuart_power(0);
-			#ifdef CONFIG_BT_CSR_7820
-			/* UART clk is not turned off immediately. Release
-			* wakelock after 500 ms.
-			*/
-			wake_lock_timeout(&bsi->wake_lock, HZ / 2);
-			#endif
 		} else {
+
 		  mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
 			return;
 		}
 	} else {
-		#ifdef CONFIG_BT_CSR_7820
-		bt_enter_sleep_mode_cnt = 0;
-		#endif
 		bluesleep_sleep_wakeup();
 	}
 }
@@ -262,15 +202,10 @@
  */
 static void bluesleep_hostwake_task(unsigned long data)
 {
-	BT_DBG("bluesleep_hostwake_task-hostwake -> %u",
-		gpio_get_value(bsi->host_wake));
+	BT_DBG("hostwake line change");
 
 	spin_lock(&rw_lock);
 
-#ifdef CONFIG_BT_CSR_7820
-	ext_wake_active = 1;
-#endif
-
 	if (gpio_get_value(bsi->host_wake))
 		bluesleep_rx_busy();
 	else
@@ -292,15 +227,13 @@
 	/* log data passing by */
 	set_bit(BT_TXDATA, &flags);
 
-#ifndef CONFIG_BT_CSR_7820
 	/* if the tx side is sleeping... */
 	if (gpio_get_value(bsi->ext_wake)) {
+
 		BT_DBG("tx was sleeping");
 		bluesleep_sleep_wakeup();
 	}
-#else
-	bluesleep_sleep_wakeup();
-#endif
+
 	spin_unlock_irqrestore(&rw_lock, irq_flags);
 }
 
@@ -328,25 +261,15 @@
 			hu  = (struct hci_uart *) hdev->driver_data;
 			state = (struct uart_state *) hu->tty->driver_data;
 			bsi->uport = state->uart_port;
-			printk(KERN_ERR "[BT] wake_peer is registered.\n");
 		}
 		break;
 	case HCI_DEV_UNREG:
-		printk(KERN_ERR "[BT] wake_peer is unregistered.\n");
 		bluesleep_hdev = NULL;
 		bsi->uport = NULL;
 		break;
-#ifdef CONFIG_BT_CSR_7820
 	case HCI_DEV_WRITE:
-	case HCI_DEV_READ:
-		 mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
-		 bluesleep_outgoing_data();
-		 break;
-#else
-	case HCI_DEV_WRITE:
-		 bluesleep_outgoing_data();
-		 break;
-#endif
+		bluesleep_outgoing_data();
+		break;
 	}
 
 	return NOTIFY_DONE;
@@ -362,19 +285,15 @@
 
 	spin_lock_irqsave(&rw_lock, irq_flags);
 
-	BT_DBG("bluesleep_tx_timer_expire-Tx timer expired");
+	BT_DBG("Tx timer expired");
 
 	/* were we silent during the last timeout? */
 	if (!test_bit(BT_TXDATA, &flags)) {
 		BT_DBG("Tx has been idle");
-		#ifdef CONFIG_BT_CSR_7820
-		ext_wake_active = 0;
-		#else
 		gpio_set_value(bsi->ext_wake, 1);
-		#endif
 		bluesleep_tx_idle();
 	} else {
-		BT_DBG("bluesleep_tx_timer_expire-Tx data during last period");
+		BT_DBG("Tx data during last period");
 		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL*HZ));
 	}
 
@@ -402,15 +321,11 @@
  * @return On success, 0. On error, -1, and <code>errno</code> is set
  * appropriately.
  */
-#ifdef CONFIG_BT_CSR_7820
-int bluesleep_start(void)
-#else
 static int bluesleep_start(void)
-#endif
 {
 	int retval;
 	unsigned long irq_flags;
-	pr_info("bluesleep_start\n");
+
 	spin_lock_irqsave(&rw_lock, irq_flags);
 
 	if (test_bit(BT_PROTO, &flags)) {
@@ -426,34 +341,14 @@
 	}
 
 	/* start the timer */
-#ifndef CONFIG_BT_CSR_7820
+
 	mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL*HZ));
-#else
-	mod_timer(&tx_timer, jiffies + (10*HZ));
-#endif
 
 	/* assert BT_WAKE */
-	#ifndef CONFIG_BT_CSR_7820
 	gpio_set_value(bsi->ext_wake, 0);
-	#else
-	/* assert BT_WAKE */
-	/* gpio_configure(bsi->ext_wake, GPIOF_DRIVE_OUTPUT
-	| GPIOF_OUTPUT_HIGH);
-	gpio_tlmm_config(GPIO_CFG(bsi->ext_wake,
-	0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_UP, GPIO_CFG_2MA), GPIO_CFG_ENABLE);*/
-	ext_wake_active = 0;
-	/*gpio_configure(bsi->host_wake, GPIOF_INPUT);
-	gpio_tlmm_config(GPIO_CFG(bsi->host_wake,
-	0, GPIO_CFG_INPUT, GPIO_CFG_NO_PULL, GPIO_CFG_2MA), GPIO_CFG_ENABLE);*/
-	#endif
-
 	retval = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
-		#ifdef CONFIG_BT_CSR_7820
-		IRQF_DISABLED | IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
-		#else
-		IRQF_DISABLED | IRQF_TRIGGER_FALLING,
-		#endif
-		"bluetooth hostwake", NULL);
+				IRQF_DISABLED | IRQF_TRIGGER_FALLING,
+				"bluetooth hostwake", NULL);
 	if (retval  < 0) {
 		BT_ERR("Couldn't acquire BT_HOST_WAKE IRQ");
 		goto fail;
@@ -465,11 +360,8 @@
 		free_irq(bsi->host_wake_irq, NULL);
 		goto fail;
 	}
-	BT_INFO("bluesleep_start-Success!! Enable BT_HOST_WAKE as wakeup interrupt");
+
 	set_bit(BT_PROTO, &flags);
-	#ifdef CONFIG_BT_CSR_7820
-	wake_lock(&bsi->wake_lock);
-	#endif
 	return 0;
 fail:
 	del_timer(&tx_timer);
@@ -481,14 +373,9 @@
 /**
  * Stops the Sleep-Mode Protocol on the Host.
  */
-#ifdef CONFIG_BT_CSR_7820
-void bluesleep_stop(void)
-#else
 static void bluesleep_stop(void)
-#endif
 {
 	unsigned long irq_flags;
-	BT_INFO("bluesleep_stop :   start-->\n");
 
 	spin_lock_irqsave(&rw_lock, irq_flags);
 
@@ -497,12 +384,8 @@
 		return;
 	}
 
-	/* deny BT_WAKE */
-	#ifdef CONFIG_BT_CSR_7820
-	ext_wake_active = 0 ;
-	#else
+	/* assert BT_WAKE */
 	gpio_set_value(bsi->ext_wake, 0);
-	#endif
 	del_timer(&tx_timer);
 	clear_bit(BT_PROTO, &flags);
 
@@ -517,11 +400,6 @@
 	if (disable_irq_wake(bsi->host_wake_irq))
 		BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
 	free_irq(bsi->host_wake_irq, NULL);
-	#ifdef CONFIG_BT_CSR_7820
-	wake_lock_timeout(&bsi->wake_lock, HZ / 2);
-	#endif
-
-	BT_INFO("bluesleep_stop :  <--end\n");
 }
 /**
  * Read the <code>BT_WAKE</code> GPIO pin value via the proc interface.
@@ -535,54 +413,6 @@
  * @param data Not used.
  * @return The number of bytes written.
  */
-
-#ifdef CONFIG_BT_CSR_7820
-static int bluepower_read_proc_btwake(char *page, char **start, off_t offset,
-					int count, int *eof, void *data)
-{
-	*eof = 1;
-	return snprintf(page, 20, "btwake:%u\n", ext_wake_active);
-}
-
-/**
- * Write the <code>BT_WAKE</code> GPIO pin value via the proc interface.
- * @param file Not used.
- * @param buffer The buffer to read from.
- * @param count The number of bytes to be written.
- * @param data Not used.
- * @return On success, the number of bytes written. On error, -1, and
- * <code>errno</code> is set appropriately.
- */
-static int bluepower_write_proc_btwake(struct file *file, const char *buffer,
-					unsigned long count, void *data)
-{
-	char *buf;
-
-	if (count < 1)
-		return -EINVAL;
-
-	buf = kmalloc(count, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-
-	if (copy_from_user(buf, buffer, count)) {
-		kfree(buf);
-		return -EFAULT;
-	}
-
-	if (buf[0] == '0') {
-		ext_wake_active = 0;
-	} else if (buf[0] == '1') {
-		ext_wake_active = 1;
-	} else {
-		kfree(buf);
-		return -EINVAL;
-	}
-
-	kfree(buf);
-	return count;
-}
-#else
 static int bluepower_read_proc_btwake(char *page, char **start, off_t offset,
 					int count, int *eof, void *data)
 {
@@ -628,7 +458,6 @@
 	kfree(buf);
 	return count;
 }
-#endif
 
 /**
  * Read the <code>BT_HOST_WAKE</code> GPIO pin value via the proc interface.
@@ -748,10 +577,6 @@
 	if (ret)
 		goto free_bt_host_wake;
 
-	#ifdef CONFIG_BT_CSR_7820
-	ext_wake_active = 0;
-	#else
-
 	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
 				"gpio_ext_wake");
 	if (!res) {
@@ -769,8 +594,6 @@
 	if (ret)
 		goto free_bt_ext_wake;
 
-	#endif
-
 	bsi->host_wake_irq = platform_get_irq_byname(pdev, "host_wake");
 	if (bsi->host_wake_irq < 0) {
 		BT_ERR("couldn't find host_wake irq\n");
@@ -778,15 +601,11 @@
 		goto free_bt_ext_wake;
 	}
 
-	#ifdef CONFIG_BT_CSR_7820
-	wake_lock_init(&bsi->wake_lock, WAKE_LOCK_SUSPEND, "bluesleep");
-	#endif
+
 	return 0;
 
 free_bt_ext_wake:
-	#ifndef CONFIG_BT_CSR_7820
 	gpio_free(bsi->ext_wake);
-	#endif
 free_bt_host_wake:
 	gpio_free(bsi->host_wake);
 free_bsi:
@@ -796,26 +615,19 @@
 
 static int bluesleep_remove(struct platform_device *pdev)
 {
-	#ifndef CONFIG_BT_CSR_7820
 	/* assert bt wake */
 	gpio_set_value(bsi->ext_wake, 0);
 	if (test_bit(BT_PROTO, &flags)) {
 		if (disable_irq_wake(bsi->host_wake_irq))
-			BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
+			BT_ERR("Couldn't disable hostwake IRQ wakeup mode \n");
 		free_irq(bsi->host_wake_irq, NULL);
 		del_timer(&tx_timer);
 		if (test_bit(BT_ASLEEP, &flags))
 			hsuart_power(1);
 	}
-	#endif
 
 	gpio_free(bsi->host_wake);
-	#ifndef CONFIG_BT_CSR_7820
 	gpio_free(bsi->ext_wake);
-	#endif
-	#ifdef CONFIG_BT_CSR_7820
-	wake_lock_destroy(&bsi->wake_lock);
-	#endif
 	kfree(bsi);
 	return 0;
 }
@@ -837,7 +649,7 @@
 	int retval;
 	struct proc_dir_entry *ent;
 
-	BT_INFO("bluesleep_init:MSM Sleep Mode Driver Ver %s", VERSION);
+	BT_INFO("MSM Sleep Mode Driver Ver %s", VERSION);
 
 	retval = platform_driver_probe(&bluesleep_driver, bluesleep_probe);
 	if (retval)
@@ -862,7 +674,7 @@
 	if (ent == NULL) {
 		BT_ERR("Unable to create /proc/%s/btwake entry", PROC_DIR);
 		retval = -ENOMEM;
-	goto fail;
+		goto fail;
 	}
 	ent->read_proc = bluepower_read_proc_btwake;
 	ent->write_proc = bluepower_write_proc_btwake;
@@ -872,7 +684,7 @@
 				bluepower_read_proc_hostwake, NULL) == NULL) {
 		BT_ERR("Unable to create /proc/%s/hostwake entry", PROC_DIR);
 		retval = -ENOMEM;
-	goto fail;
+		goto fail;
 	}
 
 	/* read/write proc entries */
@@ -880,7 +692,7 @@
 	if (ent == NULL) {
 		BT_ERR("Unable to create /proc/%s/proto entry", PROC_DIR);
 		retval = -ENOMEM;
-	goto fail;
+		goto fail;
 	}
 	ent->read_proc = bluesleep_read_proc_proto;
 	ent->write_proc = bluesleep_write_proc_proto;
@@ -890,7 +702,7 @@
 			sleep_dir, bluesleep_read_proc_asleep, NULL) == NULL) {
 		BT_ERR("Unable to create /proc/%s/asleep entry", PROC_DIR);
 		retval = -ENOMEM;
-	goto fail;
+		goto fail;
 	}
 
 	flags = 0; /* clear all status bits */
@@ -906,10 +718,6 @@
 	/* initialize host wake tasklet */
 	tasklet_init(&hostwake_task, bluesleep_hostwake_task, 0);
 
-	#ifdef CONFIG_BT_CSR_7820
-	ext_wake_active = 0;
-	#endif
-
 	hci_register_notifier(&hci_event_nblock);
 
 	return 0;
@@ -929,22 +737,6 @@
  */
 static void __exit bluesleep_exit(void)
 {
-	/* assert bt wake */
-	#ifdef CONFIG_BT_CSR_7820
-	ext_wake_active = 0;
-
-	if (test_bit(BT_PROTO, &flags)) {
-		if (disable_irq_wake(bsi->host_wake_irq))
-			BT_ERR("Couldn't disable hostwake IRQ wakeup mode\n");
-
-		free_irq(bsi->host_wake_irq, NULL);
-		del_timer(&tx_timer);
-
-		if (test_bit(BT_ASLEEP, &flags))
-			hsuart_power(1);
-	}
-	#endif
-
 	hci_unregister_notifier(&hci_event_nblock);
 	platform_driver_unregister(&bluesleep_driver);
 
diff -ru final2/drivers/bluetooth/bluetooth-power.c ics/drivers/bluetooth/bluetooth-power.c
--- final2/drivers/bluetooth/bluetooth-power.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/bluetooth/bluetooth-power.c	2013-04-19 11:37:14.000000000 +0200
@@ -27,6 +27,7 @@
 {
 	int ret = 0;
 	int (*power_control)(int enable);
+
 	power_control = data;
 	if (previous != blocked)
 		ret = (*power_control)(!blocked);
@@ -119,7 +120,7 @@
 static int __init bluetooth_power_init(void)
 {
 	int ret;
-	pr_info("bluetooth_power_init\n");
+
 	ret = platform_driver_register(&bt_power_driver);
 	return ret;
 }
diff -ru final2/drivers/bluetooth/bt3c_cs.c ics/drivers/bluetooth/bt3c_cs.c
--- final2/drivers/bluetooth/bt3c_cs.c	2014-08-29 08:16:13.240240000 +0200
+++ ics/drivers/bluetooth/bt3c_cs.c	2013-04-19 11:37:14.000000000 +0200
@@ -761,7 +761,7 @@
 }
 
 
-static const struct pcmcia_device_id bt3c_ids[] = {
+static struct pcmcia_device_id bt3c_ids[] = {
 	PCMCIA_DEVICE_PROD_ID13("3COM", "Bluetooth PC Card", 0xefce0a31, 0xd4ce9b02),
 	PCMCIA_DEVICE_NULL
 };
diff -ru final2/drivers/bluetooth/btmrvl_debugfs.c ics/drivers/bluetooth/btmrvl_debugfs.c
--- final2/drivers/bluetooth/btmrvl_debugfs.c	2014-08-29 08:16:13.240240000 +0200
+++ ics/drivers/bluetooth/btmrvl_debugfs.c	2013-04-19 11:37:14.000000000 +0200
@@ -64,8 +64,6 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
-	if (ret)
-		return ret;
 
 	priv->btmrvl_dev.hscfgcmd = result;
 
@@ -110,8 +108,6 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
-	if (ret)
-		return ret;
 
 	priv->btmrvl_dev.psmode = result;
 
@@ -151,8 +147,6 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
-	if (ret)
-		return ret;
 
 	priv->btmrvl_dev.pscmd = result;
 
@@ -197,8 +191,6 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 16, &result);
-	if (ret)
-		return ret;
 
 	priv->btmrvl_dev.gpio_gap = result;
 
@@ -238,8 +230,6 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
-	if (ret)
-		return ret;
 
 	priv->btmrvl_dev.hscmd = result;
 	if (priv->btmrvl_dev.hscmd) {
@@ -282,8 +272,6 @@
 		return -EFAULT;
 
 	ret = strict_strtol(buf, 10, &result);
-	if (ret)
-		return ret;
 
 	priv->btmrvl_dev.hsmode = result;
 
diff -ru final2/drivers/bluetooth/btuart_cs.c ics/drivers/bluetooth/btuart_cs.c
--- final2/drivers/bluetooth/btuart_cs.c	2014-08-29 08:16:13.240240000 +0200
+++ ics/drivers/bluetooth/btuart_cs.c	2013-04-19 11:37:14.000000000 +0200
@@ -689,7 +689,7 @@
 	pcmcia_disable_device(link);
 }
 
-static const struct pcmcia_device_id btuart_ids[] = {
+static struct pcmcia_device_id btuart_ids[] = {
 	/* don't use this driver. Use serial_cs + hci_uart instead */
 	PCMCIA_DEVICE_NULL
 };
diff -ru final2/drivers/bluetooth/btusb.c ics/drivers/bluetooth/btusb.c
--- final2/drivers/bluetooth/btusb.c	2014-08-29 08:16:13.240240000 +0200
+++ ics/drivers/bluetooth/btusb.c	2013-04-19 11:37:14.000000000 +0200
@@ -436,7 +436,7 @@
 	}
 }
 
-static inline void __fill_isoc_descriptor(struct urb *urb, int len, int mtu)
+static void inline __fill_isoc_descriptor(struct urb *urb, int len, int mtu)
 {
 	int i, offset = 0;
 
@@ -784,7 +784,7 @@
 	}
 }
 
-static inline int __set_isoc_interface(struct hci_dev *hdev, int altsetting)
+static int inline __set_isoc_interface(struct hci_dev *hdev, int altsetting)
 {
 	struct btusb_data *data = hdev->driver_data;
 	struct usb_interface *intf = data->isoc;
diff -ru final2/drivers/bluetooth/dtl1_cs.c ics/drivers/bluetooth/dtl1_cs.c
--- final2/drivers/bluetooth/dtl1_cs.c	2014-08-29 08:16:13.244240000 +0200
+++ ics/drivers/bluetooth/dtl1_cs.c	2013-04-19 11:37:14.000000000 +0200
@@ -636,7 +636,7 @@
 }
 
 
-static const struct pcmcia_device_id dtl1_ids[] = {
+static struct pcmcia_device_id dtl1_ids[] = {
 	PCMCIA_DEVICE_PROD_ID12("Nokia Mobile Phones", "DTL-1", 0xe1bfdd64, 0xe168480d),
 	PCMCIA_DEVICE_PROD_ID12("Nokia Mobile Phones", "DTL-4", 0xe1bfdd64, 0x9102bc82),
 	PCMCIA_DEVICE_PROD_ID12("Socket", "CF", 0xb38bcc2e, 0x44ebf863),
diff -ru final2/drivers/bluetooth/hci_ldisc.c ics/drivers/bluetooth/hci_ldisc.c
--- final2/drivers/bluetooth/hci_ldisc.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/bluetooth/hci_ldisc.c	2013-04-19 11:37:14.000000000 +0200
@@ -129,16 +129,13 @@
 		return 0;
 	}
 
+	BT_DBG("");
+
 restart:
 	clear_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);
 
 	while ((skb = hci_uart_dequeue(hu))) {
 		int len;
-/* Samsung Bluetooth Feature.2012.01.19
- * Add wake_peer uart operation which is called before starting UART TX
- */
-		if (hdev->wake_peer)
-			hdev->wake_peer(hdev);
 
 		set_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
 		len = tty->ops->write(tty, skb->data, skb->len);
@@ -362,23 +359,18 @@
  */
 static void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data, char *flags, int count)
 {
+	int ret;
 	struct hci_uart *hu = (void *)tty->disc_data;
 
 	if (!hu || tty != hu->tty)
 		return;
 
-#ifdef CONFIG_BT_CSR_7820
-	if (hu->hdev == NULL) {
-		BT_ERR("hci_uart_tty_receive : hu->hdev is null");
-		return;
-	}
-#endif
-
 	if (!test_bit(HCI_UART_PROTO_SET, &hu->flags))
 		return;
 
 	spin_lock(&hu->rx_lock);
-	hu->proto->recv(hu, (void *) data, count);
+	ret = hu->proto->recv(hu, (void *) data, count);
+	if (ret > 0)
 		hu->hdev->stat.byte_rx += count;
 	spin_unlock(&hu->rx_lock);
 
@@ -478,11 +470,18 @@
 
 	switch (cmd) {
 	case HCIUARTSETPROTO:
-		if (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {
+		if (!test_and_set_bit(HCI_UART_PROTO_SET_IN_PROGRESS,
+			&hu->flags) && !test_bit(HCI_UART_PROTO_SET,
+				&hu->flags)) {
 			err = hci_uart_set_proto(hu, arg);
 			if (err) {
-				clear_bit(HCI_UART_PROTO_SET, &hu->flags);
+				clear_bit(HCI_UART_PROTO_SET_IN_PROGRESS,
+						&hu->flags);
 				return err;
+			} else {
+				set_bit(HCI_UART_PROTO_SET, &hu->flags);
+				clear_bit(HCI_UART_PROTO_SET_IN_PROGRESS,
+						&hu->flags);
 			}
 		} else
 			return -EBUSY;
@@ -518,141 +517,16 @@
 /*
  * We don't provide read/write/poll interface for user space.
  */
-struct hci_uart_hook {
-	unsigned int len;
-	unsigned char *head;
-	unsigned char data[HCI_MAX_EVENT_SIZE];
-};
-
-static struct hci_uart_hook *hook;
-static DECLARE_WAIT_QUEUE_HEAD(read_wait);
-
-void hci_uart_tty_read_hook(struct sk_buff *skb)
-{
-	if (!hook) {
-		BT_DBG("%s: hooking wasn't requested, skip it", __func__);
-		goto hci_uart_tty_read_hook_exit;
-	}
-
-	if (bt_cb(skb)->pkt_type != HCI_EVENT_PKT) {
-		BT_DBG("%s: Packet type is %d, skip it",
-			__func__, bt_cb(skb)->pkt_type);
-		goto hci_uart_tty_read_hook_exit;
-	}
-
-	BT_DBG("%s: Received len = %d", __func__, skb->len);
-	/* [SEL_BLUETOOTH_SAURABH] P120613-1618 CHANGES START */
-	if (skb->len >= sizeof(hook->data)) {
-		BT_DBG("Packet size exceeds max len, skip it");
-		goto hci_uart_tty_read_hook_exit;
-	}
-
-	memcpy(hook->data, &bt_cb(skb)->pkt_type, 1);
-	skb_copy_from_linear_data(skb, &hook->data[1], skb->len);
-	hook->len = skb->len + 1;
-
-hci_uart_tty_read_hook_exit:
-	wake_up_interruptible(&read_wait);
-}
-EXPORT_SYMBOL(hci_uart_tty_read_hook);
-
-static int hci_uart_tty_access_allowed(void)
-{
-	char name[TASK_COMM_LEN];
-	get_task_comm(name, current_thread_info()->task);
-	BT_DBG("%s: %s", __func__, name);
-	if (strcmp(name, "brcm_poke_helpe")) {
-		BT_ERR("%s isn't allowed", name);
-		return -EACCES;
-	}
-
-	return 0;
-}
-
 static ssize_t hci_uart_tty_read(struct tty_struct *tty, struct file *file,
 					unsigned char __user *buf, size_t nr)
 {
-	struct hci_uart *hu = (void *) tty->disc_data;
-	struct hci_dev *hdev = hu->hdev;
-	int ret = 0, count;
-
-	BT_DBG("%s: hu = 0x%p hci_dev = 0x%p, nr = %d", __func__, hu, hdev, nr);
-
-	ret = hci_uart_tty_access_allowed();
-	if (ret < 0)
-		return ret;
-
-	if (!hook)
-		return -ENOMEM;
-
-	if (!hook->len)
-		interruptible_sleep_on_timeout(&read_wait, 3 * HZ);
-
-	if (!hook->len) {
-		BT_INFO("No data to read");
-	} else {
-		count = nr > hook->len ? hook->len : nr;
-
-		ret = copy_to_user(buf, hook->head, count);
-
-		hook->len -= (count - ret);
-			hook->head += (count - ret);
-
-		ret = count - ret;
-	}
-
-	if (!hook->len) {
-		BT_DBG("%s: free hook", __func__);
-		kfree(hook);
-		hook = NULL;
-	}
-
-	BT_DBG("%s: ret = %d", __func__, ret);
-
-	return ret;
+	return 0;
 }
 
 static ssize_t hci_uart_tty_write(struct tty_struct *tty, struct file *file,
 					const unsigned char *data, size_t count)
 {
-	struct hci_uart *hu = (void *) tty->disc_data;
-	struct hci_dev *hdev = hu->hdev;
-	int ret;
-
-	BT_DBG("%s: hu = 0x%p, hci_dev = 0x%p", __func__, hu, hdev);
-
-	ret = hci_uart_tty_access_allowed();
-	if (ret < 0)
-		return ret;
-
-	if (!hdev)
-		return -ENODEV;
-
-	if (!hook)
-		hook = kzalloc(sizeof(*hook), GFP_KERNEL);
-	else {
-		/* Cuase brcm_poke_helper's read/write is serialized,
-		* it's almost safe to init hook data here
-		*/
-		BT_INFO("hook data still remains");
-		memset(hook, 0, sizeof(*hook));
-	}
-
-	if (!hook)
-		return -ENOMEM;
-
-	hook->head = hook->data;
-
-	hci_uart_flush(hdev);
-
-	if (hdev->wake_peer)
-		hdev->wake_peer(hdev);
-
-	ret = tty->ops->write(tty, data, count);
-
-	BT_DBG("%s: ret = %d", __func__, ret);
-
-	return ret;
+	return 0;
 }
 
 static unsigned int hci_uart_tty_poll(struct tty_struct *tty,
diff -ru final2/drivers/bluetooth/hci_ll.c ics/drivers/bluetooth/hci_ll.c
--- final2/drivers/bluetooth/hci_ll.c	2014-08-29 08:16:13.244240000 +0200
+++ ics/drivers/bluetooth/hci_ll.c	2013-04-19 11:37:14.000000000 +0200
@@ -207,7 +207,7 @@
 		/*
 		 * This state means that both the host and the BRF chip
 		 * have simultaneously sent a wake-up-indication packet.
-		 * Traditionally, in this case, receiving a wake-up-indication
+		 * Traditionaly, in this case, receiving a wake-up-indication
 		 * was enough and an additional wake-up-ack wasn't needed.
 		 * This has changed with the BRF6350, which does require an
 		 * explicit wake-up-ack. Other BRF versions, which do not
diff -ru final2/drivers/bluetooth/hci_uart.h ics/drivers/bluetooth/hci_uart.h
--- final2/drivers/bluetooth/hci_uart.h	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/bluetooth/hci_uart.h	2013-04-19 11:37:14.000000000 +0200
@@ -75,6 +75,7 @@
 
 /* HCI_UART proto flag bits */
 #define HCI_UART_PROTO_SET			0
+#define HCI_UART_PROTO_SET_IN_PROGRESS		1
 
 /* TX states  */
 #define HCI_UART_SENDING	1
diff -ru final2/drivers/cpufreq/cpufreq.c ics/drivers/cpufreq/cpufreq.c
--- final2/drivers/cpufreq/cpufreq.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/cpufreq/cpufreq.c	2013-04-19 11:37:14.000000000 +0200
@@ -432,29 +432,7 @@
 }
 
 store_one(scaling_min_freq, min);
-#ifdef CONFIG_SEC_DVFS
-static ssize_t store_scaling_max_freq
-(struct cpufreq_policy *policy, const char *buf, size_t count)
-{
-	unsigned int ret = -EINVAL;
-	unsigned int value = 0;
-
-	ret = sscanf(buf, "%u", &value);
-	if (ret != 1)
-		return -EINVAL;
-
-	if (policy->cpu == BOOT_CPU) {
-		if (value >= MAX_FREQ_LIMIT)
-			set_freq_limit(DVFS_THERMALD_ID, -1);
-		else if (value >= MIN_FREQ_LIMIT)
-			set_freq_limit(DVFS_THERMALD_ID, value);
-	}
-
-	return count;
-}
-#else
 store_one(scaling_max_freq, max);
-#endif
 
 /**
  * show_cpuinfo_cur_freq - current CPU frequency as detected by hardware
@@ -1837,31 +1815,6 @@
 		case CPU_ONLINE:
 		case CPU_ONLINE_FROZEN:
 			cpufreq_add_dev(sys_dev);
-#ifdef CONFIG_SEC_DVFS
-			if (cpu == NON_BOOT_CPU) {
-#ifndef CONFIG_SEC_DVFS_UNI
-				unsigned int cur, min, max;
-
-				/* get current freq & update now */
-				min = get_min_lock();
-				max = get_max_lock();
-				cur = cpufreq_quick_get(cpu);
-				if (cur) {
-					struct cpufreq_policy policy;
-					policy.cpu = cpu;
-
-					if (min && cur < min)
-						cpufreq_driver_target(&policy,
-						min, CPUFREQ_RELATION_H);
-					else if (max && cur > max)
-						cpufreq_driver_target(&policy,
-						max, CPUFREQ_RELATION_L);
-				}
-#else
-				set_freq_limit(DVFS_UNICPU_ID, -1);
-#endif
-			}
-#endif
 			break;
 		case CPU_DOWN_PREPARE:
 		case CPU_DOWN_PREPARE_FROZEN:
diff -ru final2/drivers/cpufreq/cpufreq_ondemand.c ics/drivers/cpufreq/cpufreq_ondemand.c
--- final2/drivers/cpufreq/cpufreq_ondemand.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/cpufreq/cpufreq_ondemand.c	2013-04-19 11:37:14.000000000 +0200
@@ -897,10 +897,8 @@
 				    latency * LATENCY_MULTIPLIER);
 			dbs_tuners_ins.io_is_busy = should_io_be_busy();
 		}
-#ifndef CONFIG_SEC_DVFS
 		if (!cpu)
 			rc = input_register_handler(&dbs_input_handler);
-#endif
 		mutex_unlock(&dbs_mutex);
 
 		mutex_init(&this_dbs_info->timer_mutex);
@@ -921,10 +919,8 @@
 		/* If device is being removed, policy is no longer
 		 * valid. */
 		this_dbs_info->cur_policy = NULL;
-#ifndef CONFIG_SEC_DVFS
 		if (!cpu)
 			input_unregister_handler(&dbs_input_handler);
-#endif
 		mutex_unlock(&dbs_mutex);
 		if (!dbs_enable)
 			sysfs_remove_group(cpufreq_global_kobject,
diff -ru final2/drivers/cpufreq/Kconfig ics/drivers/cpufreq/Kconfig
--- final2/drivers/cpufreq/Kconfig	2014-08-29 08:16:13.324240000 +0200
+++ ics/drivers/cpufreq/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -206,11 +206,6 @@
 
 	  If in doubt, say N.
 
-config SEC_DVFS
-	bool "DVFS job"
-	default n
-	depends on CPU_FREQ
-
 menu "x86 CPU frequency scaling drivers"
 depends on X86
 source "drivers/cpufreq/Kconfig.x86"
Nur in final2/drivers: dpram.
Nur in final2/drivers: exfat.
diff -ru final2/drivers/gpu/msm/adreno.c ics/drivers/gpu/msm/adreno.c
--- final2/drivers/gpu/msm/adreno.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/gpu/msm/adreno.c	2013-04-19 11:37:14.000000000 +0200
@@ -451,8 +451,6 @@
 	int status = -EINVAL;
 
 	device = (struct kgsl_device *)pdev->id_entry->driver_data;
-	if (device == NULL)
-		return status;
 	adreno_dev = ADRENO_DEVICE(device);
 	device->parentdev = &pdev->dev;
 
@@ -568,17 +566,13 @@
 
 	if (cpu_is_msm8960() || cpu_is_msm8930())
 		adreno_regwrite(device, REG_RBBM_PM_OVERRIDE1, 0x200);
-	else if (adreno_is_a200(adreno_dev))
-		adreno_regwrite(device, REG_RBBM_PM_OVERRIDE1, 0xFDC001E0);
 	else
 		adreno_regwrite(device, REG_RBBM_PM_OVERRIDE1, 0);
 
-	if (adreno_is_a22x(adreno_dev))
- 		adreno_regwrite(device, REG_RBBM_PM_OVERRIDE2, 0x80);
-	else if (adreno_is_a200(adreno_dev))
-	        adreno_regwrite(device, REG_RBBM_PM_OVERRIDE2, 0x38);
+	if (!adreno_is_a22x(adreno_dev))
+		adreno_regwrite(device, REG_RBBM_PM_OVERRIDE2, 0);
 	else
-		adreno_regwrite(device, REG_RBBM_PM_OVERRIDE2, 0x0);
+		adreno_regwrite(device, REG_RBBM_PM_OVERRIDE2, 0x80);
 
 	kgsl_sharedmem_set(&device->memstore, 0, 0, device->memstore.size);
 
@@ -782,7 +776,6 @@
 		kgsl_device_snapshot(device, 1);
 
 		result = adreno_recover_hang(device);
-		BUG_ON(true);
 		if (result)
 			kgsl_pwrctrl_set_state(device, KGSL_STATE_HUNG);
 		else
diff -ru final2/drivers/gpu/msm/kgsl_pwrctrl.c ics/drivers/gpu/msm/kgsl_pwrctrl.c
--- final2/drivers/gpu/msm/kgsl_pwrctrl.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/gpu/msm/kgsl_pwrctrl.c	2013-04-19 11:37:14.000000000 +0200
@@ -339,11 +339,9 @@
 {
 	struct kgsl_pwrctrl *pwr = &device->pwrctrl;
 	int i = 0;
-
 	if (state == KGSL_PWRFLAGS_OFF) {
 		if (test_and_clear_bit(KGSL_PWRFLAGS_CLK_ON,
 			&pwr->power_flags)) {
-
 			trace_kgsl_clk(device, state);
 			for (i = KGSL_MAX_CLKS - 1; i > 0; i--)
 				if (pwr->grp_clks[i])
@@ -371,7 +369,6 @@
 				if (pwr->grp_clks[i])
 					clk_enable(pwr->grp_clks[i]);
 			kgsl_pwrctrl_busy_time(device, false);
-
 		}
 	}
 }
diff -ru final2/drivers/hid/hid-apple.c ics/drivers/hid/hid-apple.c
--- final2/drivers/hid/hid-apple.c	2014-08-29 08:16:13.664240000 +0200
+++ ics/drivers/hid/hid-apple.c	2013-04-19 11:37:14.000000000 +0200
@@ -417,22 +417,11 @@
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_JIS),
 		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN |
 			APPLE_RDESC_JIS },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_ALU_REVB_ANSI),
-		.driver_data = APPLE_HAS_FN },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_ISO),
-		.driver_data = APPLE_HAS_FN | APPLE_ISO_KEYBOARD },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_JIS),
-		.driver_data = APPLE_HAS_FN },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ANSI),
 		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ISO),
 		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN |
 			APPLE_ISO_KEYBOARD },
-	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO),
-		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN |
-			APPLE_ISO_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_JIS),
 		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN |
 			APPLE_RDESC_JIS },
@@ -498,33 +487,6 @@
 		.driver_data = APPLE_HAS_FN | APPLE_ISO_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_JIS),
 		.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI),
-		.driver_data = APPLE_HAS_FN },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6_ISO),
-		.driver_data = APPLE_HAS_FN | APPLE_ISO_KEYBOARD },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6_JIS),
-		.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI),
-		.driver_data = APPLE_HAS_FN },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO),
-		.driver_data = APPLE_HAS_FN | APPLE_ISO_KEYBOARD },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS),
-		.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI),
-		.driver_data = APPLE_HAS_FN },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO),
-		.driver_data = APPLE_HAS_FN | APPLE_ISO_KEYBOARD },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS),
-		.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI),
 		.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO),
diff -ru final2/drivers/hid/hid-core.c ics/drivers/hid/hid-core.c
--- final2/drivers/hid/hid-core.c	2014-08-29 08:16:13.664240000 +0200
+++ ics/drivers/hid/hid-core.c	2013-04-19 11:37:14.000000000 +0200
@@ -1265,11 +1265,9 @@
 		hid_warn(hdev,
 			 "can't create sysfs report descriptor attribute err: %d\n", ret);
 
-	/* [Security Log]
 	hid_info(hdev, "%s: %s HID v%x.%02x %s [%s] on %s\n",
 		 buf, bus, hdev->version >> 8, hdev->version & 0xff,
 		 type, hdev->name, hdev->phys);
-	*/
 
 	return 0;
 }
@@ -1342,38 +1340,9 @@
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ISO) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_JIS) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6_ISO) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6_JIS) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_ALU_REVB_ANSI) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_ALU_REVB_ISO) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_ALU_REVB_JIS) },
-	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI) },
-	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO) },
-	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS) },
-	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO) },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI) },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO) },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUS, USB_DEVICE_ID_ASUS_T91MT) },
@@ -1426,7 +1395,6 @@
 	{ HID_USB_DEVICE(USB_VENDOR_ID_KYE, USB_DEVICE_ID_KYE_ERGO_525V) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LABTEC, USB_DEVICE_ID_LABTEC_WIRELESS_KEYBOARD) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LCPOWER, USB_DEVICE_ID_LCPOWER_LC1000 ) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_LG, USB_DEVICE_ID_LG_MULTITOUCH) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_MX3000_RECEIVER) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER_2) },
@@ -1497,8 +1465,6 @@
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ROCCAT, USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },
-	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SAMSUNG_ELECTRONICS,
-		USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SKYCABLE, USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_PS3_CONTROLLER) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SONY, USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER) },
@@ -1741,8 +1707,8 @@
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ESSENTIAL_REALITY, USB_DEVICE_ID_ESSENTIAL_REALITY_P5) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ETT, USB_DEVICE_ID_TC5UH) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ETT, USB_DEVICE_ID_TC4UM) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0001) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0002) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0003) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_GENERAL_TOUCH, 0x0004) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_4_PHIDGETSERVO_30) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_GLAB, USB_DEVICE_ID_1_PHIDGETSERVO_30) },
@@ -1917,12 +1883,6 @@
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ISO) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_JIS) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO) },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
-		USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },
 	{ }
diff -ru final2/drivers/hid/hid-ids.h ics/drivers/hid/hid-ids.h
--- final2/drivers/hid/hid-ids.h	2014-08-29 08:16:13.664240000 +0200
+++ ics/drivers/hid/hid-ids.h	2013-04-19 11:37:14.000000000 +0200
@@ -109,22 +109,9 @@
 #define USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI	0x0245
 #define USB_DEVICE_ID_APPLE_WELLSPRING5_ISO	0x0246
 #define USB_DEVICE_ID_APPLE_WELLSPRING5_JIS	0x0247
-#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI	0x0249
-#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO	0x024a
-#define USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS	0x024b
-#define USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI	0x024c
-#define USB_DEVICE_ID_APPLE_WELLSPRING6_ISO	0x024d
-#define USB_DEVICE_ID_APPLE_WELLSPRING6_JIS	0x024e
-#define USB_DEVICE_ID_APPLE_ALU_REVB_ANSI	0x024f
-#define USB_DEVICE_ID_APPLE_ALU_REVB_ISO	0x0250
-#define USB_DEVICE_ID_APPLE_ALU_REVB_JIS	0x0251
-#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI	0x0252
-#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO	0x0253
-#define USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS	0x0254
 #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI  0x0239
 #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO   0x023a
 #define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS   0x023b
-#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO   0x0256
 #define USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY	0x030a
 #define USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY	0x030b
 #define USB_DEVICE_ID_APPLE_ATV_IRCONTROL	0x8241
@@ -266,7 +253,7 @@
 #define USB_DEVICE_ID_GAMERON_DUAL_PCS_ADAPTOR	0x0002
 
 #define USB_VENDOR_ID_GENERAL_TOUCH	0x0dfc
-#define USB_DEVICE_ID_GENERAL_TOUCH_WIN7_TWOFINGERS 0x0003
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN7_TWOFINGERS 0x0001
 
 #define USB_VENDOR_ID_GLAB		0x06c2
 #define USB_DEVICE_ID_4_PHIDGETSERVO_30	0x0038
@@ -287,7 +274,6 @@
 #define USB_DEVICE_ID_PENPOWER		0x00f4
 
 #define USB_VENDOR_ID_GREENASIA		0x0e8f
-#define USB_DEVICE_ID_GREENASIA_DUAL_USB_JOYPAD	0x3013
 
 #define USB_VENDOR_ID_GRETAGMACBETH	0x0971
 #define USB_DEVICE_ID_GRETAGMACBETH_HUEY	0x2005
@@ -430,9 +416,6 @@
 #define USB_DEVICE_ID_LD_HYBRID		0x2090
 #define USB_DEVICE_ID_LD_HEATCONTROL	0x20A0
 
-#define USB_VENDOR_ID_LG		0x1fd2
-#define USB_DEVICE_ID_LG_MULTITOUCH	0x0064
-
 #define USB_VENDOR_ID_LOGITECH		0x046d
 #define USB_DEVICE_ID_LOGITECH_RECEIVER	0xc101
 #define USB_DEVICE_ID_LOGITECH_HARMONY_FIRST  0xc110
@@ -582,9 +565,7 @@
 #define USB_DEVICE_ID_SAITEK_RUMBLEPAD	0xff17
 
 #define USB_VENDOR_ID_SAMSUNG		0x0419
-#define USB_VENDOR_ID_SAMSUNG_ELECTRONICS	0x04e8
 #define USB_DEVICE_ID_SAMSUNG_IR_REMOTE	0x0001
-#define USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD	0x7021
 #define USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE	0x0600
 
 #define USB_VENDOR_ID_SIGMA_MICRO	0x1c4f
diff -ru final2/drivers/hid/hid-multitouch.c ics/drivers/hid/hid-multitouch.c
--- final2/drivers/hid/hid-multitouch.c	2014-08-29 08:16:13.712240000 +0200
+++ ics/drivers/hid/hid-multitouch.c	2013-04-19 11:37:14.000000000 +0200
@@ -682,11 +682,6 @@
 		HID_USB_DEVICE(USB_VENDOR_ID_IRTOUCHSYSTEMS,
 			USB_DEVICE_ID_IRTOUCH_INFRARED_USB) },
 
-	/* LG Display panels */
-	{ .driver_data = MT_CLS_DEFAULT,
-		HID_USB_DEVICE(USB_VENDOR_ID_LG,
-			USB_DEVICE_ID_LG_MULTITOUCH) },
-
 	/* Lumio panels */
 	{ .driver_data = MT_CLS_CONFIDENCE_MINUS_ONE,
 		HID_USB_DEVICE(USB_VENDOR_ID_LUMIO,
diff -ru final2/drivers/hid/hid-samsung.c ics/drivers/hid/hid-samsung.c
--- final2/drivers/hid/hid-samsung.c	2014-08-29 08:16:13.712240000 +0200
+++ ics/drivers/hid/hid-samsung.c	2013-04-19 11:37:14.000000000 +0200
@@ -131,93 +131,6 @@
 	return 1;
 }
 
-static int samsung_kbd_input_mapping(struct hid_device *hdev,
-	struct hid_input *hi, struct hid_field *field, struct hid_usage *usage,
-	unsigned long **bit, int *max)
-{
-	if (!(HID_UP_CONSUMER == (usage->hid & HID_USAGE_PAGE) ||
-			HID_UP_KEYBOARD == (usage->hid & HID_USAGE_PAGE)))
-		return 0;
-
-	dbg_hid("samsung wireless keyboard input mapping event [0x%x]\n",
-		usage->hid & HID_USAGE);
-
-	if (HID_UP_KEYBOARD == (usage->hid & HID_USAGE_PAGE)) {
-		switch (usage->hid & HID_USAGE) {
-		set_bit(EV_REP, hi->input->evbit);
-		/* Only for UK keyboard */
-		/* key found */
-		case 0x32:
-			samsung_kbd_mouse_map_key_clear(KEY_KBDILLUMTOGGLE);
-			break;
-		case 0x64:
-			samsung_kbd_mouse_map_key_clear(KEY_BACKSLASH);
-			break;
-		default:
-			return 0;
-		}
-	}
-
-	if (HID_UP_CONSUMER == (usage->hid & HID_USAGE_PAGE)) {
-		switch (usage->hid & HID_USAGE) {
-		/* report 2 */
-		/* MENU */
-		case 0x040:
-			samsung_kbd_mouse_map_key_clear(KEY_MENU);
-			break;
-		case 0x18a:
-			samsung_kbd_mouse_map_key_clear(KEY_MAIL);
-			break;
-		case 0x196:
-			samsung_kbd_mouse_map_key_clear(KEY_WWW);
-			break;
-		case 0x19e:
-			samsung_kbd_mouse_map_key_clear(KEY_SCREENLOCK);
-			break;
-		case 0x221:
-			samsung_kbd_mouse_map_key_clear(KEY_SEARCH);
-			break;
-		case 0x223:
-			samsung_kbd_mouse_map_key_clear(KEY_HOMEPAGE);
-			break;
-		/* RECENTAPPS */
-		case 0x301:
-			samsung_kbd_mouse_map_key_clear(BTN_TRIGGER_HAPPY1);
-			break;
-		/* APPLICATION */
-		case 0x302:
-			samsung_kbd_mouse_map_key_clear(BTN_TRIGGER_HAPPY2);
-			break;
-		/* Voice search */
-		case 0x305:
-			samsung_kbd_mouse_map_key_clear(BTN_TRIGGER_HAPPY4);
-			break;
-		/* QPANEL on/off */
-		case 0x306:
-			samsung_kbd_mouse_map_key_clear(BTN_TRIGGER_HAPPY5);
-			break;
-		/* SIP on/off */
-		case 0x307:
-			samsung_kbd_mouse_map_key_clear(BTN_TRIGGER_HAPPY3);
-			break;
-		/* LANG */
-		case 0x308:
-			samsung_kbd_mouse_map_key_clear(KEY_LANGUAGE);
-			break;
-		case 0x30a:
-			samsung_kbd_mouse_map_key_clear(KEY_BRIGHTNESSDOWN);
-			break;
-		case 0x30b:
-			samsung_kbd_mouse_map_key_clear(KEY_BRIGHTNESSUP);
-			break;
-		default:
-			return 0;
-		}
-	}
-
-	return 1;
-}
-
 static __u8 *samsung_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 	unsigned int *rsize)
 {
@@ -235,9 +148,6 @@
 	if (USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE == hdev->product)
 		ret = samsung_kbd_mouse_input_mapping(hdev,
 			hi, field, usage, bit, max);
-	else if (USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD == hdev->product)
-		ret = samsung_kbd_input_mapping(hdev,
-			hi, field, usage, bit, max);
 
 	return ret;
 }
@@ -276,8 +186,6 @@
 static const struct hid_device_id samsung_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },
-	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_SAMSUNG_ELECTRONICS
-	, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD) },
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, samsung_devices);
diff -ru final2/drivers/hid/Kconfig ics/drivers/hid/Kconfig
--- final2/drivers/hid/Kconfig	2014-08-29 08:16:13.664240000 +0200
+++ ics/drivers/hid/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -69,7 +69,7 @@
 	Say Y here if you want to enable support for ACRUX game controllers.
 
 config HID_ACRUX_FF
-	bool "ACRUX force feedback support"
+	tristate "ACRUX force feedback support"
 	depends on HID_ACRUX
 	select INPUT_FF_MEMLESS
 	---help---
@@ -314,7 +314,6 @@
 	  - Hanvon dual touch panels
 	  - Ilitek dual touch panels
 	  - IrTouch Infrared USB panels
-	  - LG Display panels (Dell ST2220Tc)
 	  - Lumio CrystalTouch panels
 	  - MosArt dual-touch panels
 	  - PenMount dual touch panels
diff -ru final2/drivers/input/input.c ics/drivers/input/input.c
--- final2/drivers/input/input.c	2014-08-29 08:16:14.032240000 +0200
+++ ics/drivers/input/input.c	2013-04-19 11:37:14.000000000 +0200
@@ -901,16 +901,6 @@
 	if (!id)
 		return -ENODEV;
 
-	if (dev->name != NULL) {
-		if ((strcmp(dev->name, "accelerometer_sensor") == 0)
-			&& (strcmp(handler->name, "cpufreq_ond") == 0))
-			return -ENODEV;
-
-		if ((strcmp(dev->name, "alps") == 0)
-			&& (strcmp(handler->name, "cpufreq_ond") == 0))
-			return -ENODEV;
-	}
-
 	error = handler->connect(handler, dev, id);
 	if (error && error != -ENODEV)
 		pr_err("failed to attach handler %s to device %s, error: %d\n",
diff -ru final2/drivers/input/keyboard/gpio_keys.c ics/drivers/input/keyboard/gpio_keys.c
--- final2/drivers/input/keyboard/gpio_keys.c	2014-08-29 08:16:14.052240000 +0200
+++ ics/drivers/input/keyboard/gpio_keys.c	2013-04-19 11:37:14.000000000 +0200
@@ -25,12 +25,6 @@
 #include <linux/gpio_keys.h>
 #include <linux/workqueue.h>
 #include <linux/gpio.h>
-#include <linux/sec_debug.h>
-
-#if !defined(CONFIG_MACH_KYLE)
-#include "../../dpram/dpram.h"
-#endif
-
 
 struct gpio_button_data {
 	struct gpio_keys_button *button;
@@ -39,7 +33,6 @@
 	struct work_struct work;
 	int timer_debounce;	/* in msecs */
 	bool disabled;
-	bool key_state;
 };
 
 struct gpio_keys_drvdata {
@@ -312,68 +305,11 @@
 		   gpio_keys_show_disabled_switches,
 		   gpio_keys_store_disabled_switches);
 
-static ssize_t key_pressed_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct gpio_keys_drvdata *ddata = platform_get_drvdata(pdev);
-	int i;
-	int keystate = 0;
-
-	for (i = 0; i < ddata->n_buttons; i++) {
-		struct gpio_button_data *bdata = &ddata->data[i];
-		keystate |= bdata->key_state;
-	}
-
-	if (keystate)
-		snprintf(buf, sizeof(buf), "PRESS");
-	else
-		snprintf(buf, sizeof(buf), "RELEASE");
-
-	return strnlen(buf, sizeof(buf));
-}
-
-/* the volume keys can be the wakeup keys in special case */
-static ssize_t wakeup_enable(struct device *dev,
-	struct device_attribute *attr, char *buf, size_t count)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct gpio_keys_drvdata *ddata = platform_get_drvdata(pdev);
-
-	int n_events = get_n_events_by_type(EV_KEY);
-	unsigned long *bits;
-	ssize_t error;
-	int i;
-
-	bits = kcalloc(BITS_TO_LONGS(n_events), sizeof(*bits), GFP_KERNEL);
-	if (!bits)
-		return -ENOMEM;
-
-	error = bitmap_parselist(buf, bits, n_events);
-	if (error)
-		goto out;
-
-	for (i = 0; i < ddata->n_buttons; i++) {
-		struct gpio_button_data *button = &ddata->data[i];
-		if (test_bit(button->button->code, bits))
-			button->button->wakeup = 1;
-		else
-			button->button->wakeup = 0;
-	}
-
-out:
-	kfree(bits);
-	return count;
-}
-static DEVICE_ATTR(key_pressed, 0664, key_pressed_show, NULL);
-static DEVICE_ATTR(wakeup_keys, S_IWUSR, NULL, wakeup_enable);
 static struct attribute *gpio_keys_attrs[] = {
 	&dev_attr_keys.attr,
 	&dev_attr_switches.attr,
-	&dev_attr_key_pressed.attr,
 	&dev_attr_disabled_keys.attr,
 	&dev_attr_disabled_switches.attr,
-	&dev_attr_wakeup_keys.attr,
 	NULL,
 };
 
@@ -388,23 +324,13 @@
 	unsigned int type = button->type ?: EV_KEY;
 	int state = (gpio_get_value_cansleep(button->gpio) ? 1 : 0) ^ button->active_low;
 
-	printk(KERN_INFO"[KEY] key: %s gpio_keys_report_event state = %d\n",
-		button->desc, state);
-	bdata->key_state = !!state;
+	if (type == EV_ABS) {
+		if (state)
+			input_event(input, type, button->code, button->value);
+	} else {
 		input_event(input, type, button->code, !!state);
+	}
 	input_sync(input);
-#if defined(CONFIG_MACH_TREBON) || defined(CONFIG_MACH_GEIM) \
-	 || defined(CONFIG_MACH_JENA) || defined(CONFIG_MACH_AMAZING) \
-	 || defined(CONFIG_MACH_AMAZING_CDMA) \
-	 || defined(CONFIG_MACH_KYLE)
-
-
-#if defined(CONFIG_SEC_DEBUG) && \
-	(defined(CONFIG_SEC_DUMP) || defined(CONFIG_DPRAM))
-	if (dump_enable_flag != 0)
-		sec_check_crash_key(button->code, state);
-#endif
-#endif
 }
 
 static void gpio_keys_work_func(struct work_struct *work)
diff -ru final2/drivers/input/misc/gpio_event.c ics/drivers/input/misc/gpio_event.c
--- final2/drivers/input/misc/gpio_event.c	2014-08-29 08:16:14.056240000 +0200
+++ ics/drivers/input/misc/gpio_event.c	2013-04-19 11:37:14.000000000 +0200
@@ -21,30 +21,6 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-static unsigned int wakeup_keys_status;
-
-int gpio_event_get_wakeup_keys_status(void)
-{
-	return wakeup_keys_status;
-}
-
-static size_t wakeup_keys_store(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t count)
-{
-	int err;
-	unsigned int base = 0;
-
-	err = kstrtouint(buf, 0, &base);
-	wakeup_keys_status = base;
-
-	return count;
-}
-
-static DEVICE_ATTR(wakeup_keys, 0664, NULL, wakeup_keys_store);
-#endif
-
 struct gpio_event {
 	struct gpio_event_input_devs *input_devs;
 	const struct gpio_event_platform_data *info;
@@ -143,24 +119,6 @@
 }
 #endif
 
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-#ifdef CONFIG_PM
-static int gpio_event_sleep(struct platform_device *pdev, pm_message_t state)
-{
-	struct gpio_event *ip = platform_get_drvdata(pdev);
-
-	return gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_SUSPEND);
-}
-
-static int gpio_event_wakeup(struct platform_device *pdev)
-{
-	struct gpio_event *ip = platform_get_drvdata(pdev);
-
-	return gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_RESUME);
-}
-#endif
-#endif
-
 static int gpio_event_probe(struct platform_device *pdev)
 {
 	int err;
@@ -234,9 +192,7 @@
 		}
 		registered++;
 	}
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-	err = device_create_file(&(pdev->dev), &dev_attr_wakeup_keys);
-#endif
+
 	return 0;
 
 err_input_register_device_failed:
@@ -274,9 +230,6 @@
 	}
 	for (i = 0; i < ip->input_devs->count; i++)
 		input_unregister_device(ip->input_devs->dev[i]);
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-	device_remove_file(&(pdev->dev), &dev_attr_wakeup_keys);
-#endif
 	kfree(ip);
 	return 0;
 }
@@ -287,13 +240,6 @@
 	.driver		= {
 		.name	= GPIO_EVENT_DEV_NAME,
 	},
-
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-#ifdef CONFIG_PM
-	.suspend	= gpio_event_sleep,
-	.resume		= gpio_event_wakeup,
-#endif
-#endif
 };
 
 static int __devinit gpio_event_init(void)
diff -ru final2/drivers/input/misc/gpio_matrix.c ics/drivers/input/misc/gpio_matrix.c
--- final2/drivers/input/misc/gpio_matrix.c	2014-08-29 08:16:14.056240000 +0200
+++ ics/drivers/input/misc/gpio_matrix.c	2013-04-19 11:37:14.000000000 +0200
@@ -20,19 +20,6 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/wakelock.h>
-#include <linux/input.h>
-#include <linux/sec_debug.h>
-#if !defined(CONFIG_MACH_KYLE)
-#include "../../dpram/dpram.h"
-#endif
-
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_TREBON) \
-						|| defined(CONFIG_MACH_JENA)
-#define VOLUMEUP_GPIO	39
-#define VOLUMEDOWN_GPIO	36
-unsigned int Volume_Up_irq;
-unsigned int Volume_Down_irq;
-#endif
 
 struct gpio_kp {
 	struct gpio_event_input_devs *input_devs;
@@ -47,26 +34,6 @@
 	unsigned int disabled_irq:1;
 	unsigned long keys_pressed[0];
 };
-static struct gpio_kp *pgpio_key;
-
-extern struct class *sec_class;
-struct device *kpd_dev;
-unsigned int sec_key_pressed;
-static ssize_t keyshort_test(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	int count;
-
-	if (sec_key_pressed) {
-		count = sprintf(buf, "PRESS\n");
-	}
-	else {
-		count = sprintf(buf, "RELEASE\n");
-	}
-	return count;
-}
-
-static DEVICE_ATTR(sec_key_pressed, 0664, keyshort_test, NULL);
-
 
 static void clear_phantom_key(struct gpio_kp *kp, int out, int in)
 {
@@ -147,38 +114,18 @@
 
 	if (pressed != test_bit(keycode, kp->input_devs->dev[dev]->key)) {
 		if (keycode == KEY_RESERVED) {
-			if (mi->flags & GPIOKPF_PRINT_UNMAPPED_KEYS){
+			if (mi->flags & GPIOKPF_PRINT_UNMAPPED_KEYS)
 				pr_info("gpiomatrix: unmapped key, %d-%d "
 					"(%d-%d) changed to %d\n",
 					out, in, mi->output_gpios[out],
 					mi->input_gpios[in], pressed);
-				}
 		} else {
-			if (mi->flags & GPIOKPF_PRINT_MAPPED_KEYS){
+			if (mi->flags & GPIOKPF_PRINT_MAPPED_KEYS)
 				pr_info("gpiomatrix: key %x, %d-%d (%d-%d) "
 					"changed to %d\n", keycode,
 					out, in, mi->output_gpios[out],
 					mi->input_gpios[in], pressed);
-				}
-
-#if defined(CONFIG_SEC_DEBUG) && \
-	(!defined(CONFIG_MACH_KYLE_CHN)) && \
-	(defined(CONFIG_SEC_DUMP) || defined(CONFIG_DPRAM))
-			if (dump_enable_flag != 0)
-				printk("[KEY] keycode: %d, %s\n", keycode, pressed ? "pressed" : "released");
-#endif
-			sec_key_pressed = pressed;
 			input_report_key(kp->input_devs->dev[dev], keycode, pressed);
-#if defined(CONFIG_MACH_TREBON) || defined(CONFIG_MACH_GEIM) \
-	|| defined(CONFIG_MACH_JENA) || defined(CONFIG_MACH_AMAZING) \
-	|| defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
-
-#if defined(CONFIG_SEC_DEBUG) && \
-	(defined(CONFIG_SEC_DUMP) || defined(CONFIG_DPRAM))
-			if (dump_enable_flag != 0)
-				sec_check_crash_key(keycode, pressed);
-#endif
-#endif
 		}
 	}
 }
@@ -337,19 +284,6 @@
 				"irq %d\n", mi->input_gpios[i], irq);
 			goto err_request_irq_failed;
 		}
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_TREBON) \
-						|| defined(CONFIG_MACH_JENA)
-		switch (mi->input_gpios[i]) {
-		case VOLUMEUP_GPIO:
-			Volume_Up_irq = irq;
-			break;
-		case VOLUMEDOWN_GPIO:
-			Volume_Down_irq = irq;
-			break;
-		default:
-			break;
-		}
-#endif
 		err = enable_irq_wake(irq);
 		if (err) {
 			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
@@ -378,49 +312,12 @@
 	int i;
 	int err;
 	int key_count;
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-	int wakeup_keys_status;
-	int irq;
-	static int irq_status = 1;
-#endif
 	struct gpio_kp *kp;
 	struct gpio_event_matrix_info *mi;
 
-#if !defined(CONFIG_MACH_KYLE) && !defined(CONFIG_MACH_AMAZING)
-	kpd_dev = device_create(sec_class, NULL, 0, NULL, "sec_key");
-	if (!kpd_dev)
-		printk("Failed to create device(sec_key)!\n");
-	
-	if (device_create_file(kpd_dev, &dev_attr_sec_key_pressed) < 0)
-		printk("Failed to create file(%s)!\n", dev_attr_sec_key_pressed.attr.name);
-#endif
-
 	mi = container_of(info, struct gpio_event_matrix_info, info);
 	if (func == GPIO_EVENT_FUNC_SUSPEND || func == GPIO_EVENT_FUNC_RESUME) {
 		/* TODO: disable scanning */
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-		wakeup_keys_status = gpio_event_get_wakeup_keys_status() & 0x01;
-
-		if (irq_status != wakeup_keys_status)
-			irq_status = wakeup_keys_status;
-		else
-			return 0;
-
-
-		for (i = 0; i < mi->ninputs; i++) {
-			irq = gpio_to_irq(mi->input_gpios[i]);
-
-			if (irq_status == 1)
-				err = enable_irq_wake(irq);
-			else
-				err = disable_irq_wake(irq);
-		}
-		/* HOME Key is wakeup source */
-		for (i = 0; i < mi->nwakeups; i++) {
-			irq = gpio_to_irq(mi->wakeup_gpios[i]);
-			err = enable_irq_wake(irq);
-		}
-#endif
 		return 0;
 	}
 
@@ -434,7 +331,7 @@
 		}
 		key_count = mi->ninputs * mi->noutputs;
 
-		pgpio_key = *data = kp = kzalloc(sizeof(*kp) + sizeof(kp->keys_pressed[0]) *
+		*data = kp = kzalloc(sizeof(*kp) + sizeof(kp->keys_pressed[0]) *
 				     BITS_TO_LONGS(key_count), GFP_KERNEL);
 		if (kp == NULL) {
 			err = -ENOMEM;
@@ -506,14 +403,6 @@
 		err = gpio_keypad_request_irqs(kp);
 		kp->use_irq = err == 0;
 
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-		kpd_dev = device_create(sec_class, NULL, 0, NULL, "sec_key");
-		if (!kpd_dev)
-			printk(KERN_WARNING "Failed to create device(sec_key)!\n");
-		if (device_create_file(kpd_dev, &dev_attr_sec_key_pressed) < 0)
-			printk(KERN_WARNING "Failed to create file(%s)!\n"
-				, dev_attr_sec_key_pressed.attr.name);
-#endif
 		pr_info("GPIO Matrix Keypad Driver: Start keypad matrix for "
 			"%s%s in %s mode\n", input_devs->dev[0]->name,
 			(input_devs->count > 1) ? "..." : "",
Nur in final2/drivers/input/touchscreen: Amazing_R00_VD08_bin.c.
diff -ru final2/drivers/input/touchscreen/Kconfig ics/drivers/input/touchscreen/Kconfig
--- final2/drivers/input/touchscreen/Kconfig	2014-08-29 08:16:14.108240000 +0200
+++ ics/drivers/input/touchscreen/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -421,51 +421,6 @@
 	help
 	  This enables support for Synaptics RMI over I2C based touchscreens(ClearPad 3000).
 
-
-config TOUCHSCREEN_ZINITIX
-	tristate "Zinitix i2c touchscreen"
-	depends on I2C
-	help
-		This enable support for Zinitix over I2C based touchscreen.
-
-config TOUCHSCREEN_ZINITIX_AMAZING
-        tristate "Zinitix i2c touchscreen"
-        depends on I2C
-        help
-                This enable support for Zinitix over I2C based touchscreen.
-config TOUCHSCREEN_ZINITIX_TREBON
-	tristate "Zinitix i2c touchscreen"
-	depends on I2C
-	help
-		This enable support for Zinitix over I2C based touchscreen.
-
-config TOUCHSCREEN_ZINITIX_GEIM
-	tristate "Zinitix i2c touchscreen"
-	depends on I2C
-	help
-		This enable support for Zinitix over I2C based touchscreen.		
-
-config TOUCHSCREEN_MELFAS_TS
-        bool "Melfas Touchscreen interface support"
-        depends on I2C
-        help
-      Say Y here to enable support for the Melfas
-          touchscreen controller.
-
-config TOUCHSCREEN_MELFAS_KYLE
-	tristate "Melfas i2c touchscreen"
-	depends on I2C
-	help
-		This enable support for Melfas over I2C based touchscreen.
-
-
-config TOUCHSCREEN_MELFAS_FIRMWARE_UPDATE
-    bool "melfas touchscreen firmware update"
-        depends on TOUCHSCREEN_MELFAS || TOUCHSCREEN_MELFAS_TS
-        help
-          Say Y here to enable the touchscreen firmware update.
-
-
 config SYNA_MULTI_TOUCH
 	tristate "Synaptics i2c touchscreen(ClearPad 3000) MutilTouch support"
 	depends on TOUCHSCREEN_SYNAPTICS_RMI4_I2C
Nur in final2/drivers/input/touchscreen: KYLE_CORE28_PR_31_VC05.c.
Nur in final2/drivers/input/touchscreen: KYLE_G1F_R00_VF01.c.
Nur in final2/drivers/input/touchscreen: KYLE_G1F_R00_VF12.c.
Nur in final2/drivers/input/touchscreen: KYLE_G1F_R00_VF13.c.
Nur in final2/drivers/input/touchscreen: KYLE_G1F_R00_VF15.c.
Nur in final2/drivers/input/touchscreen: KYLE_G1F_R00_VF19.c.
Nur in final2/drivers/input/touchscreen: KYLE_G1F_R00_VF20.c.
Nur in final2/drivers/input/touchscreen: KYLE_G1F_R00_VF21.c.
Nur in final2/drivers/input/touchscreen: KYLE_G1F_R00_VF22.c.
Nur in final2/drivers/input/touchscreen: KYLE_G2_HV_R15_FW_VA1.c.
Nur in final2/drivers/input/touchscreen: KYLE_G2_R00_V001.c.
Nur in final2/drivers/input/touchscreen: KYLE_I_R03_VA13.c.
Nur in final2/drivers/input/touchscreen: KYLE_I_R03_VA15.c.
Nur in final2/drivers/input/touchscreen: KYLE_I_R03_VA17.c.
Nur in final2/drivers/input/touchscreen: KYLE_I_R03_VA18.c.
Nur in final2/drivers/input/touchscreen: KYLE_I_R03_VA19.c.
diff -ru final2/drivers/input/touchscreen/Makefile ics/drivers/input/touchscreen/Makefile
--- final2/drivers/input/touchscreen/Makefile	2014-08-29 08:16:14.108240000 +0200
+++ ics/drivers/input/touchscreen/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -69,14 +69,3 @@
 obj-$(CONFIG_TOUCHSCREEN_MSM_LEGACY)		+= msm_touch.o
 obj-$(CONFIG_TOUCHSCREEN_CY8C_TS)	+= cy8c_ts.o
 obj-$(CONFIG_TOUCHSCREEN_CYTTSP_I2C)       += cyttsp-i2c.o
-obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4)	+= synaptics_i2c_rmi4_jena.o
-#obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4)   += ISSP/
-obj-$(CONFIG_TOUCHSCREEN_MELFAS)   += melfas_ts.o mms100_download.o
-obj-$(CONFIG_TOUCHSCREEN_ZINITIX)   += zinitix_touch.o
-obj-$(CONFIG_TOUCHSCREEN_ZINITIX_TREBON)   += zinitix_touch_trebon.o
-obj-$(CONFIG_TOUCHSCREEN_ZINITIX_AMAZING)   += zinitix_touch_amazing.o
-obj-$(CONFIG_TOUCHSCREEN_ZINITIX_GEIM)   += zinitix_touch_geim.o
-obj-$(CONFIG_TOUCHSCREEN_MELFAS_TS)        += melfas_mcs7000.o mcs7000_download.o
-obj-$(CONFIG_TOUCHSCREEN_MELFAS_KYLE)   += melfas_ts.o MMS100S_ISC_Updater_V01.o MMS100S_ISC_Updater_Customize.o
-obj-$(CONFIG_TOUCHSCREEN_MELFAS_FIRMWARE_UPDATE)        += mms100_ISC_download.o
-
Nur in final2/drivers/input/touchscreen: mcs7000_download.c.
Nur in final2/drivers/input/touchscreen: mcs7000_download.h.
Nur in final2/drivers/input/touchscreen: mcs7000_download_porting.h.
Nur in final2/drivers/input/touchscreen: melfas_mcs7000.c.
Nur in final2/drivers/input/touchscreen: melfas_ts.c.
Nur in final2/drivers/input/touchscreen: mms100_ISC_download.c.
Nur in final2/drivers/input/touchscreen: MMS100S_ISC_Updater_Customize.c.
Nur in final2/drivers/input/touchscreen: MMS100S_ISC_Updater_Customize.h.
Nur in final2/drivers/input/touchscreen: MMS100S_ISC_Updater.h.
Nur in final2/drivers/input/touchscreen: MMS100S_ISC_Updater_V01.c.
Nur in final2/drivers/input/touchscreen: mms134s_download_porting.h.
Nur in final2/drivers/input/touchscreen: MTH_SAMAZING_USA_RB11_VCF1_bin.c.
Nur in final2/drivers/input/touchscreen: MTH_SAMAZING_USA_RB11_VCF3_bin.h.
Nur in final2/drivers/input/touchscreen: MTH_SAMAZING_USA_RC20_VD04_bin.h.
Nur in final2/drivers/input/touchscreen: MTH_SAMAZING_USA_RC20_VD05_bin.h.
Nur in final2/drivers/input/touchscreen: MTH_SAMAZING_USA_RC20_VD06_bin.h.
Nur in final2/drivers/input/touchscreen: MTH_SAMAZING_USA_RC20_VD07_bin.h.
Nur in final2/drivers/input/touchscreen: zinitix_touch_amazing.c.
Nur in final2/drivers/input/touchscreen: zinitix_touch_amazing.h.
Nur in final2/drivers/input/touchscreen: zinitix_touch_bt4x3_firmware.h.
Nur in final2/drivers/input/touchscreen: zinitix_touch_bt4x3_firmware_R023.h.
Nur in final2/drivers/input/touchscreen: zinitix_touch_bt4x3_reg_data.h.
Nur in final2/drivers/input/touchscreen: zinitix_touch_trebon.c.
Nur in final2/drivers/input/touchscreen: zinitix_touch_trebon.h.
diff -ru final2/drivers/Kconfig ics/drivers/Kconfig
--- final2/drivers/Kconfig	2014-08-29 08:16:12.980240000 +0200
+++ ics/drivers/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -130,8 +130,4 @@
 
 source "drivers/clocksource/Kconfig"
 
-source "drivers/sensors/Kconfig"
-
-source "drivers/dpram/Kconfig"
-
 endmenu
diff -ru final2/drivers/leds/leds-msm-pmic.c ics/drivers/leds/leds-msm-pmic.c
--- final2/drivers/leds/leds-msm-pmic.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/leds/leds-msm-pmic.c	2013-04-19 11:37:14.000000000 +0200
@@ -18,27 +18,21 @@
 #include <linux/leds.h>
 
 #include <mach/pmic.h>
-#include <linux/gpio.h>
-//#define MAX_KEYPAD_BL_LEVEL	16
 
-#if defined (CONFIG_MACH_AMAZING_CDMA)
-static unsigned char n_GPIO_KEY_LED_EN = 80;
-#else
-static unsigned char n_GPIO_KEY_LED_EN = 124;
-#endif
+#define MAX_KEYPAD_BL_LEVEL	16
 
 static void msm_keypad_bl_led_set(struct led_classdev *led_cdev,
 	enum led_brightness value)
 {
-	if (value)
-		gpio_set_value(n_GPIO_KEY_LED_EN, 1);
-	else
-		gpio_set_value(n_GPIO_KEY_LED_EN, 0);
-	
+	int ret;
+
+	ret = pmic_set_led_intensity(LED_KEYPAD, value / MAX_KEYPAD_BL_LEVEL);
+	if (ret)
+		dev_err(led_cdev->dev, "can't set keypad backlight\n");
 }
 
 static struct led_classdev msm_kp_bl_led = {
-	.name			= "button-backlight",			//"keyboard-backlight",
+	.name			= "keyboard-backlight",
 	.brightness_set		= msm_keypad_bl_led_set,
 	.brightness		= LED_OFF,
 };
@@ -52,9 +46,6 @@
 		dev_err(&pdev->dev, "unable to register led class driver\n");
 		return rc;
 	}
-#if defined (CONFIG_MACH_AMAZING_CDMA)
-	gpio_tlmm_config(GPIO_CFG(80,  0, GPIO_CFG_OUTPUT, GPIO_CFG_PULL_DOWN, GPIO_CFG_2MA), GPIO_CFG_ENABLE);
-#endif
 	msm_keypad_bl_led_set(&msm_kp_bl_led, LED_OFF);
 	return rc;
 }
@@ -71,6 +62,7 @@
 		pm_message_t state)
 {
 	led_classdev_suspend(&msm_kp_bl_led);
+
 	return 0;
 }
 
diff -ru final2/drivers/Makefile ics/drivers/Makefile
--- final2/drivers/Makefile	2014-08-29 08:16:12.980240000 +0200
+++ ics/drivers/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -123,10 +123,5 @@
 obj-y				+= ieee802154/
 #common clk code
 obj-y				+= clk/
-obj-y                           +=sensors/ 
 
 obj-$(CONFIG_HWSPINLOCK)	+= hwspinlock/
-obj-$(CONFIG_DPRAM)             += dpram/
-ifeq (1, $(shell if [ -d ../../../../../../kernel/drivers/exfat ] ; then echo 1 ; fi))
-obj-y                           += exfat/
-endif
diff -ru final2/drivers/media/video/Kconfig ics/drivers/media/video/Kconfig
--- final2/drivers/media/video/Kconfig	2014-08-29 08:16:14.592240000 +0200
+++ ics/drivers/media/video/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -1041,7 +1041,7 @@
 menuconfig MSM_CAMERA
 	bool "Qualcomm MSM camera and video capture support"
 	depends on ARCH_MSM && VIDEO_V4L2 && I2C
-#	default y
+	default y
 	help
 	  Say Y here to enable selecting the video adapters for
 	  Qualcomm msm camera and video encoding
diff -ru final2/drivers/media/video/msm/Kconfig ics/drivers/media/video/msm/Kconfig
--- final2/drivers/media/video/msm/Kconfig	2014-08-29 08:16:14.732240000 +0200
+++ ics/drivers/media/video/msm/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -16,9 +16,6 @@
 	default y
 	---help---
 	  MICRON 3M Bayer Sensor with AutoFocus
-config MT9V113
-	bool "Sensor mt9v113 (YUV 1.3M)"
-	default n	  
 config MT9D113
 	bool "Sensor mt9d113 (YUV 2M)"
 	depends on MSM_CAMERA && ARCH_MSM8X60 && !MSM_CAMERA_V4L2
@@ -166,51 +163,6 @@
 	  It is a samtech charge pump flash driver and it
 	  supports spotlight and flash light modes with
 	  differrent current levels.
-config S5K4ECGX
-	bool "Sensor S5K4ECGX (LSI 5M)"
-	default n
-	---help---
-	  Support for IMX072 sony sensor driver.
-	  It is a Bayer 5MP sensor with auto focus and it supports
-	  two mipi lanes, required for msm7x2xA platform.
-	  Say Y here if this is msm7x2xA variant platform.
-
-config S5K4ECGX_KYLE
-	bool "Sensor S5K4ECGX (LSI 5M) for KYLE"
-	default n
-	---help---
-	  Support for IMX072 sony sensor driver.
-	  It is a Bayer 5MP sensor with auto focus and it supports
-	  two mipi lanes, required for msm7x2xA platform.
-	  Say Y here if this is msm7x2xA variant platform.
-
-config SR030PC50
-	bool "Sensor SR030PC50 (SF 0.3M)"
-	default n
-	---help---
-	  Support for 030pc50 silicon file sensor driver.
-	  It is a 0.3MP sensor with No-auto focus and it supports
-	  two mipi lanes, required for msm7x2xA platform.
-	  Say Y here if this is msm7x2xA variant platform.
-
-config MSM_CAMERA_FLASH_KTD262EJH
-	bool "Kinetic camera flash support"
-	depends on MSM_CAMERA
-	default y
-	---help---
-	  Enable support for LED flash for msm camera
-
-config S5K5CCGX
-	bool "Sensor s5k5ccgx (3M)"
-	depends on MSM_CAMERA
-	default n 
-	---help---
-	  LSI 3M Sensor with Autofocus
-
-config SR300PC20
-	bool "Sensor sr300pc20 (3M)"
-	depends on MSM_CAMERA
-	default n
 
 config IMX072
 	bool "Sensor imx072 (Sony 5M)"
diff -ru final2/drivers/media/video/msm/Makefile ics/drivers/media/video/msm/Makefile
--- final2/drivers/media/video/msm/Makefile	2014-08-29 08:16:14.732240000 +0200
+++ ics/drivers/media/video/msm/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -46,12 +46,6 @@
 endif
 obj-$(CONFIG_QS_S5K4E1) += qs_s5k4e1.o qs_s5k4e1_reg.o
 obj-$(CONFIG_VB6801) += vb6801.o
-obj-$(CONFIG_S5K4ECGX) += s5k4ecgx.o 
-obj-$(CONFIG_S5K4ECGX_KYLE) += s5k4ecgx_kyle.o
-obj-$(CONFIG_SR030PC50) += sr030pc50.o
-obj-$(CONFIG_MT9V113) += mt9v113.o
-obj-$(CONFIG_S5K5CCGX) += s5k5ccgx.o sec_cam_pmic.o
-obj-$(CONFIG_SR300PC20) += sr300pc20.o sec_cam_pmic.o
 obj-$(CONFIG_IMX072) += imx072.o imx072_reg.o
 obj-$(CONFIG_WEBCAM_OV7692) += ov7692.o
 obj-$(CONFIG_WEBCAM_OV7692_QRD) += ov7692_qrd.o
diff -ru final2/drivers/media/video/msm/msm_camera.c ics/drivers/media/video/msm/msm_camera.c
--- final2/drivers/media/video/msm/msm_camera.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/media/video/msm/msm_camera.c	2013-04-19 11:37:14.000000000 +0200
@@ -917,10 +917,10 @@
 	if (list_empty_careful(&queue->list)) {
 		if (!rc) {
 			rc = -ETIMEDOUT;
-			pr_err("%s: wait_event error %d, 920\n", __func__, rc);
+			pr_err("%s: wait_event error %d\n", __func__, rc);
 			return ERR_PTR(rc);
 		} else if (rc < 0) {
-			pr_err("%s: wait_event error %d, 923\n", __func__, rc);
+			pr_err("%s: wait_event error %d\n", __func__, rc);
 			if (msm_delete_entry(&sync->event_q,
 				list_config, qcmd)) {
 				sync->ignore_qcmd = true;
@@ -1024,15 +1024,9 @@
 		goto end;
 	}
 	msm_queue_drain(&ctrl_pmsm->ctrl_q, list_control);
-#ifdef CONFIG_MACH_KYLE
-	qcmd_resp = __msm_control(sync,
-				  &ctrl_pmsm->ctrl_q,
-				  qcmd, msecs_to_jiffies(5000));
-#else
 	qcmd_resp = __msm_control(sync,
 				  &ctrl_pmsm->ctrl_q,
 				  qcmd, msecs_to_jiffies(10000));
-#endif
 
 	/* ownership of qcmd will be transfered to event queue */
 	qcmd = NULL;
@@ -1138,12 +1132,9 @@
 		buf.type = OUTPUT_TYPE_ST_R;
 	} else {
 		if (se->resptype == MSM_CAM_RESP_STEREO_OP_1) {
-			if (data != NULL) {
-				rc = msm_pmem_frame_ptov_lookup(sync,
-				data->phy.p0_phy, data->phy.p1_phy,
-				data->phy.p2_phy, &pinfo,
+			rc = msm_pmem_frame_ptov_lookup(sync, data->phy.p0_phy,
+				data->phy.p1_phy, data->phy.p2_phy, &pinfo,
 				1);  /* do clear the active flag */
-		  }
 			buf.buf_info.path = path;
 		} else if (se->resptype == MSM_CAM_RESP_STEREO_OP_2) {
 			rc = msm_pmem_frame_ptov_lookup(sync, data->phy.p0_phy,
@@ -1268,18 +1259,14 @@
 			CDBG("%s: Change msg_id to OUTPUT_TYPE_ST_L\n",
 				__func__);
 			se.stats_event.msg_id = OUTPUT_TYPE_ST_L;
-			if (data != NULL) {
-				rc = msm_divert_st_frame(sync, data, &se,
+			rc = msm_divert_st_frame(sync, data, &se,
 				OUTPUT_TYPE_V);
-			}
 		} else if (vpe_data->type == VPE_MSG_OUTPUT_ST_R) {
 			CDBG("%s: Change msg_id to OUTPUT_TYPE_ST_R\n",
 				__func__);
 			se.stats_event.msg_id = OUTPUT_TYPE_ST_R;
-			if (data != NULL) {
-				rc = msm_divert_st_frame(sync, data, &se,
+			rc = msm_divert_st_frame(sync, data, &se,
 				OUTPUT_TYPE_V);
-			}
 		} else {
 			pr_warning("%s: invalid vpe_data->type = %d\n",
 				__func__, vpe_data->type);
@@ -3034,12 +3021,6 @@
 	case MSM_CAM_IOCTL_GET_CAMERA_INFO:
 		rc = msm_get_camera_info(argp);
 		break;
-
-    case MSM_CAM_IOCTL_PCAM_CTRL_8BIT:
-		//sensor_rough_control(argp);
-		//rc = 0;
-			rc = pmsm->sync->sctrl.s_ext_config(argp); // for dual camera interface
-		        break;
 	default:
 		rc = msm_ioctl_common(pmsm, cmd, argp);
 		break;
@@ -3069,10 +3050,6 @@
 			sync->sctrl.s_release();
 			CDBG("%s, msm_camio_sensor_clk_off\n", __func__);
 			msm_camio_sensor_clk_off(sync->pdev);
-#ifdef CONFIG_MACH_KYLE_I
-			if(sync->sctrl.s_power)   //eunice09.kim : change power sequence 
-				sync->sctrl.s_power(false);
-#endif
 			if (sync->sfctrl.strobe_flash_release) {
 				CDBG("%s, strobe_flash_release\n", __func__);
 				sync->sfctrl.strobe_flash_release(
@@ -3455,7 +3432,6 @@
 			msm_enqueue(&sync->pict_q, &qcmd->list_pict);
 			return;
 		}
-		break;
 
 	case VFE_MSG_OUTPUT_S:
 		if (sync->stereocam_enabled &&
@@ -3752,6 +3728,7 @@
 {
 	int rc = 0;
 	struct msm_sync *sync = pmsm->sync;
+
 	mutex_lock(&sync->lock);
 	if (sync->apps_id && strcmp(sync->apps_id, apps_id)
 				&& (!strcmp(MSM_APPS_ID_V4L2, apps_id))) {
@@ -3773,11 +3750,6 @@
 		if (sync->vfefn.vfe_init) {
 			sync->pp_frame_avail = 0;
 			sync->get_pic_abort = 0;
-			
-#ifdef CONFIG_MACH_KYLE_I
-			if(sync->sctrl.s_power) //eunice09.kim : change power sequence
-				sync->sctrl.s_power(true);
-#endif
 			rc = msm_camio_sensor_clk_on(sync->pdev);
 			if (rc < 0) {
 				pr_err("%s: setting sensor clocks failed: %d\n",
diff -ru final2/drivers/media/video/msm/msm_io_7x27a.c ics/drivers/media/video/msm/msm_io_7x27a.c
--- final2/drivers/media/video/msm/msm_io_7x27a.c	2014-08-29 08:20:15.300248000 +0200
+++ ics/drivers/media/video/msm/msm_io_7x27a.c	2013-04-19 11:37:14.000000000 +0200
@@ -339,13 +339,9 @@
 		(0x1 << MIPI_PHY_D0_CONTROL2_ERR_SOT_HS_EN_SHFT);
 	CDBG("%s MIPI_PHY_D0_CONTROL2 val=0x%x\n", __func__, val);
 	msm_io_w(val, csibase + MIPI_PHY_D0_CONTROL2);
-#if defined(CONFIG_MACH_KYLE)
 	msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL2);
-#else
-	/*msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL2);
 	msm_io_w(val, csibase + MIPI_PHY_D2_CONTROL2);
-	msm_io_w(val, csibase + MIPI_PHY_D3_CONTROL2);*/
-#endif
+	msm_io_w(val, csibase + MIPI_PHY_D3_CONTROL2);
 
 	val = (0x0F << MIPI_PHY_CL_CONTROL_HS_TERM_IMP_SHFT) |
 		(0x0 << MIPI_PHY_CL_CONTROL_LP_REC_EN_SHFT);
@@ -386,13 +382,9 @@
 		(0x1 << MIPI_PHY_D0_CONTROL2_ERR_SOT_HS_EN_SHFT);
 	CDBG("%s MIPI_PHY_D0_CONTROL2 val=0x%x\n", __func__, val);
 	msm_io_w(val, csibase + MIPI_PHY_D0_CONTROL2);
-#if defined(CONFIG_MACH_KYLE)
 	msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL2);
-#else
-	/*msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL2);
 	msm_io_w(val, csibase + MIPI_PHY_D2_CONTROL2);
-	msm_io_w(val, csibase + MIPI_PHY_D3_CONTROL2);*/
-#endif
+	msm_io_w(val, csibase + MIPI_PHY_D3_CONTROL2);
 
 	val = (0x0F << MIPI_PHY_CL_CONTROL_HS_TERM_IMP_SHFT) |
 		(0x0 << MIPI_PHY_CL_CONTROL_LP_REC_EN_SHFT);
@@ -426,30 +418,15 @@
 	rc = camdev->camera_gpio_on();
 	if (rc < 0)
 		return rc;
-	
-#if defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)|| defined(CONFIG_MACH_KYLE) && !defined(CONFIG_MACH_KYLE_I)
-	return rc;
-#else
 	return msm_camio_clk_enable(CAMIO_CAM_MCLK_CLK);
-#endif
-
 }
 
 int msm_camio_sensor_clk_off(struct platform_device *pdev)
 {
-
-#if (defined(CONFIG_MACH_AMAZING)|| defined(CONFIG_MACH_KYLE)) && !defined(CONFIG_MACH_KYLE_I)
-	int rc = 0;
-#endif
 	const struct msm_camera_sensor_info *sinfo = pdev->dev.platform_data;
 	struct msm_camera_device_platform_data *camdev = sinfo->pdata;
 	camdev->camera_gpio_off();
-
-#if (defined(CONFIG_MACH_AMAZING)||defined(CONFIG_MACH_KYLE)) && !defined(CONFIG_MACH_KYLE_I)
-return rc;
-#else
 	return msm_camio_clk_disable(CAMIO_CAM_MCLK_CLK);
-#endif
 
 }
 
@@ -461,24 +438,24 @@
 	val = readl_relaxed(appbase + 0x00000210);
 	val |= 0x1;
 	writel_relaxed(val, appbase + 0x00000210);
-	usleep_range(1000, 2000);
+	usleep_range(10000, 11000);
 
 	val = readl_relaxed(appbase + 0x00000210);
 	val &= ~0x1;
 	writel_relaxed(val, appbase + 0x00000210);
-	usleep_range(1000, 2000);
+	usleep_range(10000, 11000);
 
 	/* do axi reset */
 	val = readl_relaxed(appbase + 0x00000208);
 	val |= 0x1;
 	writel_relaxed(val, appbase + 0x00000208);
-	usleep_range(1000, 2000);
+	usleep_range(10000, 11000);
 
 	val = readl_relaxed(appbase + 0x00000208);
 	val &= ~0x1;
 	writel_relaxed(val, appbase + 0x00000208);
 	mb();
-	usleep_range(1000, 2000);
+	usleep_range(10000, 11000);
 	return;
 }
 
@@ -493,21 +470,11 @@
 
 	msm_camio_clk_enable(CAMIO_CSI0_PCLK);
 	msm_camio_clk_enable(CAMIO_CSI1_PCLK);
-#ifdef CONFIG_MACH_KYLE_I
-	rc = camdev->camera_gpio_on();
-	//if (rc < 0) eunice09.kim : Change power sequence
-		return rc;
-	//mdelay(40);
-	//return msm_camio_clk_enable(CAMIO_CAM_MCLK_CLK);
-#else
+
 	rc = camdev->camera_gpio_on();
-	if (rc < 0) //eunice09.kim : Change power sequence
+	if (rc < 0)
 		return rc;
-	mdelay(40);
 	return msm_camio_clk_enable(CAMIO_CAM_MCLK_CLK);
-
-#endif
-
 }
 
 int msm_camio_probe_off(struct platform_device *pdev)
@@ -567,13 +534,9 @@
 		(0x1 << MIPI_PHY_D0_CONTROL2_ERR_SOT_HS_EN_SHFT);
 	CDBG("%s MIPI_PHY_D0_CONTROL2 val=0x%x\n", __func__, val);
 	msm_io_w(val, csibase + MIPI_PHY_D0_CONTROL2);
-#if defined(CONFIG_MACH_KYLE)
 	msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL2);
-#else
-	/*msm_io_w(val, csibase + MIPI_PHY_D1_CONTROL2);
 	msm_io_w(val, csibase + MIPI_PHY_D2_CONTROL2);
-	msm_io_w(val, csibase + MIPI_PHY_D3_CONTROL2);*/
-#endif
+	msm_io_w(val, csibase + MIPI_PHY_D3_CONTROL2);
 
 
 	val = (0x0F << MIPI_PHY_CL_CONTROL_HS_TERM_IMP_SHFT) |
Nur in final2/drivers/media/video/msm: mt9v113.c.
Nur in final2/drivers/media/video/msm: mt9v113.h.
Nur in final2/drivers/media/video/msm: s5k4ecgx.c.
Nur in final2/drivers/media/video/msm: s5k4ecgx.h.
Nur in final2/drivers/media/video/msm: s5k4ecgx_kyle.c.
Nur in final2/drivers/media/video/msm: s5k4ecgx_kyle.h.
Nur in final2/drivers/media/video/msm: s5k4ecgx_regs.h.
Nur in final2/drivers/media/video/msm: s5k4ecgx_regs_kyle.h.
Nur in final2/drivers/media/video/msm: s5k5ccgx.c.
Nur in final2/drivers/media/video/msm: s5k5ccgx.h.
Nur in final2/drivers/media/video/msm: sec_cam_pmic.c.
Nur in final2/drivers/media/video/msm: sec_cam_pmic.h.
Nur in final2/drivers/media/video/msm: sr030pc50.c.
Nur in final2/drivers/media/video/msm: sr030pc50.h.
Nur in final2/drivers/media/video/msm: sr300pc20.c.
Nur in final2/drivers/media/video/msm: sr300pc20.h.
Nur in final2/drivers/misc: fsaxxxx_usbsw.c.
diff -ru final2/drivers/misc/Kconfig ics/drivers/misc/Kconfig
--- final2/drivers/misc/Kconfig	2014-08-29 08:16:14.948240000 +0200
+++ ics/drivers/misc/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -569,13 +569,6 @@
 	processing of MPEG transport streams from the main processor.
 	This can also be compiled as a loadable module.
 
-config SAMSUNG_JACK
-	bool "3.5 PI EAR_JACK driver for Samsung devices"
-	depends on INPUT
-	default n
-	---help---
-	  This is 3.5 PI EAR_JACK driver for Samsung devices.
-
 config HAPTIC_ISA1200
 	tristate "ISA1200 haptic support"
 	depends on I2C
@@ -649,29 +642,6 @@
 	  to the fuse block. Currently this is supported only
 	  on FSM targets.
 
-config FSAXXXX_USBSW
-	bool "Fairchild FSAxxxx USB switch Driver"
-	depends on I2C
-	default n
-
-config SEC_MISC
-	bool "Samsung P series miscellaneous driver"
-	default n
-	---help---
-	  Samsung P series miscellaneous driver
-
-config SEC_DEBUG
-	bool "Samsung Debug Code"
-	default n
-	---help---
-	  Samsung debug code	
-
-config SEC_DUMP
-	bool "Samsung DUMP Code"
-	default n
-	---help---
-	  Samsung dump code		  
-
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
@@ -679,6 +649,5 @@
 source "drivers/misc/ti-st/Kconfig"
 source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/carma/Kconfig"
-source "drivers/misc/modem_if/Kconfig"
 
 endif # MISC_DEVICES
diff -ru final2/drivers/misc/Makefile ics/drivers/misc/Makefile
--- final2/drivers/misc/Makefile	2014-08-29 08:16:14.948240000 +0200
+++ ics/drivers/misc/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -55,8 +55,6 @@
 msm_tsif-objs := tsif.o
 obj-$(CONFIG_TSIF_CHRDEV) += tsif_chrdev.o
 obj-$(CONFIG_TSPP) += tspp.o
-obj-$(CONFIG_SAMSUNG_JACK) += sec_jack.o
-obj-$(CONFIG_FSAXXXX_USBSW)  += fsaxxxx_usbsw.o
 obj-$(CONFIG_HAPTIC_ISA1200)		+= isa1200.o
 obj-$(CONFIG_PMIC8058_PWM) += pmic8058-pwm.o
 obj-$(CONFIG_PMIC8XXX_VIBRATOR) += pm8xxx-vibrator.o
@@ -68,7 +66,3 @@
 obj-$(CONFIG_TZCOM) += tzcom.o
 obj-$(CONFIG_QSEECOM) += qseecom.o
 obj-$(CONFIG_QFP_FUSE) += qfp_fuse.o
-obj-$(CONFIG_SEC_MODEM) += modem_if/
-obj-$(CONFIG_SEC_MISC) += sec_misc.o sec_param.o
-obj-$(CONFIG_SEC_DEBUG) += sec_debug.o
-obj-$(CONFIG_SEC_DUMP) += sec_dump.o
Nur in final2/drivers/misc: modem_if.
Nur in final2/drivers/misc: sec_debug.c.
Nur in final2/drivers/misc: sec_dump.c.
Nur in final2/drivers/misc: sec_dump.h.
Nur in final2/drivers/misc: sec_jack.c.
Nur in final2/drivers/misc: sec_misc.c.
Nur in final2/drivers/misc: sec_param.c.
diff -ru final2/drivers/mmc/card/block.c ics/drivers/mmc/card/block.c
--- final2/drivers/mmc/card/block.c	2014-08-29 08:20:15.304248000 +0200
+++ ics/drivers/mmc/card/block.c	2013-04-19 11:37:14.000000000 +0200
@@ -192,6 +192,7 @@
 {
 	struct mmc_blk_data *md = mmc_blk_get(bdev->bd_disk);
 	int ret = -ENXIO;
+
 	mutex_lock(&block_mutex);
 	if (md) {
 		if (md->usage == 2)
@@ -1302,9 +1303,7 @@
 
 	ret = mmc_init_queue(&md->queue, card, &md->lock, subname);
 	if (ret)
-     {
 		goto err_putdisk;
-     }  
 
 	md->queue.issue_fn = mmc_blk_issue_rq;
 	md->queue.data = md;
@@ -1332,7 +1331,7 @@
 
 	snprintf(md->disk->disk_name, sizeof(md->disk->disk_name),
 		 "mmcblk%d%s", md->name_idx, subname ? subname : "");
-		 
+
 	blk_queue_logical_block_size(md->queue.queue, 512);
 	set_capacity(md->disk, size);
 
@@ -1660,6 +1659,7 @@
 	res = mmc_register_driver(&mmc_driver);
 	if (res)
 		goto out2;
+
 	return 0;
  out2:
 	unregister_blkdev(MMC_BLOCK_MAJOR, "mmc");
diff -ru final2/drivers/mmc/core/core.c ics/drivers/mmc/core/core.c
--- final2/drivers/mmc/core/core.c	2014-08-29 08:20:15.304248000 +0200
+++ ics/drivers/mmc/core/core.c	2013-04-19 11:37:14.000000000 +0200
@@ -1427,20 +1427,6 @@
 		return mmc_mmc_erase_timeout(card, arg, qty);
 }
 
-#define UNSTUFF_BITS(resp, start, size)					\
-	({								\
-		const int __size = size;				\
-		const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1;	\
-		const int __off = 3 - ((start) / 32);			\
-		const int __shft = (start) & 31;			\
-		u32 __res;						\
-									\
-		__res = resp[__off] >> __shft;				\
-		if (__size + __shft > 32)				\
-			__res |= resp[__off-1] << ((32 - __shft) % 32);	\
-		__res & __mask;						\
-	})
-
 static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 			unsigned int to, unsigned int arg)
 {
@@ -1448,15 +1434,6 @@
 	unsigned int qty = 0;
 	int err;
 
-	u32 *resp = card->raw_csd;
-
-	/* For WriteProtection */
-	if (UNSTUFF_BITS(resp, 12, 2)) {
-		printk(KERN_ERR "eMMC set Write Protection mode, Can't be written or erased.");
-		err = -EIO;
-		goto out;
-	}
-
 	/*
 	 * qty is used to calculate the erase timeout which depends on how many
 	 * erase groups (or allocation units in SD terminology) are affected.
@@ -1545,14 +1522,6 @@
 			err = -EIO;
 			goto out;
 		}
-
-		if (cmd.resp[0] & R1_WP_ERASE_SKIP) {
-			printk(KERN_ERR "error %d requesting status %#x (R1_WP_ERASE_SKIP)\n",
-				err, cmd.resp[0]);
-			err = -EIO;
-			goto out;
-		}
-
 	} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
 		 R1_CURRENT_STATE(cmd.resp[0]) == 7);
 out:
@@ -1622,15 +1591,6 @@
 	/* 'from' and 'to' are inclusive */
 	to -= 1;
 
-	/* to set the Address in 16k (32 Sectors) */
-	if (arg == MMC_TRIM_ARG) {
-		if ((from % 32) != 0)
-			from = ((from >> 5) + 1) << 5;
-		to = (to >> 5) << 5;
-		if (from >= to)
-			return 0;
-	}
-
 	return mmc_do_erase(card, from, to, arg);
 }
 EXPORT_SYMBOL(mmc_erase);
@@ -2132,9 +2092,6 @@
 	if (!err && !mmc_card_keep_power(host))
 		mmc_power_off(host);
 
-	if (!host->card || host->index == 1)
-		mdelay(50);
-
 	return err;
 }
 
@@ -2238,11 +2195,7 @@
 		}
 		host->rescan_disable = 0;
 		spin_unlock_irqrestore(&host->lock, flags);
-		if (host->card && host->card->type == MMC_TYPE_SDIO)
-			printk(KERN_INFO
-				"%s(): WLAN SKIP DETECT CHANGE\n", __func__);
-		else
-			mmc_detect_change(host, 0);
+		mmc_detect_change(host, 0);
 
 	}
 
diff -ru final2/drivers/mmc/host/msm_sdcc.c ics/drivers/mmc/host/msm_sdcc.c
--- final2/drivers/mmc/host/msm_sdcc.c	2014-08-29 08:20:15.304248000 +0200
+++ ics/drivers/mmc/host/msm_sdcc.c	2013-04-19 11:37:14.000000000 +0200
@@ -4686,29 +4686,6 @@
 	return NULL;
 }
 
-/* SYSFS about SD Card Detection by soonil.lim */
-
-static struct device *t_flash_detect_dev;
-
-static ssize_t t_flash_detect_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	struct mmc_host *mmc = dev_get_drvdata(dev);
-	struct msmsdcc_host *host = mmc_priv(mmc);
-	unsigned int detect;
-	printk(KERN_ERR "%s : enter in sdc%d\n", __func__, host->pdev_id);
-	detect = host->plat->status(mmc_dev(host->mmc));
-	if (detect) {
-		printk(KERN_DEBUG "sdcc1: card inserted.\n");
-		return sprintf(buf, "Insert\n");
-	} else {
-		printk(KERN_DEBUG "sdcc1: card removed.\n");
-		return sprintf(buf, "Remove\n");
-	}
-}
-
-static DEVICE_ATTR(status, 0444, t_flash_detect_show, NULL);
-
 static int
 msmsdcc_probe(struct platform_device *pdev)
 {
@@ -4725,6 +4702,7 @@
 	struct resource *dma_crci_res = NULL;
 	int ret = 0;
 	int i;
+
 	if (pdev->dev.of_node) {
 		plat = msmsdcc_populate_pdata(&pdev->dev);
 		of_property_read_u32((&pdev->dev)->of_node,
@@ -5120,23 +5098,6 @@
 		pr_err("%s: No card detect facilities available\n",
 		       mmc_hostname(mmc));
 
-/* SYSFS about SD Card Detection by soonil.lim */
-	if (t_flash_detect_dev == NULL && (host->pdev_id == 1)) {
-		printk(KERN_ERR "MAKE SYSFS\n");
-		printk(KERN_DEBUG "%s : Change sysfs Card Detect\n", __func__);
-
-		t_flash_detect_dev = device_create(sec_class,
-			NULL, 0, NULL, "sdcard");
-		if (IS_ERR(t_flash_detect_dev))
-			pr_err("%s : Failed to create device!\n", __func__);
-
-		if (device_create_file(t_flash_detect_dev,
-			&dev_attr_status) < 0)
-			pr_err("%s : Failed to create device file(%s)!\n",
-			       __func__, dev_attr_status.attr.name);
-
-		dev_set_drvdata(t_flash_detect_dev, mmc);
-	}
 	mmc_set_drvdata(pdev, mmc);
 
 	ret = pm_runtime_set_active(&(pdev)->dev);
@@ -5491,25 +5452,6 @@
 		goto out;
 	}
 
-	if (host->pdev_id == 2) {
-		printk(KERN_INFO "SDCC CH 2 : msmsdcc_runtime_suspend WLAN SKIP Suspend\n");
-
-		spin_lock_irqsave(&host->lock, flags);
-		writel(0, host->base + MMCIMASK0);
-
-		if (host->clks_on) {
-			clk_disable(host->clk);
-
-			if (!IS_ERR(host->pclk))
-				clk_disable(host->pclk);
-
-			host->clks_on = 0;
-		}
-		spin_unlock_irqrestore(&host->lock, flags);
-
-		return 0;
-	}
-
 	pr_debug("%s: %s: start\n", mmc_hostname(mmc), __func__);
 	if (mmc) {
 		host->sdcc_suspending = 1;
@@ -5580,27 +5522,6 @@
 	if (host->plat->is_sdio_al_client)
 		return 0;
 
-	if (host->pdev_id == 2) {
-		printk(KERN_INFO "SDCC CH 2 : msmsdcc_runtime_resume WLAN SKIP Resume\n");
-
-		spin_lock_irqsave(&host->lock, flags);
-
-		if (!host->clks_on) {
-			if (!IS_ERR_OR_NULL(host->dfab_pclk))
-				clk_enable(host->dfab_pclk);
-
-			if (!IS_ERR(host->pclk))
-				clk_enable(host->pclk);
-
-			clk_enable(host->clk);
-			host->clks_on = 1;
-		}
-		writel(host->mci_irqenable, host->base + MMCIMASK0);
-		spin_unlock_irqrestore(&host->lock, flags);
-
-		return 0;
-	}
-
 	pr_debug("%s: %s: start\n", mmc_hostname(mmc), __func__);
 	if (mmc) {
 		if (mmc->card && mmc_card_sdio(mmc->card) &&
diff -ru final2/drivers/mmc/host/msm_sdcc.h ics/drivers/mmc/host/msm_sdcc.h
--- final2/drivers/mmc/host/msm_sdcc.h	2014-08-29 08:20:15.304248000 +0200
+++ ics/drivers/mmc/host/msm_sdcc.h	2013-04-19 11:37:14.000000000 +0200
@@ -219,8 +219,6 @@
 #define MSM_MMC_REQ_TIMEOUT	10000 /* msecs */
 #define MSM_MMC_DISABLE_TIMEOUT        200 /* msecs */
 
-extern struct class *sec_class;	/* Sysfs about SD Card Detection */
-
 /*
  * Controller HW limitations
  */
diff -ru final2/drivers/net/Kconfig ics/drivers/net/Kconfig
--- final2/drivers/net/Kconfig	2014-08-29 08:16:15.136240000 +0200
+++ ics/drivers/net/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -3445,7 +3445,7 @@
 config MSM_RMNET
 	tristate "MSM RMNET Virtual Network Device"
 	depends on ARCH_MSM
-	default n
+	default y
 	help
 	  Virtual ethernet interface for MSM RMNET transport.
 
Nur in final2/drivers/net/wireless/ath: ath6kl.
diff -ru final2/drivers/net/wireless/ath/Kconfig ics/drivers/net/wireless/ath/Kconfig
--- final2/drivers/net/wireless/ath/Kconfig	2014-08-29 08:16:16.856240000 +0200
+++ ics/drivers/net/wireless/ath/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -25,6 +25,5 @@
 source "drivers/net/wireless/ath/ath5k/Kconfig"
 source "drivers/net/wireless/ath/ath9k/Kconfig"
 source "drivers/net/wireless/ath/carl9170/Kconfig"
-source "drivers/net/wireless/ath/ath6kl/Kconfig"
 
 endif
diff -ru final2/drivers/net/wireless/ath/Makefile ics/drivers/net/wireless/ath/Makefile
--- final2/drivers/net/wireless/ath/Makefile	2014-08-29 08:16:16.856240000 +0200
+++ ics/drivers/net/wireless/ath/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -1,9 +1,4 @@
-NOSTDINC_FLAGS := -I$(srctree)/include/compat/ \
-        -include $(srctree)/include/compat/linux/compat-2.6.h \
-        $(CFLAGS)
-
 obj-$(CONFIG_ATH5K)		+= ath5k/
-obj-$(CONFIG_ATH6KL)		+= ath6kl/
 obj-$(CONFIG_ATH9K_HW)		+= ath9k/
 obj-$(CONFIG_CARL9170)		+= carl9170/
 
Nur in final2/drivers/power: bq27425_fuelgauge.c.
Nur in final2/drivers/power: fuel_gauge.c.
Nur in final2/drivers/power: fuelgauge_max17043.c.
Nur in final2/drivers/power: fuelgauge_max17048.c.
diff -ru final2/drivers/power/Kconfig ics/drivers/power/Kconfig
--- final2/drivers/power/Kconfig	2014-08-29 08:16:32.484241000 +0200
+++ ics/drivers/power/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -281,11 +281,6 @@
 	  To compile this driver as a module, choose M here: the module will
 	  be called smb137b.
 
-config CHARGER_SMB328A
-	bool "Enable SMB328A charger driver"
-	default n
-	help
-	  Say Y here to enable support for charger with SMB328A chip
 config BATTERY_MSM_FAKE
 	tristate "Fake MSM battery"
 	depends on ARCH_MSM && BATTERY_MSM
@@ -357,22 +352,4 @@
 	help
 	  Say Y here to enable support for pm8921 chip bms subdevice
 
-config BQ27425_FUEL_GAUGE
-	tristate "TI BQ27425 Fuel Gauge"
-	depends on I2C
-	help
-	  BQ27425 is fuel-gauge systems for lithium-ion (Li+) batteries
-	  in handheld and portable equipment.
-config MAX17043_FUELGAUGE
-	tristate "Maxim MAX17043 Fuel Gauge"
-	depends on I2C
-	help
-	  MAX17043 is fuel-gauge systems for lithium-ion (Li+) batteries
-	  in handheld and portable equipment "
-config MAX17048_FUELGAUGE
-	tristate "Maxim MAX17048 Fuel Gauge"
-	depends on I2C
-	help
-	  MAX17048 is fuel-gauge systems for lithium-ion (Li+) batteries
-	  in handheld and portable equipment "
 endif # POWER_SUPPLY
diff -ru final2/drivers/power/Makefile ics/drivers/power/Makefile
--- final2/drivers/power/Makefile	2014-08-29 08:16:32.484241000 +0200
+++ ics/drivers/power/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -37,7 +37,6 @@
 obj-$(CONFIG_CHARGER_TWL4030)	+= twl4030_charger.o
 obj-$(CONFIG_CHARGER_GPIO)	+= gpio-charger.o
 obj-$(CONFIG_BATTERY_MSM)       += msm_battery.o
-obj-$(CONFIG_MAX17043_FUEL_GAUGE)	+= fuel_gauge.o
 obj-$(CONFIG_BATTERY_MSM8X60)   += msm_charger.o
 obj-$(CONFIG_PM8058_CHARGER)    += pmic8058-charger.o
 obj-$(CONFIG_ISL9519_CHARGER)   += isl9519q.o
@@ -49,7 +48,4 @@
 obj-$(CONFIG_PM8XXX_CCADC)	+= pm8xxx-ccadc.o
 obj-$(CONFIG_PM8921_BMS)	+= pm8921-bms.o
 obj-$(CONFIG_PM8921_CHARGER)	+= pm8921-charger.o
-obj-$(CONFIG_BQ27425_FUEL_GAUGE)	+= bq27425_fuelgauge.o
-obj-$(CONFIG_MAX17048_FUELGAUGE)	+= fuelgauge_max17048.o
-obj-$(CONFIG_MAX17043_FUELGAUGE)	+= fuelgauge_max17043.o
-obj-$(CONFIG_CHARGER_SMB328A)   += smb328a_charger.o
+obj-$(CONFIG_LTC4088_CHARGER)	+= ltc4088-charger.o
diff -ru final2/drivers/power/msm_battery.c ics/drivers/power/msm_battery.c
--- final2/drivers/power/msm_battery.c	2014-08-29 08:20:15.304248000 +0200
+++ ics/drivers/power/msm_battery.c	2013-04-19 11:37:14.000000000 +0200
@@ -8,15 +8,14 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
+ *
  */
 
 /*
  * this needs to be before <linux/kernel.h> is loaded,
  * and <linux/sched.h> loads <linux/kernel.h>
  */
-#include <linux/device.h>
-
-#define MAX17043_FUEL_GAUGE
+#define DEBUG  0
 
 #include <linux/slab.h>
 #include <linux/earlysuspend.h>
@@ -29,38 +28,17 @@
 #include <linux/uaccess.h>
 #include <linux/wait.h>
 #include <linux/workqueue.h>
-#include <linux/fsaxxxx_usbsw.h>
-#include <linux/atomic.h>
+
+#include <asm/atomic.h>
+
 #include <mach/msm_rpcrouter.h>
 #include <mach/msm_battery.h>
-#include <mach/bq27425_fuelguage.h>
-#include "../../arch/arm/mach-msm/proc_comm.h"
-#include <mach/pmic.h>
-#include <linux/android_alarm.h>
-/*from S+*/
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/wakelock.h>
-
-#include <linux/timer.h>
-#include <linux/delay.h>
-
-static struct wake_lock vbus_wake_lock;
-static struct wake_lock lpm_wake_lock;
-static struct wake_lock fuel_alert_wake_lock;
-static int fuel_alert_det;
-
-#ifdef DEBUG
-#undef pr_debug
-#define pr_debug pr_info
-#endif
 
-#define BATTERY_RPC_PROG		0x30000089
-#define BATTERY_RPC_VER_1_1		0x00010001
-#define BATTERY_RPC_VER_2_1		0x00020001
-#define BATTERY_RPC_VER_4_1		0x00040001
-#define BATTERY_RPC_VER_5_1		0x00050001
+#define BATTERY_RPC_PROG	0x30000089
+#define BATTERY_RPC_VER_1_1	0x00010001
+#define BATTERY_RPC_VER_2_1	0x00020001
+#define BATTERY_RPC_VER_4_1     0x00040001
+#define BATTERY_RPC_VER_5_1     0x00050001
 
 #define BATTERY_RPC_CB_PROG	(BATTERY_RPC_PROG | 0x01000000)
 
@@ -68,322 +46,40 @@
 #define CHG_RPC_VER_1_1		0x00010001
 #define CHG_RPC_VER_1_3		0x00010003
 #define CHG_RPC_VER_2_2		0x00020002
-#define CHG_RPC_VER_3_1		0x00030001
-#define CHG_RPC_VER_4_1		0x00040001
+#define CHG_RPC_VER_3_1         0x00030001
+#define CHG_RPC_VER_4_1         0x00040001
 
-#define BATTERY_REGISTER_PROC			2
-#define BATTERY_MODIFY_CLIENT_PROC		4
-#define BATTERY_DEREGISTER_CLIENT_PROC	5
-#define BATTERY_READ_MV_PROC			12
-#define BATTERY_ENABLE_DISABLE_FILTER_PROC	14
+#define BATTERY_REGISTER_PROC				2
+#define BATTERY_MODIFY_CLIENT_PROC			4
+#define BATTERY_DEREGISTER_CLIENT_PROC			5
+#define BATTERY_READ_MV_PROC				12
+#define BATTERY_ENABLE_DISABLE_FILTER_PROC		14
 
-#define VBATT_FILTER				2
+#define VBATT_FILTER			2
 
-#define BATTERY_CB_TYPE_PROC			1
+#define BATTERY_CB_TYPE_PROC		1
 #define BATTERY_CB_ID_ALL_ACTIV		1
-#define BATTERY_CB_ID_LOW_VOL			2
+#define BATTERY_CB_ID_LOW_VOL		2
 
-#define BATTERY_LOW				3200
-#define BATTERY_HIGH				4300
+#define BATTERY_LOW		3200
+#define BATTERY_HIGH		4300
 
 #define ONCRPC_CHG_GET_GENERAL_STATUS_PROC	12
 #define ONCRPC_CHARGER_API_VERSIONS_PROC	0xffffffff
 
-#define BATT_RPC_TIMEOUT	5000	/* 5 sec */
-
-#define INVALID_BATT_HANDLE		-1
-
-#define RPC_TYPE_REQ		0
-#define RPC_TYPE_REPLY		1
-#define RPC_REQ_REPLY_COMMON_HEADER_SIZE	(3 * sizeof(uint32_t))
-
-#define DEBUG 1
-
-
-typedef enum {
-	STOP_CHARGING,
-	START_CHARGING
-} chg_enable_type;
-
-
-enum chg_type {
-	USB_CHG_TYPE__SDP,
-	USB_CHG_TYPE__CARKIT,
-	USB_CHG_TYPE__WALLCHARGER,
-	USB_CHG_TYPE__INVALID
-};
-
-/*Maybe iT is not used in here*/
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING)
-const int temp_table[][2] = {
-	/* ADC, Temperature (C) */
-	{813, -10},
-	{808, -9},
-	{803, -8},
-	{798, -7},
-	{793, -6},
-	{788, -5},
-	{783, -4},
-	{778, -3},
-	{773, -2},
-	{768, -1},
-	{762, 0},
-	{756, 1},
-	{750, 2},
-	{744, 3},
-	{738, 4},
-	{731, 5},
-	{724, 6},
-	{718, 7},
-	{711, 8},
-	{704, 9},
-	{696, 10},
-	{688, 11},
-	{681, 12},
-	{674, 13},
-	{667, 14},
-	{660, 15},
-	{652, 16},
-	{644, 17},
-	{636, 18},
-	{628, 19},
-	{620, 20},
-	{612, 21},
-	{604, 22},
-	{595, 23},
-	{587, 24},
-	{578, 25},
-	{569, 26},
-	{559, 27},
-	{550, 28},
-	{541, 29},
-	{532, 30},
-	{522, 31},
-	{513, 32},
-	{503, 33},
-	{494, 34},
-	{484, 35},
-	{475, 36},
-	{466, 37},
-	{457, 38},
-	{448, 39},
-	{439, 40},
-	{430, 41},
-	{421, 42},
-	{412, 43},
-	{403, 44},
-	{395, 45},
-	{387, 46},
-	{379, 47},
-	{371, 48},
-	{363, 49},
-	{355, 50},
-	{348, 51},
-	{341, 52},
-	{334, 53},
-	{327, 54},
-	{320, 55},
-	{313, 56},
-	{306, 57},
-	{299, 58},
-	{292, 59},
-	{285, 60},
-	{278, 61},
-	{271, 62},
-	{264, 63},
-	{257, 64},
-	{250, 65},
-	{243, 66},
-	{236, 67},
-};
-
-#elif CONFIG_MACH_AMAZING_CDMA
-const int temp_table[][2] = {
-	/*ADC, Temperature (C) */
-	{246, 65},
-	{280, 60},
-	{318, 55},
-	{359, 50},
-	{402, 45},
-	{446, 40},
-	{492, 35},
-	{541, 30},
-	{587, 25},
-	{631, 20},
-	{675, 15},
-	{711, 10},
-	{746, 5},
-	{778, 0},
-	{802, -5},
-	{825, -10},
-	{843, -15},
-	{857, -20},
-	{869, -25},
-	{877, -30},
-};
-
-#elif CONFIG_MACH_KYLE
-const int temp_table[][2] = {
-	/*ADC, Temperature (C) */
-	{240, 70},
-	{286, 60},
-	{350, 50},
-	{449, 40},
-	{545, 30},
-	{617, 20},
-	{699, 10},
-	{776, 0},
-	{818, -10},
-	{852, -20},
-	{876, -30},
-};
-#else
-const int temp_table[][2] = {
-	/* ADC, Temperature (C) */
-	{860, -20},
-	{847, -15},
-	{831, -10},
-	{808, -5},
-	{782, 0},
-	{740, 5},
-	{711, 10},
-	{682, 15},
-	{624, 20},
-	{587, 25},
-	{538, 30},
-	{504, 35},
-	{449, 40},
-	{413, 45},
-	{370, 50},
-	{330, 55},
-	{289, 60}
-};
-
-#endif
-
-#define AVERAGE_COUNT				10
-
-#ifdef __FULL_CHARGE_TEST__
-#define TOTAL_CHARGING_TIME			(1 * 60*HZ)
-#define TOTAL_RECHARGING_TIME			(1 * 60*HZ)
-#else
-#define TOTAL_CHARGING_TIME			(5 * 60*60*HZ)
-#define TOTAL_RECHARGING_TIME			(90 * 60*HZ)
-#endif
-#define TOTAL_WATING_TIME			(20 * HZ)
-#define WAKE_LOCK_TIME_OUT			(5 * HZ)
-#define ALARM_POLLING_TIME_SHORT		(1 * 60)
-#define ALARM_POLLING_TIME_LONG		(10 * 60)
-
-#define BAT_USE_TIMER_EXPIRE			(10 * 60*HZ)
-
-
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING)
-#define BATT_CHECK_INTERVAL			(10 * HZ)
-#elif CONFIG_MACH_KYLE
-#define BATT_CHECK_INTERVAL			(20 * HZ)
-#else
-#define BATT_CHECK_INTERVAL			(30 * HZ)
-#endif
-#define TEMP_TABLE_OFFSET			30
+#define BATT_RPC_TIMEOUT    5000	/* 5 sec */
 
-#if defined(CONFIG_MACH_GEIM)
-#define BATT_TEMP_EVENT_BLOCK			60
-#define BATT_TEMP_HIGH_BLOCK			47
-#define BATT_TEMP_HIGH_RECOVER			43
-#define BATT_TEMP_LOW_BLOCK			(-5)
-#define BATT_TEMP_LOW_RECOVER			0
-
-#define BATT_TEMP_HIGH_BLOCK_LPM		47
-#define BATT_TEMP_HIGH_RECOVER_LPM		43
-#define BATT_TEMP_LOW_BLOCK_LPM		(-5)
-#define BATT_TEMP_LOW_RECOVER_LPM		0
-
-#elif CONFIG_MACH_AMAZING
-#define BATT_TEMP_EVENT_BLOCK			60
-#define BATT_TEMP_HIGH_BLOCK			48
-#define BATT_TEMP_HIGH_RECOVER			42
-#define BATT_TEMP_LOW_BLOCK			(-5)
-#define BATT_TEMP_LOW_RECOVER			0
-
-#define BATT_TEMP_HIGH_BLOCK_LPM		48
-#define BATT_TEMP_HIGH_RECOVER_LPM		42
-#define BATT_TEMP_LOW_BLOCK_LPM			(-5)
-#define BATT_TEMP_LOW_RECOVER_LPM		0
-
-#elif CONFIG_MACH_AMAZING_CDMA
-#define BATT_TEMP_EVENT_BLOCK			276
-#define BATT_TEMP_HIGH_BLOCK			428
-#define BATT_TEMP_HIGH_RECOVER			433
-#define BATT_TEMP_LOW_BLOCK				802
-#define BATT_TEMP_LOW_RECOVER			775
-
-#define BATT_TEMP_HIGH_BLOCK_LPM		428
-#define BATT_TEMP_HIGH_RECOVER_LPM		433
-#define BATT_TEMP_LOW_BLOCK_LPM			802
-#define BATT_TEMP_LOW_RECOVER_LPM		775
-
-#elif CONFIG_MACH_KYLE
-#define BATT_TEMP_EVENT_BLOCK			719
-#define BATT_TEMP_HIGH_BLOCK			286
-#define BATT_TEMP_HIGH_RECOVER			449
-#define BATT_TEMP_LOW_BLOCK			800
-#define BATT_TEMP_LOW_RECOVER			776
-
-#define BATT_TEMP_HIGH_BLOCK_LPM		286
-#define BATT_TEMP_HIGH_RECOVER_LPM		449
-#define BATT_TEMP_LOW_BLOCK_LPM			800
-#define BATT_TEMP_LOW_RECOVER_LPM		776
+#define INVALID_BATT_HANDLE    -1
 
-#else
-#define BATT_TEMP_HIGH_BLOCK			60
-#define BATT_TEMP_HIGH_RECOVER			40
-#define BATT_TEMP_LOW_BLOCK			(-5)
-#define BATT_TEMP_LOW_RECOVER			0
-
-#define BATT_TEMP_HIGH_BLOCK_LPM		60
-#define BATT_TEMP_HIGH_RECOVER_LPM		40
-#define BATT_TEMP_LOW_BLOCK_LPM		(-5)
-#define BATT_TEMP_LOW_RECOVER_LPM		0
+#define RPC_TYPE_REQ     0
+#define RPC_TYPE_REPLY   1
+#define RPC_REQ_REPLY_COMMON_HEADER_SIZE   (3 * sizeof(uint32_t))
 
-#endif
 
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-#define USE_CALL			(0x1 << 0)
-#define USE_VIDEO			(0x1 << 1)
-#define USE_MUSIC			(0x1 << 2)
-#define USE_BROWSER		(0x1 << 3)
-#define USE_HOTSPOT			(0x1 << 4)
-#define USE_CAMERA			(0x1 << 5)
-#define USE_DATA_CALL		(0x1 << 6)
-#define USE_GPS			(0x1 << 7)
-#endif /*CONFIG_MACH_GEIM*/
-
-
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING)
-#define BATT_FULL_CHARGING_CURRENT	90
-#define BATT_FULL_CHARGING_VOLTAGE      4180
-#elif CONFIG_MACH_KYLE
-#define BATT_FULL_CHARGING_CURRENT	120
-#define BATT_FULL_CHARGING_VOLTAGE      4320
-#define BATT_FULL_PERCENT_VOLTAGE       4300
-#elif defined(CONFIG_MACH_AMAZING_CDMA)
-#define BATT_FULL_CHARGING_CURRENT	150
-#define BATT_FULL_CHARGING_VOLTAGE      4190
+#if DEBUG
+#define DBG_LIMIT(x...) do {if (printk_ratelimit()) pr_debug(x); } while (0)
 #else
-#define BATT_FULL_CHARGING_CURRENT	90
-#define BATT_FULL_CHARGING_VOLTAGE      4180
-#endif /*CONFIG_FUEL_GPIO*/
-
-#ifdef CONFIG_MACH_KYLE
-#define BATT_RECHARGING_VOLTAGE_1	4300
-#define BATT_RECHARGING_VOLTAGE_2	4150
-#elif defined(CONFIG_MACH_AMAZING_CDMA)
-#define BATT_RECHARGING_VOLTAGE_1	4130
-#define BATT_RECHARGING_VOLTAGE_2	4000
-#else
-#define BATT_RECHARGING_VOLTAGE_1	4130
-#define BATT_RECHARGING_VOLTAGE_2	4000
+#define DBG_LIMIT(x...) do {} while (0)
 #endif
 
 enum {
@@ -415,38 +111,6 @@
 	BATTERY_VOLTAGE_UNKNOWN,
 };
 
-/* for Rev 03*/
-#ifndef CONFIG_BQ27425_FUEL_GAUGE
-#define BATT_LOW_VOLT		3400
-#define BATT_LEVEL1_VOLT	3620
-#define BATT_LEVEL2_VOLT	3700
-#define BATT_LEVEL3_VOLT	3740
-#define BATT_LEVEL4_VOLT	3790
-#define BATT_LEVEL5_VOLT	3860
-#define BATT_LEVEL6_VOLT	3960
-#define BATT_FULL_VOLT		4200
-#define BATT_RECHAR_VOLT	4140
-
-
-#define BATT_LOW_ADC		2315
-#define BATT_LEVEL1_ADC	2680
-#define BATT_LEVEL2_ADC	2825
-#define BATT_LEVEL3_ADC	2895
-#define BATT_LEVEL4_ADC	2985
-#define BATT_LEVEL5_ADC	3105
-#define BATT_LEVEL6_ADC	3275
-#define BATT_LEVEL7_ADC	3394
-#define BATT_LEVEL8_ADC	3513
-#define BATT_LEVEL9_ADC	3547
-#define BATT_FULL_ADC		3685
-
-static int g_chg_en;
-static int prev_scaled_level;
-static int chg_polling_cnt;
-static int bSetTimer;
-
-#endif/*CONFIG_BQ27425_FUEL_GAUGE*/
-
 /*
  * This enum contains defintions of the charger hardware status
  */
@@ -512,45 +176,17 @@
 	BATTERY_LEVEL_INVALID
 };
 
-
-
-
-/*From S+ bat driver*/
-int batt_jig_on_status;
-EXPORT_SYMBOL(batt_jig_on_status);
-
-/* sys fs */
-struct class *jig_class;
-EXPORT_SYMBOL(jig_class);
-struct device *jig_dev;
-EXPORT_SYMBOL(jig_dev);
-
-static ssize_t jig_show(struct device *dev,
-	struct device_attribute *attr, char *buf);
-static DEVICE_ATTR(jig , 664,
-	jig_show, NULL);
-
-static ssize_t jig_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, sizeof(buf), "%d\n", batt_jig_on_status);
-}
-/* sys fs  End S+ bat driver*/
-
-
+#ifndef CONFIG_BATTERY_MSM_FAKE
 struct rpc_reply_batt_chg_v1 {
 	struct rpc_reply_hdr hdr;
-	u32	more_data;
-	u32	charger_status;			/*nc*/
-	u32	charger_type;			/*nc*/
-	u32	battery_status;			/*nc*/
-	u32	battery_level;			/*nc*/
-	u32 battery_voltage;		/*nc*/
-	u32	battery_temp;			/*nc*/
-	u32 battery_temp_adc;
-	u32	chg_current;
-	u32 batt_id;
-	u32 battery_temp_degree;
+	u32 	more_data;
+
+	u32	charger_status;
+	u32	charger_type;
+	u32	battery_status;
+	u32	battery_level;
+	u32     battery_voltage;
+	u32	battery_temp;
 };
 
 struct rpc_reply_batt_chg_v2 {
@@ -568,6 +204,7 @@
 };
 
 static union rpc_reply_batt_chg rep_batt_chg;
+#endif
 
 struct msm_battery_info {
 	u32 voltage_max_design;
@@ -578,173 +215,83 @@
 	u32 batt_api_version;
 
 	u32 avail_chg_sources;
-	u32 current_chg_source;		/*nc*/
-	u32 chg_temp_event_check;
-	u32 talk_gsm;
-	u32 data_call;
+	u32 current_chg_source;
 
 	u32 batt_status;
 	u32 batt_health;
-	u32 charger_valid;			/*nc*/
+	u32 charger_valid;
 	u32 batt_valid;
-	u32 batt_capacity;		/* in percentage */
+	u32 batt_capacity; /* in percentage */
 
-	u32 charger_status;		/*nc*/
+	u32 charger_status;
 	u32 charger_type;
-	u32 battery_status;		/*nc*/
-	u32 battery_level;		/*nc*/
-	u32 battery_voltage;
-
-	u32 fg_soc;
-	u32 battery_vol;		/*volt*/
-	u32 batt_temp_check;
-	u32 batt_full_check;
-	u32 charging_source;
-
-	int battery_temp;		/* in celsius */
-	int batt_temp_degc;
-	u32 chg_current_adc;
-	u32 batt_recharging;
-	/*fuelgauge*/
-	u32	fuel_alert;
-	u32 fuel_alert_adc;
-	u32 fuel_temp;
-	u32 batt_fuel_current;
-
-	u32 batt_type;
-
-	u32 batt_vf_adc;
-	u32 vf;
-	int battery_temp_adc;
-	u32 battery_temp_proc;
-	s32 batt_temp_aver;
-	u32 batt_vol_adc;
-	u32 batt_vol_aver;
+	u32 battery_status;
+	u32 battery_level;
+	u32 battery_voltage; /* in millie volts */
+	u32 battery_temp;  /* in celsius */
 
-	u32 chargingblock_clear;
-	u32 batt_voltage_now;		/*low bat*/
-
-	u32 suspend_status;
+	u32(*calculate_capacity) (u32 voltage);
 
 	s32 batt_handle;
 
-	struct msm_charger_data *pdata;
-
-	enum cable_type_t	cable_status;
-	enum acc_type_t		acc_status;
-	enum ovp_type_t		ovp_status;
-
-	struct msm_battery_callback callback;
-
 	struct power_supply *msm_psy_ac;
 	struct power_supply *msm_psy_usb;
 	struct power_supply *msm_psy_batt;
-	struct power_supply *current_ps;	/*nc*/
+	struct power_supply *current_ps;
 
-	struct alarm		alarm;
 	struct msm_rpc_client *batt_client;
 	struct msm_rpc_endpoint *chg_ep;
 
-	struct workqueue_struct *msm_batt_wq;
-	struct timer_list timer;
-	struct timer_list bat_use_timer;
-
 	wait_queue_head_t wait_q;
 
-	u32 vbatt_modify_reply_avail;	/*nc*/
-	struct early_suspend early_suspend;
-
-	u32 batt_slate_mode;
-	u32 off_backlight;
-
-	u32 batt_use;
-	u32 batt_use_wait;
-	u32 resume_flag;
-	u32 boot_flag;
+	u32 vbatt_modify_reply_avail;
 
-	ktime_t                 last_poll;
+	struct early_suspend early_suspend;
 };
 
 static struct msm_battery_info msm_batt_info = {
 	.batt_handle = INVALID_BATT_HANDLE,
-	.charger_type = CHARGER_TYPE_NONE,
+	.charger_status = CHARGER_STATUS_BAD,
+	.charger_type = CHARGER_TYPE_INVALID,
+	.battery_status = BATTERY_STATUS_GOOD,
+	.battery_level = BATTERY_LEVEL_FULL,
 	.battery_voltage = BATTERY_HIGH,
+	.batt_capacity = 100,
 	.batt_status = POWER_SUPPLY_STATUS_DISCHARGING,
 	.batt_health = POWER_SUPPLY_HEALTH_GOOD,
 	.batt_valid  = 1,
-	.battery_temp = 230,
-	.batt_slate_mode = 0,
-	.off_backlight = 0,
+	.battery_temp = 23,
+	.vbatt_modify_reply_avail = 0,
 };
 
 static enum power_supply_property msm_power_props[] = {
 	POWER_SUPPLY_PROP_ONLINE,
 };
 
-static enum power_supply_property msm_batt_power_props[] = {
-	POWER_SUPPLY_PROP_STATUS,
-	POWER_SUPPLY_PROP_HEALTH,
-	POWER_SUPPLY_PROP_PRESENT,
-	POWER_SUPPLY_PROP_TECHNOLOGY,
-	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
-	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
-	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-	POWER_SUPPLY_PROP_CAPACITY,
-	POWER_SUPPLY_PROP_TEMP,
-	POWER_SUPPLY_PROP_TYPE,
-};
-
 static char *msm_power_supplied_to[] = {
 	"battery",
 };
 
-const char *oem_str[] = {
-	"PCOM_OEM_CHARGING_INFO",
-	"PCOM_OEM_POWER_KEY_GET",
-	"PCOM_OEM_SYS_CMD",
-	"PCOM_OEM_SAMSUNG_LAST",
-};
-
-enum {
-	SMEM_PROC_COMM_CHARGING_CURRENT = 0,
-	SMEM_PROC_COMM_CHARGING_VF,
-	SMEM_PROC_COMM_CHARGING_TEMP_ADC,
-	SMEM_PROC_COMM_CHARGING_TEMP_DEGREE,
-	SMEM_PROC_COMM_CHARGING_VOLTAGE,
-	SMEM_PROC_COMM_CHARGING_CHARGE_STATE,
-	SMEM_PROC_COMM_CHARGING_FUEL_ALERT_CHECK
-};
-
-const char *oem_chg_str[] = {
-	"SMEM_PROC_COMM_CHARGING_CURRENT",
-	"SMEM_PROC_COMM_CHARGING_VF",
-	"SMEM_PROC_COMM_CHARGING_TEMP_ADC",
-	"SMEM_PROC_COMM_CHARGING_TEMP_DEGREE",
-	"SMEM_PROC_COMM_CHARGING_VOLTAGE",
-	"SMEM_PROC_COMM_CHARGING_CHARGE_STATE",
-	"SMEM_PROC_COMM_CHARGING_FUEL_ALERT_CHECK"
-};
-
-static int pm_msm_proc_comm(u32 cmd, u32 *data1, u32 *data2)
-{
-	pr_info("%s,\td1=%s,\td2=%d\n",
-			oem_str[cmd - PCOM_OEM_CHARGING_INFO],
-			oem_chg_str[*data1], *data2);
-	return msm_proc_comm(cmd, data1, data2);
-}
-
-static void bc_read_status(struct msm_battery_info *mi)
-{
-	mi->batt_type = POWER_SUPPLY_TECHNOLOGY_LION;
-}
-
-static int msm_batt_power_get_property(struct power_supply *psy,
-				       enum power_supply_property psp,
-				       union power_supply_propval *val);
-
 static int msm_power_get_property(struct power_supply *psy,
 				  enum power_supply_property psp,
-				  union power_supply_propval *val);
+				  union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (psy->type == POWER_SUPPLY_TYPE_MAINS) {
+			val->intval = msm_batt_info.current_chg_source & AC_CHG
+			    ? 1 : 0;
+		}
+		if (psy->type == POWER_SUPPLY_TYPE_USB) {
+			val->intval = msm_batt_info.current_chg_source & USB_CHG
+			    ? 1 : 0;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
 
 static struct power_supply msm_psy_ac = {
 	.name = "ac",
@@ -766,1895 +313,65 @@
 	.get_property = msm_power_get_property,
 };
 
-static struct power_supply msm_psy_batt = {
-	.name = "battery",
-	.type = POWER_SUPPLY_TYPE_BATTERY,
-	.properties = msm_batt_power_props,
-	.num_properties = ARRAY_SIZE(msm_batt_power_props),
-	.get_property = msm_batt_power_get_property,
-};
-
-static unsigned int charging_start_time;
-
-static int msm_batt_driver_init;
-static int msm_batt_unhandled_interrupt;
-
-#if defined(CONFIG_MACH_KYLE)
-static DEFINE_SPINLOCK(batt_lock);
-int msm_batt_progress;
-#endif
-
-extern void hsusb_chg_connected(enum chg_type chgtype);
-extern void hsusb_chg_vbus_draw(unsigned mA);
-
-
-#ifdef CONFIG_BQ27425_FUEL_GAUGE
-static u32 get_voltage_from_fuelgauge(void);
-static u32 get_level_from_fuelgauge(void);
-static int get_temp_from_fuelgauge(void);
-static int get_current_from_fuelgauge(void);
-static u32 set_reset_fuelgague(void);
-static u32 get_vf_open_from_fuelgauge(void);
-#endif /* CONFIG_BQ27425_FUEL_GAUGE */
-
-
-int batt_restart(void);
-
-
-static ssize_t msm_batt_show_property(struct device *dev,
-		struct device_attribute *attr, char *buf);
-static ssize_t msm_batt_store_property(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count);
-
-static int msm_batt_average_chg_current(int chg_current_adc);
-
-static void msm_batt_check_event(struct work_struct *work);
-static void msm_batt_set_cable_bt(struct work_struct *work);
-static void msm_batt_ovp_bt(struct work_struct *work);
-static void msm_batt_cable_status_update(void);
-
-static void msm_batt_update_psy_status(void);
-
-/* charging absolute time control */
-static void msm_batt_set_charging_start_time(chg_enable_type enable);
-static int msm_batt_is_over_abs_time(void);
-
-static void msm_batt_update_psy_status(void);
-static void msm_batt_chg_en(chg_enable_type enable);
-static DECLARE_WORK(msm_batt_work, msm_batt_check_event);
-static DECLARE_WORK(msm_batt_wq_setcable, msm_batt_set_cable_bt);
-static DECLARE_WORK(msm_batt_wq_ovp, msm_batt_set_cable_bt);
-struct workqueue_struct *msm_batt_cable_wq;
-
-static void batt_timeover(unsigned long arg)
-{
-	pr_info("[BATT] %s: timer !!\n", __func__);
-	queue_work(msm_batt_info.msm_batt_wq, &msm_batt_work);
-	mod_timer(&msm_batt_info.timer, (jiffies + BATT_CHECK_INTERVAL));
-}
-
-void msm_battery_fuel_alert(void)
-{
-	int data1 = SMEM_PROC_COMM_CHARGING_FUEL_ALERT_CHECK;
-	int data2 = 0;
-	int res = pm_msm_proc_comm(PCOM_OEM_CHARGING_INFO, &data1, &data2);
-
-	pr_info("[BATT] fuel_alert cleared:%d\n", data2);
-	/* block bellow until fuel guage modified */
-/*
-	queue_work(msm_batt_info.msm_batt_wq, &msm_batt_work);
-	mod_timer(&msm_batt_info.timer, (jiffies + BATT_CHECK_INTERVAL));
-*/
-}
-
-static void msm_batt_check_event(struct work_struct *work)
-{
-	pr_info("[BATT] %s: work !!\n", __func__);
-	msm_batt_update_psy_status();
-}
-
-#define MSM_BATTERY_ATTR(_name)		\
-{						\
-	.attr = { .name = #_name, .mode = 0664 },	\
-	.show = msm_batt_show_property,		\
-	.store = msm_batt_store_property,		\
-}
-
-static struct device_attribute msm_battery_attrs[] = {
-#if defined(CONFIG_MAX17043_FUELGAUGE) || \
-	defined(CONFIG_MAX17048_FUELGAUGE) || \
-	defined(CONFIG_BQ27425_FUEL_GAUGE)
-	MSM_BATTERY_ATTR(fg_read_soc),
-#endif
-#if defined(CONFIG_BQ27425_FUEL_GAUGE) || \
-	defined(CONFIG_MAX17048_FUELGAUGE)
-	MSM_BATTERY_ATTR(fg_reset_soc),
-#elif (CONFIG_MAX17043_FUELGAUGE)
-	MSM_BATTERY_ATTR(batt_reset_soc),
-#endif	/* CONFIG_BQ27425_FUEL_GAUGE */
-	MSM_BATTERY_ATTR(batt_vol),
-	MSM_BATTERY_ATTR(batt_vol_adc),
-#if defined(CONFIG_MACH_KYLE)
-	MSM_BATTERY_ATTR(batt_reset_soc),
-	MSM_BATTERY_ATTR(batt_vol_aver),
-	MSM_BATTERY_ATTR(auth_battery),
-#endif
-	MSM_BATTERY_ATTR(batt_temp_check),
-	MSM_BATTERY_ATTR(batt_full_check),
-	MSM_BATTERY_ATTR(charging_source),
-	MSM_BATTERY_ATTR(chg_current_adc),
-	MSM_BATTERY_ATTR(batt_temp_adc),
-	MSM_BATTERY_ATTR(batt_temp),
-	MSM_BATTERY_ATTR(batt_temp_aver),
-	MSM_BATTERY_ATTR(batt_fuel_current),
-	MSM_BATTERY_ATTR(batt_vf_adc),
-	MSM_BATTERY_ATTR(batt_vf),
-	MSM_BATTERY_ATTR(batt_type),
-#ifdef __BATT_TEST_DEVICE__
-	MSM_BATTERY_ATTR(batt_temp_test_adc),
-#endif
-	MSM_BATTERY_ATTR(chargingblock_clear),
-	MSM_BATTERY_ATTR(batt_slate_mode),
-	MSM_BATTERY_ATTR(batt_temp_degc),
-	MSM_BATTERY_ATTR(chg_temp_event_check),
-	MSM_BATTERY_ATTR(vt_call),
-	MSM_BATTERY_ATTR(talk_wcdma),
-	MSM_BATTERY_ATTR(talk_gsm),
-	/*MSM_BATTERY_ATTR(data_call),*/
-	MSM_BATTERY_ATTR(off_backlight),
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-	MSM_BATTERY_ATTR(call),
-	MSM_BATTERY_ATTR(video),
-	MSM_BATTERY_ATTR(music),
-	MSM_BATTERY_ATTR(browser),
-	MSM_BATTERY_ATTR(hotspot),
-	MSM_BATTERY_ATTR(camera),
-	MSM_BATTERY_ATTR(data_call),
-	MSM_BATTERY_ATTR(gps),
-	MSM_BATTERY_ATTR(batt_use),
-#endif /*CONFIG_MACH_GEIM*/
-
-};
-
-enum {
-#if defined(CONFIG_MAX17043_FUELGAUGE) || \
-	defined(CONFIG_MAX17048_FUELGAUGE) || \
-	defined(CONFIG_BQ27425_FUEL_GAUGE)
-	FG_READ_SOC = 0,
-#endif
-#if defined(CONFIG_BQ27425_FUEL_GAUGE) || \
-	defined(CONFIG_MAX17048_FUELGAUGE)
-	FG_RESET_SOC,
-#elif (CONFIG_MAX17043_FUELGAUGE)
-	BATT_RESET_SOC,
-#endif	/* CONFIG_BQ27425_FUEL_GAUGE */
-	BATT_VOL,
-	BATT_VOL_ADC,
-#if defined(CONFIG_MACH_KYLE)
-	BATT_RESET_SOC,
-	BATT_VOL_AVER,
-	AUTH_BATTERY,
-#endif
-	BATT_TEMP_CHECK,
-	BATT_FULL_CHECK,
-	CHARGING_SOURCE,
-	CHG_CURRENT_ADC,
-	BATT_TEMP_ADC,
-	BATT_TEMP,
-	BATTERY_TEMP_AVER,
-	BATT_FUEL_CURRENT,
-	BATT_VF_ADC,
-	BATT_VF,
-	BATT_TYPE,
-#ifdef __BATT_TEST_DEVICE__
-	BATT_TEMP_TEST_ADC,
-#endif
-	CHARGINGBLOCK_CLEAR,
-	BATT_SLATE_MODE,
-	BATT_TEMP_DEGC,
-	CHG_TEMP_EVENT_CHECK,
-	VT_CALL,
-	TALK_WCDMA,
-	TALK_GSM,
-	/*DATA_CALL,*/
-	OFF_BACKLIGHT,
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-	BATT_USE_CALL,
-	BATT_USE_VIDEO,
-	BATT_USE_MUSIC,
-	BATT_USE_BROWSER,
-	BATT_USE_HOTSPOT,
-	BATT_USE_CAMERA,
-	BATT_USE_DATA_CALL,
-	BATT_USE_GPS,
-	BATT_USE,
-#endif /*CONFIG_MACH_GEIM*/
-	BATT_TEST_MODE,
+static enum power_supply_property msm_batt_power_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
 };
 
-static int msm_batt_create_attrs(struct device *dev)
-{
-	int i, rc;
-
-	for (i = 0; i < ARRAY_SIZE(msm_battery_attrs); i++)	{
-		rc = device_create_file(dev, &msm_battery_attrs[i]);
-		if (rc)
-			goto failed;
-	}
-	goto succeed;
-
-failed:
-	while (i--)
-		device_remove_file(dev, &msm_battery_attrs[i]);
-
-succeed:
-	return rc;
-}
-
-static void msm_batt_remove_attrs(struct device *dev)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(msm_battery_attrs); i++)
-		device_remove_file(dev, &msm_battery_attrs[i]);
-
-}
-
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-
-void msm_bat_use_timer_func(unsigned long param)
-{
-	struct msm_battery_info *chg = (struct msm_battery_info *)param;
-
-	msm_batt_info.batt_use &= (~msm_batt_info.batt_use_wait);
-	pr_info("[BATT]batt_use timer expired (0x%x)\n",
-			msm_batt_info.batt_use);
-#if 0
-	if (msm_batt_info.batt_status == POWER_SUPPLY_STATUS_CHARGING &&
-		(msm_batt_info.cable_status == CABLE_TYPE_TA)  &&
-		(msm_batt_info.batt_use == 0)) {
-		pr_info("%s[BATT] restart charging for TA\n", __func__);
-		msm_batt_chg_en(true);
-	}
-#endif
-
-}
-
-void msm_bat_use_module(int module, int enable)
-{
-	if (!enable && (msm_batt_info.batt_use
-			== msm_batt_info.batt_use_wait)) {
-		pr_info("/BATT_USE/ ignore duplicated of same event\n");
-		return;
-	}
-
-	del_timer_sync(&msm_batt_info.bat_use_timer);
-	msm_batt_info.batt_use &= (~msm_batt_info.batt_use_wait);
-
-	if (enable) {
-#if 0
-		if (msm_batt_info.batt_status ==
-			POWER_SUPPLY_STATUS_CHARGING &&
-			(msm_batt_info.cable_status == CABLE_TYPE_TA)  &&
-			(msm_batt_info.batt_use == 0)) {
-			pr_info("%s[BATT] restart charging for TA\n", __func__);
-			msm_batt_chg_en(true);
-			}
-#endif
-		msm_batt_info.batt_use_wait = 0;
-		msm_batt_info.batt_use |= module;
-
-		/* debug msg */
-		if (module == USE_CALL)
-			pr_info("/BATT_USE/ use module (call) 0x%x\n",
-				msm_batt_info.batt_use);
-		else if (module == USE_VIDEO)
-			pr_info("/BATT_USE/ use module (video) 0x%x\n",
-				msm_batt_info.batt_use);
-		else if (module == USE_MUSIC)
-			pr_info("/BATT_USE/ use module (music) 0x%x\n",
-				msm_batt_info.batt_use);
-		else if (module == USE_BROWSER)
-			pr_info("/BATT_USE/ use module (browser) 0x%x\n",
-				msm_batt_info.batt_use);
-		else if (module == USE_HOTSPOT)
-			pr_info("/BATT_USE/ use module (hotspot) 0x%x\n",
-				msm_batt_info.batt_use);
-		else if (module == USE_CAMERA)
-			pr_info("/BATT_USE/ use module (camera) 0x%x\n",
-				msm_batt_info.batt_use);
-		else if (module == USE_DATA_CALL)
-			pr_info("/BATT_USE/ use module (data call) 0x%x\n",
-				msm_batt_info.batt_use);
-		else if (module == USE_GPS)
-			pr_info("/BATT_USE/ use module (gps) 0x%x\n",
-				msm_batt_info.batt_use);
-	} else {
-		if (msm_batt_info.batt_use == 0) {
-			pr_info("/BATT_USE/ nothing to clear\n");
-			return;	/* nothing to clear */
-		}
-		msm_batt_info.batt_use_wait = module;
-		mod_timer(&msm_batt_info.bat_use_timer,
-				jiffies + BAT_USE_TIMER_EXPIRE);
-		pr_info("/BATT_USE/ start timer (curr 0x%x, wait 0x%x)\n",
-			msm_batt_info.batt_use, msm_batt_info.batt_use_wait);
-
-	}
-}
-#endif /*CONFIG_MACH_GEIM*/
-
-
-static ssize_t msm_batt_show_property(struct device *dev,
-				       struct device_attribute *attr,
-				       char *buf)
+static int msm_batt_power_get_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       union power_supply_propval *val)
 {
-	int i = 0;
-	const ptrdiff_t offset = attr - msm_battery_attrs;
-	union power_supply_propval value;
-
-	switch (offset) {
-#if defined(CONFIG_MAX17043_FUELGAUGE) || \
-	defined(CONFIG_MAX17048_FUELGAUGE) || \
-	defined(CONFIG_BQ27425_FUEL_GAUGE)
-	case FG_READ_SOC:
-#if defined(CONFIG_MAX17043_FUELGAUGE) ||  defined(CONFIG_MAX17048_FUELGAUGE)
-		if (msm_batt_info.pdata &&
-			msm_batt_info.pdata->psy_fuelgauge &&
-			msm_batt_info.pdata->psy_fuelgauge->get_property) {
-#ifdef CONFIG_MACH_KYLE
-				value.intval = 0;	/*normal soc */
-#endif
-				msm_batt_info.pdata->psy_fuelgauge->get_property(
-					msm_batt_info.pdata->psy_fuelgauge, POWER_SUPPLY_PROP_CAPACITY, &value);
-		}
-		msm_batt_info.batt_capacity = value.intval;
-#endif
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_capacity);
-		break;
-#endif /*CONFIG_BQ27425_FUEL_GAUGE*/
-#ifdef CONFIG_BQ27425_FUEL_GAUGE
-	case FG_RESET_SOC:
-#ifndef CONFIG_MACH_JENA
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			set_reset_fuelgague());
-#endif
-		break;
-#endif /*CONFIG_BQ27425_FUEL_GAUGE*/
-	case BATT_VOL:
-#if defined(CONFIG_MAX17043_FUELGAUGE) ||  defined(CONFIG_MAX17048_FUELGAUGE)
-#if defined(CONFIG_MACH_KYLE)
-	case BATT_VOL_AVER:
-#endif
-		if (msm_batt_info.pdata &&
-			msm_batt_info.pdata->psy_fuelgauge &&
-			msm_batt_info.pdata->psy_fuelgauge->get_property) {
-
-				msm_batt_info.pdata->psy_fuelgauge->get_property(
-					msm_batt_info.pdata->psy_fuelgauge,
-						POWER_SUPPLY_PROP_VOLTAGE_NOW, &value);
-
-				msm_batt_info.batt_voltage_now = value.intval;
-		}
-
-		msm_batt_info.battery_vol = msm_batt_info.batt_voltage_now / 1000;
-#endif
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.battery_vol);
-		break;
-	case BATT_VOL_ADC:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_vol_adc);
-		break;
-#if defined(CONFIG_MACH_KYLE)
-	case AUTH_BATTERY:
-		break;
-#endif
-	case BATT_TEMP_CHECK:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_temp_check);
-		break;
-	case BATT_FULL_CHECK:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_full_check);
-		break;
-	case CHARGING_SOURCE:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.charging_source);
-		break;
-	case CHG_CURRENT_ADC:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.chg_current_adc);
-		break;
-	case BATT_TEMP_ADC:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.battery_temp_adc);
-		break;
-	case BATT_TEMP:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.battery_temp);
-		break;
-	case BATTERY_TEMP_AVER:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_temp_aver);
-		break;
-	case BATT_FUEL_CURRENT:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_fuel_current);
-		break;
-	case BATT_VF_ADC:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_vf_adc);
-		break;
-	case BATT_VF:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_vf_adc);
-		break;
-	case BATT_TYPE:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "SDI_SDI\n");
-		break;
-#ifdef __BATT_TEST_DEVICE__
-	case BATT_TEMP_TEST_ADC:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-				temp_test_adc);
-		break;
-#endif
-	case CHARGINGBLOCK_CLEAR:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.chargingblock_clear);
-		break;
-
-	case BATT_SLATE_MODE:
-		/*FOR SLATE TEST Don't charge by USB*/
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_slate_mode);
-		break;
-	case BATT_TEMP_DEGC:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_temp_degc);
-		break;
-
-	case CHG_TEMP_EVENT_CHECK:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.chg_temp_event_check);
-		break;
-
-	case VT_CALL:
-	case TALK_WCDMA:
-	case TALK_GSM:
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			(msm_batt_info.batt_use & USE_CALL) ? 1 : 0);
-#else
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.talk_gsm);
-#endif /*CONFIG_MACH_GEIM*/
-		break;
-
-/*	case DATA_CALL:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.data_call);
-		break;*/
-
-	case OFF_BACKLIGHT:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.off_backlight);
-		break;
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-	case BATT_USE_CALL:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			(msm_batt_info.batt_use & USE_CALL) ? 1 : 0);
-		break;
-	case BATT_USE_VIDEO:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			(msm_batt_info.batt_use & USE_VIDEO) ? 1 : 0);
-		break;
-	case BATT_USE_MUSIC:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			(msm_batt_info.batt_use & USE_MUSIC) ? 1 : 0);
-		break;
-	case BATT_USE_BROWSER:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			(msm_batt_info.batt_use & USE_BROWSER) ? 1 : 0);
-		break;
-	case BATT_USE_HOTSPOT:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			(msm_batt_info.batt_use & USE_HOTSPOT) ? 1 : 0);
-		break;
-	case BATT_USE_CAMERA:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			(msm_batt_info.batt_use & USE_CAMERA) ? 1 : 0);
-		break;
-	case BATT_USE_DATA_CALL:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			(msm_batt_info.batt_use & USE_DATA_CALL) ? 1 : 0);
-		break;
-	case BATT_USE_GPS:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			(msm_batt_info.batt_use & USE_GPS) ? 1 : 0);
-		break;
-	case BATT_USE:
-		i += scnprintf(buf + i, PAGE_SIZE - i, "%d\n",
-			msm_batt_info.batt_use);
-		break;
-#endif /*CONFIG_MACH_GEIM*/
-
-
-	default:
-		i = -EINVAL;
-	}
-
-	return i;
-}
-
-static ssize_t msm_batt_store_property(struct device *dev,
-				       struct device_attribute *attr,
-				       const char *buf, size_t count)
-{
-	int x = 0;
-	int ret = 0;
-	const ptrdiff_t offset = attr - msm_battery_attrs;
-	union power_supply_propval value;
-
-
-	switch (offset) {
-#if defined(CONFIG_MAX17043_FUELGAUGE) || \
-	defined(CONFIG_MAX17048_FUELGAUGE)
-	case BATT_RESET_SOC:
-#if defined(CONFIG_MACH_KYLE)
-	case FG_RESET_SOC:
-		pr_info("[BATT] %s: RESET SOC!!!\n", __func__);
-#endif
-		if (sscanf(buf, "%d\n", &x) == 1)	{
-			msm_batt_info.pdata->psy_fuelgauge->set_property(
-					msm_batt_info.pdata->psy_fuelgauge,
-					POWER_SUPPLY_PROP_FUELGAUGE_RESET,
-					&value);
-			msm_batt_info.resume_flag = 1;
-			msm_batt_update_psy_status();
-			ret = count;
-		}
-		break;
-#elif CONFIG_BQ27425_FUEL_GAUGE
-	case FG_RESET_SOC:
-#ifdef CONFIG_MACH_JENA
-		if (sscanf(buf, "%d\n", &x) == 1)	{
-			set_reset_fuelgague();
-			msm_batt_info.resume_flag = 1;
-			msm_batt_update_psy_status();
-			ret = count;
-		}
-		break;
-#else
-		if (sscanf(buf, "%d\n", &x) == 1)
-			ret = count;
-		break;
-#endif
-#endif
-#ifdef __BATT_TEST_DEVICE__
-	case BATT_TEMP_TEST_ADC:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			if (x == 0)
-				temp_test_adc = 0;
-			else
-				temp_test_adc = x;
-			ret = count;
-		}
-		break;
-#endif
-	case CHARGINGBLOCK_CLEAR:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			pr_debug("\n[BATT] %s: chargingblock_clear -> "
-				"write 0x%x\n\n", __func__, x);
-			msm_batt_info.chargingblock_clear = x;
-			ret = count;
-		}
-		break;
-
-	case BATT_SLATE_MODE:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_batt_info.batt_slate_mode = x;
-			msm_batt_update_psy_status();
-			ret = count;
-		}
-	    break;
-
-	case CHG_TEMP_EVENT_CHECK:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_batt_info.chg_temp_event_check = x;
-			ret = count;
-		}
-		break;
-
-	case TALK_GSM:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_batt_info.talk_gsm = x;
-			ret = count;
-		}
-		break;
-
-	/*case DATA_CALL:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_batt_info.data_call = x;
-			ret = count;
-		}
-		break;*/
-
-	case OFF_BACKLIGHT:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_batt_info.off_backlight = x;
-			ret = count;
-		}
-		break;
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-	case BATT_USE_CALL:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			/*during_call = x;*/
-			msm_bat_use_module(USE_CALL, x);
-			ret = count;
-		}
-		break;
-	case BATT_USE_VIDEO:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_bat_use_module(USE_VIDEO, x);
-			ret = count;
-		}
-		break;
-	case BATT_USE_MUSIC:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_bat_use_module(USE_MUSIC, x);
-			ret = count;
-		}
-		break;
-	case BATT_USE_BROWSER:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_bat_use_module(USE_BROWSER, x);
-			ret = count;
-		}
-		break;
-	case BATT_USE_HOTSPOT:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_bat_use_module(USE_HOTSPOT, x);
-			ret = count;
-		}
-		break;
-	case BATT_USE_CAMERA:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_bat_use_module(USE_CAMERA, x);
-			ret = count;
-		}
-		break;
-	case BATT_USE_DATA_CALL:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_bat_use_module(USE_DATA_CALL, x);
-			ret = count;
-		}
-		break;
-	case BATT_USE_GPS:
-		if (sscanf(buf, "%d\n", &x) == 1) {
-			msm_bat_use_module(USE_GPS, x);
-			ret = count;
-		}
-		break;
-#endif /*CONFIG_MACH_GEIM*/
-	default:
-		return -EINVAL;
-	}	/* end of switch */
-
-	return ret;
-}
-
-static int msm_power_get_property(struct power_supply *psy,
-				  enum power_supply_property psp,
-				  union power_supply_propval *val)
-{
-	switch (psp) {
-	case POWER_SUPPLY_PROP_ONLINE:
-		if (psy->type == POWER_SUPPLY_TYPE_MAINS)
-			val->intval = msm_batt_info.charging_source & AC_CHG
-			    ? 1 : 0;
-
-		if (psy->type == POWER_SUPPLY_TYPE_USB) {
-			if (msm_batt_info.batt_slate_mode)
-				msm_batt_info.charging_source = NO_CHG;
-
-			val->intval = msm_batt_info.charging_source & USB_CHG
-			    ? 1 : 0;
-		}
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-#ifdef CONFIG_BQ27425_FUEL_GAUGE
-static u32 get_voltage_from_fuelgauge(void)
-{
-	if (is_attached)
-		return bq27425_get_vcell();
-	return 3700;
-}
-
-static u32 get_level_from_fuelgauge(void)
-{
-	if (is_attached)
-		return bq27425_get_soc();
-	return 70;
-}
-
-static int get_temp_from_fuelgauge(void)
-{
-	if (is_attached)
-		return bq27425_get_temperature();
-	return 30;
-}
-
-static int get_current_from_fuelgauge(void)
-{
-	if (is_attached)
-		return bq27425_get_current();
-	return 1;
-}
-
-static u32 set_reset_fuelgague(void)
-{
-	if (is_attached)
-		return bq27425_reset_soc();
-	return 1;
-}
-
-static u32 get_vf_open_from_fuelgauge(void)
-{
-	if (is_attached)
-		return bq27425_get_flag();
-	return 2;
-}
-#endif /* CONFIG_BQ27425_FUEL_GAUGE */
-
-void msm_set_cable(struct msm_battery_callback *ptr,
-			enum cable_type_t status)
-{
-	flush_work_sync(msm_batt_cable_wq);
-	pr_info("%s : [BATT] cable_status(%d)\n", __func__, status);
-	msm_batt_info.cable_status = status;
-	queue_work(msm_batt_cable_wq, &msm_batt_wq_setcable);
-}
-
-static void msm_batt_set_cable_bt(struct work_struct *work)
-{
-	struct msm_battery_info *chg = &msm_batt_info;
-	pr_info("%s : [BATT] cable_status(%d)\n", __func__, chg->cable_status);
-
-	if (chg->cable_status == CABLE_TYPE_UNKNOWN) {
-		msm_batt_info.charging_source = NO_CHG;
-		msm_batt_info.batt_status =
-			POWER_SUPPLY_STATUS_DISCHARGING;
-		msm_batt_info.charger_type =
-			CHARGER_TYPE_NONE;
-		msm_batt_info.batt_full_check = 0;
-		msm_batt_info.batt_recharging = 0;
-		msm_batt_chg_en(false);
-		wake_unlock(&vbus_wake_lock);
-	} else {
-		if (msm_batt_info.batt_health !=
-			POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)
-			msm_batt_info.batt_health =
-			POWER_SUPPLY_HEALTH_GOOD;
-		else
-			goto skip;
-		if (chg->cable_status == CABLE_TYPE_TA) {
-			msm_batt_info.charging_source = AC_CHG;
-			msm_batt_info.charger_type = CHARGER_TYPE_WALL;
-		} else {
-			msm_batt_info.charging_source = USB_CHG;
-			msm_batt_info.charger_type =
-				CHARGER_TYPE_USB_PC;
-		}
-		msm_batt_info.batt_status =
-			POWER_SUPPLY_STATUS_CHARGING;
-		wake_lock(&vbus_wake_lock);
-
-		if (chg->ovp_status == 1) {
-#if defined(CONFIG_MACH_KYLE_I)
-			msm_batt_info.batt_health = 
-				POWER_SUPPLY_HEALTH_OVERVOLTAGE;
-			msm_batt_info.batt_status =
-				POWER_SUPPLY_STATUS_DISCHARGING;
-#else
-			msm_batt_info.batt_status =
-				POWER_SUPPLY_STATUS_NOT_CHARGING;
-#endif
-			msm_batt_info.batt_full_check = 0;
-			msm_batt_info.batt_recharging = 0;
-			if (charging_boot == 1) {
-				msm_batt_info.charging_source = NO_CHG;
-		msm_batt_info.batt_status =
-			POWER_SUPPLY_STATUS_DISCHARGING;
-				msm_batt_info.charger_type =
-					CHARGER_TYPE_NONE;
-			}
-		msm_batt_chg_en(false);
-		} else {
-			msm_batt_chg_en(true);
-		}
-	}
-skip:
-	power_supply_changed(&msm_psy_ac);
-	power_supply_changed(&msm_psy_usb);
-	pr_info("%s : [BATT] batt_status(%d) charger_type(%d) source(%d)\n",
-		__func__, msm_batt_info.batt_status,
-		msm_batt_info.charger_type, msm_batt_info.charging_source);
-	if (set_timer == 1) {
-		pr_info("[BATT] timer setting enable\n");
-		queue_work(msm_batt_info.msm_batt_wq, &msm_batt_work);
-		mod_timer(&msm_batt_info.timer,
-			(jiffies + BATT_CHECK_INTERVAL));
-	}
-}
-
-void msm_set_acc_type(struct msm_battery_callback *ptr,
-				enum acc_type_t status)
-{
-	struct msm_battery_info *chg =
-		container_of(ptr, struct msm_battery_info, callback);
-
-	chg->acc_status = status;
-	pr_info("%s : [BATT] acc_status = %d\n", __func__, chg->acc_status);
-}
-
-void msm_set_ovp_type(struct msm_battery_callback *ptr,
-				enum ovp_type_t status)
-{
-	flush_work_sync(msm_batt_cable_wq);
-	pr_info("[BATT:%s] ovp_status(%d)\n", __func__, status);
-	msm_batt_info.ovp_status = status;
-	queue_work(msm_batt_cable_wq, &msm_batt_wq_ovp);
-}
-
-static void msm_batt_ovp_bt(struct work_struct *work)
-{
-	struct msm_battery_info *chg = &msm_batt_info;
-
-	pr_info("[BATT:%s] ovp_status(%d)\n", __func__, chg->ovp_status);
-
-	if (chg->ovp_status == 1 && msm_batt_info.batt_status ==
-		POWER_SUPPLY_STATUS_CHARGING) {
-		pr_info("%s : [BATT] do ovp protection\n", __func__);
-
-		msm_batt_info.batt_status =
-			POWER_SUPPLY_STATUS_NOT_CHARGING;
-		msm_batt_info.batt_full_check = 0;
-		msm_batt_info.batt_recharging = 0;
-		if (charging_boot == 1) {
-			msm_batt_info.charging_source = NO_CHG;
-			msm_batt_info.batt_status =
-				POWER_SUPPLY_STATUS_DISCHARGING;
-			msm_batt_info.charger_type =
-				CHARGER_TYPE_NONE;
-		}
-		msm_batt_chg_en(false);
-		power_supply_changed(&msm_psy_batt);
-		if (charging_boot == 1) {
-			power_supply_changed(&msm_psy_ac);
-			power_supply_changed(&msm_psy_usb);
-		}
-	} else {
-		if (chg->cable_status != 0
-			&& msm_batt_info.batt_status ==
-				POWER_SUPPLY_STATUS_NOT_CHARGING) {
-			msm_batt_info.batt_status =
-				POWER_SUPPLY_STATUS_CHARGING;
-			msm_batt_chg_en(true);
-			power_supply_changed(&msm_psy_batt);
-		}
-	}
-}
-
-static int msm_batt_power_get_property(struct power_supply *psy,
-				       enum power_supply_property psp,
-				       union power_supply_propval *val)
-{
-	union power_supply_propval value;
-
-	switch (psp) {
-	case POWER_SUPPLY_PROP_STATUS:
-		val->intval = msm_batt_info.batt_status;
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = msm_batt_info.batt_status;
 		break;
 	case POWER_SUPPLY_PROP_HEALTH:
-		val->intval = msm_batt_info.batt_health;
-		break;
-	case POWER_SUPPLY_PROP_PRESENT:
-		val->intval = msm_batt_info.batt_valid;
-		break;
-	case POWER_SUPPLY_PROP_TECHNOLOGY:
-		val->intval = msm_batt_info.batt_technology;
-		break;
-	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
-		val->intval = msm_batt_info.voltage_max_design;
-		break;
-	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
-		val->intval = msm_batt_info.voltage_min_design;
-		break;
-	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-#if defined(CONFIG_MAX17043_FUELGAUGE) ||  defined(CONFIG_MAX17048_FUELGAUGE)
-		if (msm_batt_info.pdata &&
-			msm_batt_info.pdata->psy_fuelgauge &&
-			msm_batt_info.pdata->psy_fuelgauge->get_property) {
-
-				msm_batt_info.pdata->psy_fuelgauge->get_property(
-					msm_batt_info.pdata->psy_fuelgauge, POWER_SUPPLY_PROP_VOLTAGE_NOW, &value);
-
-				msm_batt_info.batt_voltage_now = value.intval;
-		}
-#endif
-		val->intval = msm_batt_info.batt_voltage_now;
-		break;
-	case POWER_SUPPLY_PROP_CAPACITY:
-#if defined(CONFIG_MAX17043_FUELGAUGE) || defined(CONFIG_MAX17048_FUELGAUGE)
-		if (msm_batt_info.pdata &&
-			msm_batt_info.pdata->psy_fuelgauge &&
-			msm_batt_info.pdata->psy_fuelgauge->get_property) {
-#ifdef CONFIG_MACH_KYLE
-				value.intval = 0;	/*normal soc */
-#endif
-				msm_batt_info.pdata->psy_fuelgauge->get_property(
-					msm_batt_info.pdata->psy_fuelgauge, POWER_SUPPLY_PROP_CAPACITY, &value);
-
-				if (msm_batt_info.batt_full_check) {
-					value.intval = 100;
-#ifdef CONFIG_MACH_KYLE
-				} else if (
-		(msm_batt_info.battery_vol < BATT_FULL_PERCENT_VOLTAGE - 50)
-				 && (msm_batt_info.batt_full_check == 0)
-				 && (value.intval == 100)) {
-					value.intval = 99;
-				/*not yet fully charged*/
-				}
-			pmic_gpio_direction_input(PMIC_GPIO_1);
-			if (pmic_gpio_get_value(PMIC_GPIO_1) &&
-				value.intval == 0) {
-				value.intval = 1;
-
-#else
-				} else if ((msm_batt_info.batt_full_check == 0) && (value.intval == 100)) {
-					value.intval = 99;       /*not yet fully charged*/
-
-#endif
-				}
-				if (msm_batt_info.batt_capacity !=  value.intval) {
-					pr_info(
-					"[BATT] %s: Battery level changed ! (%d -> %d)\n",
-					__func__, msm_batt_info.batt_capacity,
-					value.intval);
-				msm_batt_info.batt_capacity =  value.intval;
-			}
-		}
-#endif
-		val->intval = msm_batt_info.batt_capacity;
-		break;
-	case POWER_SUPPLY_PROP_TEMP:
-		val->intval = msm_batt_info.battery_temp;
-		break;
-	case POWER_SUPPLY_PROP_TYPE:
-		val->intval = msm_batt_info.batt_type;
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static void msm_batt_set_alarm(int seconds)
-{
-	ktime_t low_interval = ktime_set(seconds - 10, 0);
-	ktime_t slack = ktime_set(20, 0);
-	ktime_t next;
-
-	pr_info("%s[BATT] set alarm\n", __func__);
-	next = ktime_add(msm_batt_info.last_poll, low_interval);
-	alarm_start_range(&msm_batt_info.alarm, next,
-				ktime_add(next, slack));
-
-}
-
-static void msm_batt_alarm_manager(struct alarm *alarm)
-{
-	queue_work(msm_batt_info.msm_batt_wq, &msm_batt_work);
-}
-
-/*for rev03 version*/
-#ifndef CONFIG_BQ27425_FUEL_GAUGE
-
-int calculate_batt_level(int batt_volt)
-{
-	int scaled_level = 0;
-
-	if (g_chg_en == 0) {
-		chg_polling_cnt = 0;
-		if (batt_volt >= BATT_RECHAR_VOLT) {
-			scaled_level = 100;
-			if ((prev_scaled_level < scaled_level) &&
-				(prev_scaled_level != 0))
-				scaled_level = prev_scaled_level;
-		} else if (batt_volt >=  BATT_LEVEL6_VOLT) {
-			scaled_level = ((batt_volt - BATT_LEVEL6_VOLT+1)*19)
-				/(BATT_RECHAR_VOLT - BATT_LEVEL6_VOLT);
-			scaled_level = scaled_level + 80;
-			if ((prev_scaled_level < scaled_level) &&
-				(prev_scaled_level != 0))
-				scaled_level = prev_scaled_level;
-		} else if (batt_volt >= BATT_LEVEL5_VOLT) {
-			scaled_level = ((batt_volt - BATT_LEVEL5_VOLT)*15)
-				/(BATT_LEVEL6_VOLT - BATT_LEVEL5_VOLT);
-			scaled_level = scaled_level + 65;
-		} else if (batt_volt >= BATT_LEVEL4_VOLT) {/*64% ~ 50%*/
-			scaled_level = ((batt_volt - BATT_LEVEL4_VOLT)*15)
-				/(BATT_LEVEL5_VOLT - BATT_LEVEL4_VOLT);
-			scaled_level = scaled_level + 50;
-		} else if (batt_volt >= BATT_LEVEL3_VOLT) { /*49% ~ 35%*/
-			scaled_level = ((batt_volt - BATT_LEVEL3_VOLT)*15)
-				/(BATT_LEVEL4_VOLT - BATT_LEVEL3_VOLT);
-			scaled_level = scaled_level + 35;
-		} else if (batt_volt >= BATT_LEVEL2_VOLT) {/*34% ~ 20%*/
-			scaled_level = ((batt_volt - BATT_LEVEL2_VOLT)*15)
-				/(BATT_LEVEL3_VOLT - BATT_LEVEL2_VOLT);
-			scaled_level = scaled_level + 20;
-		} else if (batt_volt >= BATT_LEVEL1_VOLT) {/*19% ~ 5%*/
-			scaled_level = ((batt_volt - BATT_LEVEL1_VOLT)*15)
-				/(BATT_LEVEL2_VOLT - BATT_LEVEL1_VOLT);
-			scaled_level = scaled_level + 5;
-		} else if (batt_volt > BATT_LOW_VOLT) {/*4% ~ 1%*/
-			scaled_level = ((batt_volt - BATT_LOW_VOLT)*4)
-				/(BATT_LEVEL1_VOLT - BATT_LOW_VOLT);
-			scaled_level = scaled_level + 1;
-		} else {
-			if (msm_batt_info.charger_type == CHARGER_TYPE_NONE)
-				scaled_level = 0;
-			else
-				scaled_level = 1;
-		}
-
-	} else {
-		if (batt_volt >= BATT_RECHAR_VOLT) {/*100%*/
-			if (prev_scaled_level >= 91) {
-				if (prev_scaled_level >= 91 &&
-					prev_scaled_level < 94)
-					scaled_level = 91;
-				if (prev_scaled_level >= 94 &&
-					prev_scaled_level < 97)
-					scaled_level = 94;
-				if (prev_scaled_level >= 97 &&
-					prev_scaled_level < 100)
-					scaled_level = 97;
-				if (prev_scaled_level == 100)
-					scaled_level = 100;
-
-				if (chg_polling_cnt != 0) {
-					if (scaled_level != 100) {
-						if ((chg_polling_cnt % 60) == 0)
-							scaled_level += 3;
-						if (scaled_level == 100)
-							chg_polling_cnt = 0;
-					}
-				}
-			} else {
-				scaled_level = 91;
-			}
-		} else if (batt_volt >= BATT_LEVEL6_VOLT) {/*99% ~ 80%*/
-			scaled_level = ((batt_volt - BATT_LEVEL6_VOLT+1)*10)
-				/(BATT_RECHAR_VOLT - BATT_LEVEL6_VOLT);
-			scaled_level = scaled_level+80;
-
-			if (prev_scaled_level > scaled_level)
-				scaled_level = prev_scaled_level;
-
-		} else if (batt_volt >= BATT_LEVEL5_VOLT) {
-			scaled_level = ((batt_volt - BATT_LEVEL5_VOLT)*15)
-				/(BATT_LEVEL6_VOLT - BATT_LEVEL5_VOLT);
-			scaled_level = scaled_level+65;
-		} else if (batt_volt >= BATT_LEVEL4_VOLT) {
-			scaled_level = ((batt_volt - BATT_LEVEL4_VOLT)*15)
-				/(BATT_LEVEL5_VOLT - BATT_LEVEL4_VOLT);
-			scaled_level = scaled_level+50;
-		} else if (batt_volt >= BATT_LEVEL3_VOLT) {
-			scaled_level = ((batt_volt - BATT_LEVEL3_VOLT)*15)
-				/(BATT_LEVEL4_VOLT - BATT_LEVEL3_VOLT);
-			scaled_level = scaled_level+35;
-		} else if (batt_volt >= BATT_LEVEL2_VOLT) {
-			scaled_level = ((batt_volt - BATT_LEVEL2_VOLT)*15)
-				/(BATT_LEVEL3_VOLT - BATT_LEVEL2_VOLT);
-			scaled_level = scaled_level+20;
-		} else if (batt_volt >= BATT_LEVEL1_VOLT) {
-			scaled_level = ((batt_volt - BATT_LEVEL1_VOLT)*15)
-				/(BATT_LEVEL2_VOLT - BATT_LEVEL1_VOLT);
-			scaled_level = scaled_level+5;
-		} else if (batt_volt > BATT_LOW_VOLT) {
-			scaled_level = ((batt_volt - BATT_LOW_VOLT)*4)
-				/(BATT_LEVEL1_VOLT - BATT_LOW_VOLT);
-			scaled_level = scaled_level+1;
-		} else {
-			if (msm_batt_info.charger_type == CHARGER_TYPE_NONE)
-				scaled_level = 0;
-			else
-				scaled_level = 1;
-		}
-	}
-
-	pr_info("[Battery] %s : batt_volt %d, scaled_level %d, g_chg_en %d\n",
-		__func__, batt_volt, scaled_level, g_chg_en);
-
-	prev_scaled_level = scaled_level;
-	msm_batt_info.batt_capacity = scaled_level;
-	return 1;
-}
-
-#define BATT_CAL_CHG 150
-
-int calculate_batt_voltage(int vbatt_adc)
-{
-	int batt_volt = 0;
-	static int prevVal;
-	int chg_comp = 0;
-
-#ifdef __CONTROL_CHARGING_SUDDEN_LEVEL_UP__
-	if (!prevVal)
-		prevVal = vbatt_adc;
-
-	if ((vbatt_adc <= BATT_FULL_ADC) && (vbatt_adc > BATT_LEVEL9_ADC))
-		chg_comp = 70;
-	if ((vbatt_adc <= BATT_LEVEL9_ADC) && (vbatt_adc > BATT_LEVEL8_ADC))
-		chg_comp = 210;
-	if ((vbatt_adc <= BATT_LEVEL8_ADC) && (vbatt_adc > BATT_LEVEL7_ADC))
-		chg_comp = 240;
-	if ((vbatt_adc <= BATT_LEVEL7_ADC) && (vbatt_adc > BATT_LEVEL6_ADC))
-		chg_comp = 280;
-	if (vbatt_adc <= BATT_LEVEL6_ADC)
-		chg_comp = 320;
-
-	if (vbatt_adc < BATT_FULL_ADC) {
-		if (g_chg_en) {
-			if (prevVal < (vbatt_adc-chg_comp)) {
-				vbatt_adc = vbatt_adc-chg_comp;
-				pr_info("[Battery] vbatt_adc-BATT_CAL_CHG\n");
-			} else {
-				vbatt_adc = prevVal;
-				pr_info("[Battery] chg_en & prevVal\n");
-			}
-		} else {
-			if (prevVal < vbatt_adc)
-				vbatt_adc = prevVal;
-		}
-	}
-	prevVal = vbatt_adc;
-#endif
-
-	pr_info("[Battery] %s : vbatt_adc %d\n", __func__, vbatt_adc);
-
-	if (vbatt_adc >= BATT_FULL_ADC) {
-		batt_volt = BATT_FULL_VOLT;
-	} else if (vbatt_adc >=  BATT_LEVEL6_ADC) {
-		batt_volt = ((vbatt_adc - BATT_LEVEL6_ADC)*
-			(BATT_FULL_VOLT - BATT_LEVEL6_VOLT))/
-			(BATT_FULL_ADC - BATT_LEVEL6_ADC);
-		batt_volt = batt_volt+BATT_LEVEL6_VOLT;
-	} else if (vbatt_adc >=  BATT_LEVEL5_ADC) {
-		batt_volt = ((vbatt_adc - BATT_LEVEL5_ADC)*
-			(BATT_LEVEL6_VOLT - BATT_LEVEL5_VOLT))/
-			(BATT_LEVEL6_ADC - BATT_LEVEL5_ADC);
-		batt_volt = batt_volt+BATT_LEVEL5_VOLT;
-	} else if (vbatt_adc >=  BATT_LEVEL4_ADC) {
-		batt_volt = ((vbatt_adc - BATT_LEVEL4_ADC)*
-			(BATT_LEVEL5_VOLT - BATT_LEVEL4_VOLT))/
-			(BATT_LEVEL5_ADC - BATT_LEVEL4_ADC);
-		batt_volt = batt_volt+BATT_LEVEL4_VOLT;
-	} else if (vbatt_adc >=  BATT_LEVEL3_ADC) {
-		batt_volt = ((vbatt_adc - BATT_LEVEL3_ADC)*
-			(BATT_LEVEL4_VOLT - BATT_LEVEL3_VOLT))/
-			(BATT_LEVEL4_ADC - BATT_LEVEL3_ADC);
-		batt_volt = batt_volt+BATT_LEVEL3_VOLT;
-	} else if (vbatt_adc >=  BATT_LEVEL2_ADC) {
-		batt_volt = ((vbatt_adc - BATT_LEVEL2_ADC)*
-			(BATT_LEVEL3_VOLT - BATT_LEVEL2_VOLT))/
-			(BATT_LEVEL3_ADC - BATT_LEVEL2_ADC);
-		batt_volt = batt_volt+BATT_LEVEL2_VOLT;
-	} else if (vbatt_adc >=  BATT_LEVEL1_ADC) {
-		batt_volt = ((vbatt_adc - BATT_LEVEL1_ADC)*
-			(BATT_LEVEL2_VOLT - BATT_LEVEL1_VOLT))/
-			(BATT_LEVEL2_ADC - BATT_LEVEL1_ADC);
-		batt_volt = batt_volt+BATT_LEVEL1_VOLT;
-	} else if (vbatt_adc >  BATT_LOW_ADC) {
-		batt_volt = ((vbatt_adc - BATT_LOW_ADC)*
-			(BATT_LEVEL1_VOLT - BATT_LOW_VOLT))/
-			(BATT_LEVEL1_ADC - BATT_LOW_ADC);
-		batt_volt = batt_volt+BATT_LOW_VOLT;
-	} else {
-		batt_volt = BATT_LOW_VOLT;
-	}
-	pr_info("[Battery] %s : vbatt_adc %d & batt_volt %d\n",
-		__func__, vbatt_adc, batt_volt);
-
-	return batt_volt;
-}
-#endif /*CONFIG_MAX17043_FUEL_GAUGE*//*end for rev 03 version for cal voltage*/
-
-static void msm_batt_chg_en(chg_enable_type enable)
-{
-	if (enable == START_CHARGING) {
-		if (msm_batt_info.charging_source == NO_CHG) {
-			pr_err("[BATT] %s: charging_source not defined!\n",
-				__func__);
-			return ;
-		}
-
-		if (msm_batt_info.charging_source & AC_CHG) {
-#if defined(CONFIG_MACH_GEIM)
-			if (msm_batt_info.batt_use == 1) {
-				pr_info("%s[BATT] set event charging current\n",
-					__func__);
-				#ifndef CONFIG_CHARGER_SMB328A
-				hsusb_chg_connected(USB_CHG_TYPE__SDP);
-				hsusb_chg_vbus_draw(500);
-				#else
-				msm_batt_info.pdata->charger_ic->start_charging
-					(msm_batt_info.pdata->charger_ic->chg_curr_ta);
-				#endif
-			} else {
-#endif
-			pr_info("[BATT] %s: Start charging! (AC)\n",
-				__func__);
-				#ifndef CONFIG_CHARGER_SMB328A
-				hsusb_chg_connected
-					(USB_CHG_TYPE__WALLCHARGER);
-#if defined(CONFIG_MACH_AMAZING)
-			hsusb_chg_vbus_draw(100);
-			mdelay(100);
-			hsusb_chg_vbus_draw(200);
-			hsusb_chg_vbus_draw(300);
-			hsusb_chg_vbus_draw(400);
-			hsusb_chg_vbus_draw(500);
-			hsusb_chg_vbus_draw(600);
-#elif defined(CONFIG_MACH_AMAZING_CDMA)
-			hsusb_chg_vbus_draw(100);
-			mdelay(100);
-			hsusb_chg_vbus_draw(200);
-			hsusb_chg_vbus_draw(300);
-			hsusb_chg_vbus_draw(400);
-			hsusb_chg_vbus_draw(500);
-			hsusb_chg_vbus_draw(600);
-			hsusb_chg_vbus_draw(700);
-#else
-			hsusb_chg_vbus_draw(600);
-#endif
-				#else
-				msm_batt_info.pdata->charger_ic->start_charging
-					(msm_batt_info.pdata->charger_ic->chg_curr_ta);
-				#endif
-
-#if defined(CONFIG_MACH_GEIM)
-			}
-#endif
-
-		} else {
-			pr_info("[BATT] %s: Start charging! (USB)\n",
-				__func__);
-			#ifndef CONFIG_CHARGER_SMB328A
-			hsusb_chg_connected(USB_CHG_TYPE__SDP);
-#if defined(CONFIG_MACH_AMAZING)
-			hsusb_chg_vbus_draw(100);
-			mdelay(100);
-			hsusb_chg_vbus_draw(200);
-			hsusb_chg_vbus_draw(300);
-			hsusb_chg_vbus_draw(400);
-			hsusb_chg_vbus_draw(500);
-#elif defined(CONFIG_MACH_AMAZING_CDMA)
-			hsusb_chg_vbus_draw(100);
-			mdelay(100);
-			hsusb_chg_vbus_draw(200);
-			hsusb_chg_vbus_draw(300);
-			hsusb_chg_vbus_draw(400);
-			hsusb_chg_vbus_draw(450);
-#else
-			hsusb_chg_vbus_draw(500);
-#endif
-			#else
-			msm_batt_info.pdata->charger_ic->start_charging
-				(msm_batt_info.pdata->charger_ic->chg_curr_usb);
-			#endif
-		}
-
-		msm_batt_set_charging_start_time(START_CHARGING);
-		pr_info("[BATT] %s: Start charging! (0x%x,"
-			" full_check = %d)\n", __func__,
-			msm_batt_info.charging_source,
-			msm_batt_info.batt_full_check);
-		if (fuel_alert_det) {
-			wake_unlock(&fuel_alert_wake_lock);
-			pr_info("[BATT:%s] fuel alert unlock", __func__);
-		fuel_alert_det = 0;
-		}
-
-	} else {
-		msm_batt_set_charging_start_time(STOP_CHARGING);
-		#ifndef CONFIG_CHARGER_SMB328A
-		if (msm_batt_info.charging_source == NO_CHG)
-			hsusb_chg_connected(USB_CHG_TYPE__INVALID);
-		else
-			hsusb_chg_vbus_draw(0);
-		#else
-			hsusb_chg_connected(USB_CHG_TYPE__INVALID);
-			msm_batt_info.pdata->charger_ic->stop_charging();
-		#endif
-
-		msm_batt_average_chg_current(-1); /*initialize all*/
-
-		pr_info("[BATT] %s: Stop charging! (charging_source = 0x%x, "
-			"full_check = %d)\n", __func__,
-			msm_batt_info.charging_source,
-			msm_batt_info.batt_full_check);
-	}
-}
-
-static int msm_batt_average_chg_current(int chg_current_adc)
-{
-	static int history[AVERAGE_COUNT] = {0};
-	static int count;
-	static int index;
-	int i, sum, max, min, ret;
-
-	if (chg_current_adc == 0)
-		return 0;
-
-	if (chg_current_adc < 0) {
-		count = 0;
-		index = 0;
-		for (i = 0; i < AVERAGE_COUNT; i++)
-			history[i] = 0;
-
-		return 0;
-	}
-
-	if (count == 0)
-		for (i = 0; i < AVERAGE_COUNT; i++)
-			history[i] = chg_current_adc;
-
-	if (index >= count)
-		count++;
-
-	max = min = history[0];
-	sum = 0;
-
-	for (i = 0; i < AVERAGE_COUNT; i++) {
-		if (i == index)
-			history[i] = chg_current_adc;
-
-		if (max < history[i])
-			max = history[i];
-		if (min > history[i])
-			min = history[i];
-
-		sum += history[i];
-	}
-
-	ret = ((sum-max-min) / (AVERAGE_COUNT-2));
-
-	index++;
-
-	if (index == AVERAGE_COUNT) {
-		history[0] = ret;
-		index = 1;
-	}
-
-	pr_debug("[BATT] %s: adc=%d, sum=%d, max=%d, min=%d, ret=%d\n",
-		__func__, chg_current_adc, sum, max, min, ret);
-
-	if (count < AVERAGE_COUNT)
-		return BATT_FULL_CHARGING_CURRENT+50;
-
-#if !defined(CONFIG_MACH_AMAZING_CDMA) && !defined(CONFIG_MACH_KYLE)
-	if (ret != msm_batt_info.chg_current_adc) {
-		msm_batt_info.chg_current_adc = ret;
-		return 1;
-	} else {
-		return 0;
-	}
-
-	msm_batt_info.chg_current_adc = ret;
-#endif
-	return ret;
-}
-
-#ifdef CONFIG_CHARGER_SMB328A
-static void msm_batt_charge_done(struct msm_battery_callback *ptr)
-{
-		pr_info("[BATT] %s: Fully charged\n", __func__);
-		msm_batt_info.batt_full_check = 1;
-		msm_batt_info.batt_recharging = 0;
-		msm_batt_info.batt_status = POWER_SUPPLY_STATUS_FULL;
-		msm_batt_info.batt_capacity = 100;
-		msm_batt_chg_en(STOP_CHARGING);
-}
-#endif
-
-static int msm_batt_check_full_charging(int chg_current_adc)
-{
-	static unsigned int time_after_under_tsh;
-
-	if (chg_current_adc == 0 ||
-		msm_batt_info.charging_source == NO_CHG)
-		return 0;
-
-	if (msm_batt_is_over_abs_time()) {
-		pr_info("[BATT] %s: Fully charged, over abs time! (recharging=%d)\n",
-			__func__, msm_batt_info.batt_recharging);
-		msm_batt_info.batt_full_check = 1;
-		msm_batt_info.batt_recharging = 0;
-		msm_batt_info.batt_status = POWER_SUPPLY_STATUS_FULL;
-		msm_batt_info.batt_capacity = 100;
-		msm_batt_chg_en(STOP_CHARGING);
-		return 1;
-	}
-
-#ifndef CONFIG_CHARGER_SMB328A
-	if (msm_batt_info.battery_vol >= BATT_FULL_CHARGING_VOLTAGE) {
-		if (chg_current_adc < BATT_FULL_CHARGING_CURRENT &&
-			msm_batt_info.batt_capacity >= 99)	{
-			if (time_after_under_tsh == 0) {
-				time_after_under_tsh = jiffies;
-			} else {
-				if (time_after((unsigned long)jiffies,
-					(unsigned long)(time_after_under_tsh
-					+ TOTAL_WATING_TIME))) {
-					pr_info("[BATT] %s: Fully charged, "
-						"(voltage=%d, ICHG=%d)\n",
-						__func__,
-						msm_batt_info.battery_vol,
-						chg_current_adc);
-					msm_batt_info.batt_full_check = 1;
-					msm_batt_info.batt_recharging = 0;
-					msm_batt_info.batt_status =
-						POWER_SUPPLY_STATUS_FULL;
-					msm_batt_info.batt_capacity = 100;
-					time_after_under_tsh = 0;
-					msm_batt_chg_en(STOP_CHARGING);
-					return 1;
-				}
-			}
-		} else {
-			time_after_under_tsh = 0;
-		}
-	}
-#endif
-
-	return 0;
-}
-
-static int msm_batt_check_recharging(void)
-{
-	static unsigned int time_after_vol1, time_after_vol2;
-
-	if ((msm_batt_info.batt_full_check == 0) ||
-		(msm_batt_info.batt_recharging == 1) ||
-		(msm_batt_info.batt_health != POWER_SUPPLY_HEALTH_GOOD)) {
-		time_after_vol1 = 0;
-		time_after_vol2 = 0;
-		return 0;
-	}
-
-	/* check 1st voltage */
-	if (msm_batt_info.battery_vol <= BATT_RECHARGING_VOLTAGE_1) {
-		if (time_after_vol1 == 0)
-			time_after_vol1 = jiffies;
-
-		if (time_after((unsigned long)jiffies,
-			(unsigned long)(time_after_vol1 + TOTAL_WATING_TIME))) {
-			pr_info("[BATT] %s: Recharging ! (voltage1 = %d)\n",
-				__func__, msm_batt_info.battery_vol);
-			msm_batt_info.batt_recharging = 1;
-			msm_batt_chg_en(START_CHARGING);
-#ifndef CONFIG_MACH_KYLE
-			msm_batt_info.batt_status =
-					POWER_SUPPLY_STATUS_CHARGING;
-#endif
-			return 1;
-		}
-	} else {
-		time_after_vol1 = 0;
-	}
-	/* check 2nd voltage */
-	if (msm_batt_info.battery_vol <= BATT_RECHARGING_VOLTAGE_2) {
-		if (time_after_vol2 == 0)
-			time_after_vol2 = jiffies;
-
-		if (time_after((unsigned long)jiffies,
-			(unsigned long)(time_after_vol2 + TOTAL_WATING_TIME))) {
-			pr_info("[BATT] %s: Recharging ! (voltage2 = %d)\n",
-				__func__, msm_batt_info.battery_vol);
-			msm_batt_info.batt_recharging = 1;
-			msm_batt_chg_en(START_CHARGING);
-#ifndef CONFIG_MACH_KYLE
-			msm_batt_info.batt_status =
-					POWER_SUPPLY_STATUS_CHARGING;
-#endif
-			return 1;
-		}
-	} else {
-		time_after_vol2 = 0;
-	}
-
-	return 0;
-}
-#if defined(CONFIG_MAX17043_FUELGAUGE) || defined(CONFIG_MAX17048_FUELGAUGE)
-static int msm_batt_check_level(int battery_level)
-{
-
-	if (msm_batt_info.batt_full_check)
-	{
-		battery_level = 100;
-	}
-#ifdef CONFIG_MACH_KYLE
-	else if ((msm_batt_info.battery_vol < BATT_FULL_PERCENT_VOLTAGE - 50)
-&& (msm_batt_info.batt_full_check == 0) && (battery_level == 100)) {
-		battery_level = 99;	/* not yet fully charged */
-	}
-
-	pmic_gpio_direction_input(PMIC_GPIO_1);
-	if (pmic_gpio_get_value(PMIC_GPIO_1) &&
-		battery_level == 0) {
-		/* not yet alerted low battery (do not power off yet) */
-		battery_level = 1;
-	}
-#else
-	else if ( (msm_batt_info.batt_full_check == 0) && (battery_level == 100) )
-	{
-		battery_level = 99;	/* not yet fully charged */
-	}
-
-#endif
-
-/*
-	if (msm_batt_info.battery_voltage< msm_batt_info.voltage_min_design)
-	{
-		battery_level = 0;
-	}
-*/
-
-	if (msm_batt_info.batt_capacity != battery_level)
-	{
-		pr_info("[BATT] %s: Battery level changed ! (%d -> %d)\n", __func__, msm_batt_info.batt_capacity, battery_level);
-		msm_batt_info.batt_capacity = battery_level;
-		return 1;
-	}
-
-	if (msm_batt_info.battery_voltage <= BATTERY_LOW)
-		return 1;
-
-/*	if (is_alert) // need to check it for low battery
-		return 1;*/	// force update to power off !
-
-	return 0;
-}
-#else
-static int msm_batt_check_level(int battery_level)
-{
-
-
-	if (msm_batt_info.batt_status != POWER_SUPPLY_STATUS_FULL &&
-		(battery_level == 100))
-		battery_level = 99;
-
-	if (msm_batt_info.batt_capacity != battery_level) {
-		if (msm_batt_info.batt_status != POWER_SUPPLY_STATUS_FULL) {
-			if (msm_batt_info.boot_flag) {
-				msm_batt_info.boot_flag = 0;
-			msm_batt_info.batt_capacity = battery_level;
-			} else {
-				if (msm_batt_info.resume_flag) {
-					pr_info("[BATT] resume!\n");
-					if (battery_level == 0)
-						msm_batt_info.batt_capacity
-							= 2;
-					else
-						msm_batt_info.batt_capacity
-							= battery_level;
-					msm_batt_info.resume_flag = 0;
-				} else {
-				if (msm_batt_info.batt_capacity
-					> battery_level) {
-						msm_batt_info.batt_capacity
-							-= 1;
-					}
-				else if (msm_batt_info.batt_capacity
-					< battery_level) {
-					if (battery_level > 10 ||
-					msm_batt_info.batt_status !=
-					POWER_SUPPLY_STATUS_DISCHARGING)
-						msm_batt_info.batt_capacity
-							+= 1;
-					}
-				}
-			}
-		} else {
-			msm_batt_info.batt_capacity = 100;
-		}
-		pr_info("[BATT]AVE_SOC : %d\n", msm_batt_info.batt_capacity);
-	}
-
-	if (msm_batt_info.battery_vol <= BATTERY_LOW)
-		return 1;
-
-	return 0;
-}
-#endif
-static int msm_batt_average_temperature(int temp_adc)
-{
-	static int history[AVERAGE_COUNT] = {0};
-	static int count;
-	static int index;
-	int i, sum, max, min, ret;
-
-	if (temp_adc == 0)
-		return 0;
-
-#ifdef __BATT_TEST_DEVICE__
-		if (temp_test_adc)
-			return temp_test_adc;
-#endif
-
-	if (count == 0)
-		for (i = 0; i < AVERAGE_COUNT; i++)
-			history[i] = temp_adc;
-
-	if (index >= count)
-		count++;
-
-	max = min = history[0];
-	sum = 0;
-
-	for (i = 0; i < AVERAGE_COUNT; i++) {
-		if (i == index)
-			history[i] = temp_adc;
-
-		if (max < history[i])
-			max = history[i];
-		if (min > history[i])
-			min = history[i];
-
-		sum += history[i];
-	}
-
-	ret = ((sum-max-min) / (AVERAGE_COUNT-2));
-
-	index++;
-
-	if (index == AVERAGE_COUNT) {
-		history[0] = ret;
-		index = 1;
-	}
-
-	pr_debug("[BATT] %s: adc=%d, sum=%d, max=%d, min=%d, ret=%d\n",
-		__func__, temp_adc, sum, max, min, ret);
-	return ret;
-}
-
-static int msm_batt_control_temperature(int temp_adc)
-{
-	int prev_health = msm_batt_info.batt_health;
-	int new_health = prev_health;
-	int array_size = 0;
-	int i;
-	int degree;
-
-	int high_block;
-	int high_recover;
-	int low_block;
-	int low_recover;
-
-	union power_supply_propval value;
-
-	static char *health_text[] = {
-		"Unknown", "Good", "Overheat", "Dead", "Over voltage",
-		"Unspecified failure", "Cold",
-	};
-
-#if defined(CONFIG_MACH_AMAZING) | defined(CONFIG_MACH_KYLE)
-		if (temp_adc == 0)
-			return 0;
-#endif
-
-	if (charging_boot == 1) {/*lpm mode*/
-		high_block = BATT_TEMP_HIGH_BLOCK_LPM;
-		high_recover = BATT_TEMP_HIGH_RECOVER_LPM;
-		low_block = BATT_TEMP_LOW_BLOCK_LPM;
-		low_recover = BATT_TEMP_LOW_RECOVER_LPM;
-	} else {
-		high_block = BATT_TEMP_HIGH_BLOCK;
-		high_recover = BATT_TEMP_HIGH_RECOVER;
-		low_block = BATT_TEMP_LOW_BLOCK;
-		low_recover = BATT_TEMP_LOW_RECOVER;
-	}
-
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-	if (msm_batt_info.batt_use && !charging_boot) {
-		pr_info("%s[BATT] set event block\n", __func__);
-		high_block = BATT_TEMP_EVENT_BLOCK;
-	}
-#endif
-
-#ifdef __AUTO_TEMP_TEST__
-	static unsigned int auto_test_start_time;
-	static unsigned int auto_test_interval = (2 * 60*HZ);
-	static int auto_test_mode;
-	/* 0: normal (recover cold), 1: force overheat,
-	  * 2: normal (recover overheat), 3: force cold
-	  */
-
-	if (msm_batt_info.charging_source != NO_CHG) {
-		if (auto_test_start_time == 0)
-			auto_test_start_time = jiffies;
-
-		if (time_after((unsigned long)jiffies, (unsigned long)
-			(auto_test_start_time + auto_test_interval))) {
-			auto_test_mode++;
-			if (auto_test_mode > 3)
-				auto_test_mode = 0;
-			auto_test_start_time = jiffies;
-		}
-		pr_debug("[BATT] auto test mode = %d (0:normal,1:overheat,"
-			"2:normal,3:cold)\n", auto_test_mode);
-
-		if (auto_test_mode == 1) {
-			temp_adc = high_block + 10;
-			msm_batt_info.battery_temp_adc = temp_adc;
-		} else if (auto_test_mode == 3) {
-			temp_adc = high_block - 10;
-			msm_batt_info.battery_temp_adc = temp_adc;
-		}
-	} else {
-		auto_test_start_time = 0;
-		auto_test_mode = 0;
-	}
-#endif
-
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
-	array_size = ARRAY_SIZE(temp_table);
-
-	for (i = 0; i < (array_size - 1); i++) {
-		if (i == 0) {
-			if (temp_adc <= temp_table[0][0]) {
-				degree = temp_table[0][1];
-				break;
-			} else if (temp_adc >= temp_table[array_size-1][0]) {
-				degree = temp_table[array_size-1][1];
-				break;
-			}
-		}
-
-		if (temp_table[i][0] < temp_adc &&
-			temp_table[i+1][0] >= temp_adc) {
-			degree = temp_table[i][1];
-#if defined(CONFIG_MACH_KYLE)	/* temperature split 1 degree unit */
-			if (temp_table[i+1][0] == temp_table[i][0])
-				break;
-
-			degree = temp_table[i+1][1] -
-			((temp_table[i+1][1] - temp_table[i][1])*
-			((temp_table[i+1][0] - temp_adc)*10 /
-			(temp_table[i+1][0] - temp_table[i][0]))) / 10;
-#endif
-		}
-	}
-
-	msm_batt_info.battery_temp = degree * 10;
-#else
-
-	msm_batt_info.battery_temp = temp_adc * 10;
-#endif
-
-	pr_info("%s [BATT] battery_temp : %d temp_adc : %d\n", __func__,
-		msm_batt_info.battery_temp, temp_adc);
-	/*  TODO:  check application */
-
-#if defined(CONFIG_MACH_KYLE)	/* MAX17048 RCOMP Update */
-	value.intval = msm_batt_info.battery_temp / 10;
-	msm_batt_info.pdata->psy_fuelgauge->set_property(
-					msm_batt_info.pdata->psy_fuelgauge,
-					POWER_SUPPLY_PROP_TEMP,
-					&value);
-#endif
-
-	if (prev_health == POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)
-		return 0;
-
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
-	if (temp_adc <= high_block) {
-		if (prev_health != POWER_SUPPLY_HEALTH_OVERHEAT)
-			new_health = POWER_SUPPLY_HEALTH_OVERHEAT;
-	} else if ((temp_adc >= high_recover)
-		&& (temp_adc <= low_recover)) {
-		if ((prev_health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
-			(prev_health == POWER_SUPPLY_HEALTH_COLD))
-			new_health = POWER_SUPPLY_HEALTH_GOOD;
-	} else if (temp_adc >= low_block) {
-		if (prev_health != POWER_SUPPLY_HEALTH_COLD)
-			new_health = POWER_SUPPLY_HEALTH_COLD;
-	}
-	if (msm_batt_info.charging_source == NO_CHG) {
-		if ((low_block > temp_adc)
-			&& (temp_adc > high_block)) {
-			if ((prev_health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
-				(prev_health == POWER_SUPPLY_HEALTH_COLD))
-				new_health = POWER_SUPPLY_HEALTH_GOOD;
-		}
-	}
-#else
-	if (temp_adc >= high_block) {
-		if (prev_health != POWER_SUPPLY_HEALTH_OVERHEAT)
-			new_health = POWER_SUPPLY_HEALTH_OVERHEAT;
-	} else if ((temp_adc <= high_recover)
-		&& (temp_adc >= low_recover)) {
-		if ((prev_health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
-			(prev_health == POWER_SUPPLY_HEALTH_COLD))
-			new_health = POWER_SUPPLY_HEALTH_GOOD;
-	} else if (temp_adc <= low_block) {
-		if (prev_health != POWER_SUPPLY_HEALTH_COLD)
-			new_health = POWER_SUPPLY_HEALTH_COLD;
-	}
-
-	if (msm_batt_info.charging_source == NO_CHG) {
-		if ((low_block < temp_adc)
-			&& (temp_adc < high_block)) {
-			if ((prev_health == POWER_SUPPLY_HEALTH_OVERHEAT) ||
-				(prev_health == POWER_SUPPLY_HEALTH_COLD))
-				new_health = POWER_SUPPLY_HEALTH_GOOD;
-		}
-	}
-#endif
-
-	if (msm_batt_info.chargingblock_clear != 0x0)
-		new_health = POWER_SUPPLY_HEALTH_GOOD;
-
-	if (prev_health != new_health) {
-		if (msm_batt_info.charging_source == NO_CHG) {
-			pr_info("[BATT] %s: Health changed by temperature!"
-				" (ADC = %d, %s-> %s)\n", __func__,
-				temp_adc, health_text[prev_health],
-				health_text[new_health]);
-			msm_batt_info.batt_status =
-				POWER_SUPPLY_STATUS_DISCHARGING;
-		} else {
-			if (new_health != POWER_SUPPLY_HEALTH_GOOD)	{
-				pr_info("[BATT] %s: Block charging! (ADC ="
-					" %d, %s-> %s)\n", __func__,
-					temp_adc, health_text[prev_health],
-					health_text[new_health]);
-				msm_batt_info.batt_status =
-					POWER_SUPPLY_STATUS_NOT_CHARGING;
-				msm_batt_chg_en(STOP_CHARGING);
-			} else {
-				pr_info("[BATT] %s: Recover charging! (ADC"
-					" = %d, %s-> %s)\n", __func__,
-					temp_adc, health_text[prev_health],
-					health_text[new_health]);
-				msm_batt_info.batt_status =
-					POWER_SUPPLY_STATUS_CHARGING;
-				msm_batt_chg_en(START_CHARGING);
-			}
-		}
-
-		msm_batt_info.batt_health = new_health;
-		return 1;
+		val->intval = msm_batt_info.batt_health;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = msm_batt_info.batt_valid;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = msm_batt_info.batt_technology;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = msm_batt_info.voltage_max_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = msm_batt_info.voltage_min_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = msm_batt_info.battery_voltage;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = msm_batt_info.batt_capacity;
+		break;
+	default:
+		return -EINVAL;
 	}
 	return 0;
 }
 
-#ifndef CONFIG_BQ27425_FUEL_GAUGE
+static struct power_supply msm_psy_batt = {
+	.name = "battery",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties = msm_batt_power_props,
+	.num_properties = ARRAY_SIZE(msm_batt_power_props),
+	.get_property = msm_batt_power_get_property,
+};
+
 #ifndef CONFIG_BATTERY_MSM_FAKE
 struct msm_batt_get_volt_ret_data {
-	u32 battery_vol;
+	u32 battery_voltage;
 };
-#endif
+
 static int msm_batt_get_volt_ret_func(struct msm_rpc_client *batt_client,
 				       void *buf, void *data)
 {
@@ -2663,12 +380,11 @@
 	data_ptr = (struct msm_batt_get_volt_ret_data *)data;
 	buf_ptr = (struct msm_batt_get_volt_ret_data *)buf;
 
-	data_ptr->battery_vol = be32_to_cpu(buf_ptr->battery_vol);
+	data_ptr->battery_voltage = be32_to_cpu(buf_ptr->battery_voltage);
 
 	return 0;
 }
 
-
 static u32 msm_batt_get_vbatt_voltage(void)
 {
 	int rc;
@@ -2686,17 +402,15 @@
 		return 0;
 	}
 
-	return rep.battery_vol;
-
+	return rep.battery_voltage;
 }
-#endif /*CONFIG_BQ27425_FUEL_GAUGE*/
 
 #define	be32_to_cpu_self(v)	(v = be32_to_cpu(v))
-#define	be16_to_cpu_self(v)	(v = be16_to_cpu(v))
 
 static int msm_batt_get_batt_chg_status(void)
 {
 	int rc;
+
 	struct rpc_req_batt_chg {
 		struct rpc_request_hdr hdr;
 		u32 more_data;
@@ -2724,33 +438,6 @@
 		be32_to_cpu_self(v1p->battery_level);
 		be32_to_cpu_self(v1p->battery_voltage);
 		be32_to_cpu_self(v1p->battery_temp);
-		be32_to_cpu_self(v1p->battery_temp_adc);
-		be32_to_cpu_self(v1p->chg_current);
-		be32_to_cpu_self(v1p->batt_id);
-		be32_to_cpu_self(v1p->battery_temp_degree);
-
-
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
-	pr_debug("%s: v1p->charger_status= %d\n", __func__,
-			v1p->charger_status);
-	pr_debug("%s: v1p->charger_type= %d\n", __func__,
-			v1p->charger_type);
-	pr_debug("%s: v1p->battery_status= %d\n", __func__,
-			v1p->battery_status);
-	pr_debug("%s: v1p->battery_level= %d\n", __func__,
-			v1p->battery_level);
-	pr_debug("%s: v1p->battery_voltage= %d\n", __func__,
-			v1p->battery_voltage);
-	pr_debug("%s: v1p->battery_temp= %d\n", __func__,
-			v1p->battery_temp);
-	pr_debug("%s: v1p->battery_temp_adc= %d\n", __func__,
-			v1p->battery_temp_adc);
-	pr_debug("%s: v1p->chg_current= %d\n", __func__,
-			v1p->chg_current);
-	pr_debug("%s: v1p->batt_id= %d\n", __func__,
-			v1p->batt_id);
-#endif
-
 	} else {
 		pr_err("%s: No battery/charger data in RPC reply\n", __func__);
 		return -EIO;
@@ -2758,309 +445,211 @@
 
 	return 0;
 }
-#ifdef CONFIG_BQ27425_FUEL_GAUGE
-static int msm_batt_check_vfopen()
-{
-	int ret = 0;
-	if (msm_batt_info.acc_status == ACC_TYPE_JIG)
-		return 1;
-	ret = get_vf_open_from_fuelgauge();
-
-	if (ret == -1) {
-		pr_info("%s[BATT] battery is not attached\n", __func__);
-		msm_batt_info.batt_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-		msm_batt_info.batt_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
-		msm_batt_chg_en(STOP_CHARGING);
-	} else if (ret == 1) {
-		/*pr_info("%s[BATT] battery is attached\n", __func__);*/
-		if (msm_batt_info.batt_health ==
-			POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)
-			msm_batt_info.batt_health = POWER_SUPPLY_HEALTH_GOOD;
-		msm_batt_unhandled_interrupt = 1;
-	} else {
-		pr_info("%s[BATT]fuelgauge is not attached\n", __func__);
-	}
-	return ret;
-}
-#endif
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
-unsigned int pm_msm_proc_comm_charging_curr_adc_get(void)
-{
-	unsigned int data1 = 0, data2 = 0;
-	int r = msm_proc_comm(PCOM_OEM_CHARGING_CURRENT, &data1, &data2);
-	return data1;
-}
-unsigned int pm_msm_proc_comm_temp_adc_get(void)
-{
-	unsigned int data1 = 0, data2 = 0;
-	int r = msm_proc_comm(PCOM_OEM_TEMP_ADC_GET, &data1, &data2);
-	return data1;
-}
-unsigned int pm_msm_proc_comm_vf_adc_get(void)
-{
-	unsigned int data1 = 0, data2 = 0;
-	int r = msm_proc_comm(PCOM_OEM_VF_GET, &data1, &data2);
-	return data1;
-}
-void pole_check(void)
-{
-	unsigned int vf_adc = 0;
-	vf_adc = pm_msm_proc_comm_vf_adc_get();
-	msm_batt_info.batt_vf_adc = vf_adc;
-	pr_info("%s[BATT] vf_adc=%d\n", __func__, vf_adc);
-	if ((vf_adc > 500) && (msm_batt_info.charging_source != NO_CHG)) {
-		if (msm_batt_info.acc_status != ACC_TYPE_JIG) {
-			/* (+)(-) open check */
-			msm_batt_chg_en(STOP_CHARGING);
-			pr_info("[BATT] %s: STOP Charging\n",
-					__func__);
-			pr_info("%s[BATT] battery is attached, but vf is open\n",
-					__func__);
-			msm_batt_info.batt_health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
-			msm_batt_info.batt_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
-		}
-	}
-#if defined(CONFIG_MACH_KYLE)
-	else if ((vf_adc < 500) && (msm_batt_info.charging_source != NO_CHG)) {
-		if (msm_batt_info.batt_health ==
-			POWER_SUPPLY_HEALTH_UNSPEC_FAILURE)
-			msm_batt_info.batt_health = POWER_SUPPLY_HEALTH_GOOD;
-		msm_batt_unhandled_interrupt = 1;
-	}
-#endif
-}
-#endif
 
 static void msm_batt_update_psy_status(void)
 {
+	static u32 unnecessary_event_count;
 	u32	charger_status;
 	u32	charger_type;
 	u32	battery_status;
 	u32	battery_level;
-	u32	battery_vol;
-	int	battery_temp_adc;
-	u32	chg_current_adc;
-
-	int	battery_temp;
-	u32	battery_current;
-
-	union power_supply_propval value;
-
-	u32 status_changed = 0;
-	u32 i = 0;
-	u32 rc;
-
-	static int batt_prestatus;
-	static int flag;
-
-	struct timespec ts;
-
-	/*(+)Open Check*/
-	if (!flag) {
-#if defined(CONFIG_MACH_KYLE)
-		if (!charging_boot) 
-#endif
-		{
-			msm_batt_chg_en(STOP_CHARGING);
-			pr_info("[BATT] %s: STOP Charging\n", __func__);
-			msleep(3);
-			msm_batt_chg_en(START_CHARGING);
-			pr_info("[BATT] %s: Start Charging\n", __func__);
-		}
-		flag = 1;
-	/*Check LPM mode*/
-		if (charging_boot) {
-			msm_batt_info.batt_voltage_now = charging_boot;
-			batt_prestatus = msm_batt_info.batt_status;
-			msm_batt_info.batt_status = 0;
-			}
-	} else {
-		batt_prestatus = msm_batt_info.batt_status;
-	}
+	u32     battery_voltage;
+	u32	battery_temp;
+	struct	power_supply	*supp;
 
-	/* Get general status from CP by RPC */
 	if (msm_batt_get_batt_chg_status())
 		return;
 
-	bc_read_status(&msm_batt_info);
-
-#ifndef CONFIG_BQ27425_FUEL_GAUGE
 	charger_status = rep_batt_chg.v1.charger_status;
 	charger_type = rep_batt_chg.v1.charger_type;
 	battery_status = rep_batt_chg.v1.battery_status;
-#if defined(CONFIG_MAX17043_FUELGAUGE) ||  defined(CONFIG_MAX17048_FUELGAUGE)
-	if (msm_batt_info.pdata &&
-	    msm_batt_info.pdata->psy_fuelgauge &&
-	    msm_batt_info.pdata->psy_fuelgauge->get_property) {
-#ifdef CONFIG_MACH_KYLE
-		value.intval = 0;	/*normal soc */
-#endif
-		msm_batt_info.pdata->psy_fuelgauge->get_property(
-			msm_batt_info.pdata->psy_fuelgauge, POWER_SUPPLY_PROP_CAPACITY, &value);
-			battery_level = value.intval;
-		msm_batt_info.pdata->psy_fuelgauge->get_property(
-			msm_batt_info.pdata->psy_fuelgauge, POWER_SUPPLY_PROP_VOLTAGE_NOW, &value);
-			battery_vol = value.intval;
-
-            }
-	msm_batt_info.batt_voltage_now = battery_vol;
-	msm_batt_info.battery_vol = battery_vol / 1000;
-	msm_batt_info.batt_vol_adc = msm_batt_info.battery_vol;
-
-#else	/* CONFIG_MAX17043_FUEL_GAUGE */
 	battery_level = rep_batt_chg.v1.battery_level;
-	battery_vol = rep_batt_chg.v1.battery_voltage;
-
-	msm_batt_info.battery_vol = msm_batt_get_vbatt_voltage();
-	msm_batt_info.batt_voltage_now = msm_batt_info.battery_vol * 1000;
-	msm_batt_info.batt_vol_adc = msm_batt_info.battery_vol;
+	battery_voltage = rep_batt_chg.v1.battery_voltage;
+	battery_temp = rep_batt_chg.v1.battery_temp;
 
-#endif
-#if defined(CONFIG_MACH_AMAZING_CDMA)
-	battery_temp_adc = pm_msm_proc_comm_temp_adc_get();
-	chg_current_adc = rep_batt_chg.v1.chg_current;
-
-	pr_info(" %s charging current = %d\n", __func__, chg_current_adc);
-#elif defined(CONFIG_MACH_KYLE)
-	battery_temp_adc = pm_msm_proc_comm_temp_adc_get();
-	chg_current_adc = rep_batt_chg.v1.chg_current;
-#else
-	battery_temp  = rep_batt_chg.v1.battery_temp;
-	battery_temp_adc = rep_batt_chg.v1.battery_temp_adc;
-	chg_current_adc = rep_batt_chg.v1.chg_current;
-#endif
+	/* Make correction for battery status */
+	if (battery_status == BATTERY_STATUS_INVALID_v1) {
+		if (msm_batt_info.chg_api_version < CHG_RPC_VER_3_1)
+			battery_status = BATTERY_STATUS_INVALID;
+	}
+
+	if (charger_status == msm_batt_info.charger_status &&
+	    charger_type == msm_batt_info.charger_type &&
+	    battery_status == msm_batt_info.battery_status &&
+	    battery_level == msm_batt_info.battery_level &&
+	    battery_voltage == msm_batt_info.battery_voltage &&
+	    battery_temp == msm_batt_info.battery_temp) {
+		/* Got unnecessary event from Modem PMIC VBATT driver.
+		 * Nothing changed in Battery or charger status.
+		 */
+		unnecessary_event_count++;
+		if ((unnecessary_event_count % 20) == 1)
+			DBG_LIMIT("BATT: same event count = %u\n",
+				 unnecessary_event_count);
+		return;
+	}
 
-	if (charging_boot)
-		msm_batt_info.batt_status = batt_prestatus;
-	battery_temp = msm_batt_info.batt_temp_aver;
-
-	pr_info("%s [BATTERY] Rev03 level : %d, voltage : %d"
-		",temp : %d,  temp_adc : %d\n", __func__, battery_level,
-		msm_batt_info.battery_vol,battery_temp,battery_temp_adc);
-#endif
-#ifdef CONFIG_BQ27425_FUEL_GAUGE
-	battery_level = get_level_from_fuelgauge();
-	/*msm_batt_info.chg_current_adc = battery_level;*/
-	msm_batt_info.battery_vol = get_voltage_from_fuelgauge();
-	msm_batt_info.batt_voltage_now = msm_batt_info.battery_vol * 1000;
-	msm_batt_info.batt_fuel_current = get_current_from_fuelgauge();
-	msm_batt_info.chg_current_adc = msm_batt_info.batt_fuel_current;
-	battery_temp = get_temp_from_fuelgauge();
-	msm_batt_info.batt_temp_aver =  battery_temp * 10;
-
-	msm_batt_info.batt_vol_adc = msm_batt_info.battery_vol;
-
-	if (charging_boot)
-		msm_batt_info.batt_status = batt_prestatus;
-
-	/*chg_current_adc = rep_batt_chg.v1.chg_current;*/
-	battery_temp_adc = rep_batt_chg.v1.battery_temp_adc;
-	/*msm_batt_info.battery_temp = rep_batt_chg.v1.battery_temp_degree;*/
-
-	pr_info("%s [BATTERY] Rev05 level : %d, voltage : %d, temp_ap %d"
-		" temp_cp : %d, current_fg : %d cur_cp :%d status %d"
-		"battery_temp_adc\n",
-		__func__, battery_level, msm_batt_info.battery_vol,
-		msm_batt_info.battery_temp, msm_batt_info.batt_temp_aver,
-		msm_batt_info.batt_fuel_current, chg_current_adc,
-		msm_batt_info.batt_status, battery_temp_adc);
-#endif	/* CONFIG_MAX17043_FUEL_GAUGE */
-
-	if ((msm_batt_info.batt_status == POWER_SUPPLY_STATUS_CHARGING) ||
-		(msm_batt_info.batt_recharging == 1)) {
-		if (chg_current_adc < 30 || chg_current_adc > 900)
-			chg_current_adc = 0;
-	} else{
-			chg_current_adc = 0;
-	}
-#ifdef CONFIG_BQ27425_FUEL_GAUGE
-	if (msm_batt_info.cable_status != CABLE_TYPE_UNKNOWN)
-		msm_batt_check_vfopen();
-#endif
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
-	if (msm_batt_info.cable_status != CABLE_TYPE_UNKNOWN)
-		pole_check();
-#endif
-	/* check temperature */
+	unnecessary_event_count = 0;
 
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
-	msm_batt_info.battery_temp_adc =
-		msm_batt_average_temperature(battery_temp_adc);
-	msm_batt_control_temperature(msm_batt_info.battery_temp_adc);
-#else
-	msm_batt_info.battery_temp_adc =
-		msm_batt_average_temperature(battery_temp_adc);
-	msm_batt_control_temperature(battery_temp);
-#endif
+	DBG_LIMIT("BATT: rcvd: %d, %d, %d, %d; %d, %d\n",
+		 charger_status, charger_type, battery_status,
+		 battery_level, battery_voltage, battery_temp);
+
+	if (battery_status == BATTERY_STATUS_INVALID &&
+	    battery_level != BATTERY_LEVEL_INVALID) {
+		DBG_LIMIT("BATT: change status(%d) to (%d) for level=%d\n",
+			 battery_status, BATTERY_STATUS_GOOD, battery_level);
+		battery_status = BATTERY_STATUS_GOOD;
+	}
+
+	if (msm_batt_info.charger_type != charger_type) {
+		if (charger_type == CHARGER_TYPE_USB_WALL ||
+		    charger_type == CHARGER_TYPE_USB_PC ||
+		    charger_type == CHARGER_TYPE_USB_CARKIT) {
+			DBG_LIMIT("BATT: USB charger plugged in\n");
+			msm_batt_info.current_chg_source = USB_CHG;
+			supp = &msm_psy_usb;
+		} else if (charger_type == CHARGER_TYPE_WALL) {
+			DBG_LIMIT("BATT: AC Wall changer plugged in\n");
+			msm_batt_info.current_chg_source = AC_CHG;
+			supp = &msm_psy_ac;
+		} else {
+			if (msm_batt_info.current_chg_source & AC_CHG)
+				DBG_LIMIT("BATT: AC Wall charger removed\n");
+			else if (msm_batt_info.current_chg_source & USB_CHG)
+				DBG_LIMIT("BATT: USB charger removed\n");
+			else
+				DBG_LIMIT("BATT: No charger present\n");
+			msm_batt_info.current_chg_source = 0;
+			supp = &msm_psy_batt;
+
+			/* Correct charger status */
+			if (charger_status != CHARGER_STATUS_INVALID) {
+				DBG_LIMIT("BATT: No charging!\n");
+				charger_status = CHARGER_STATUS_INVALID;
+				msm_batt_info.batt_status =
+					POWER_SUPPLY_STATUS_NOT_CHARGING;
+			}
+		}
+	} else
+		supp = NULL;
 
-	/* check full charging */
-	/*msm_batt_average_chg_current(msm_batt_info.batt_fuel_current);*/
-#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
-	msm_batt_info.chg_current_adc = msm_batt_average_chg_current(chg_current_adc);
-#endif
-	if (msm_batt_info.cable_status != CABLE_TYPE_UNKNOWN ||
-		msm_batt_info.charger_type != CHARGER_TYPE_NONE)
-		msm_batt_check_full_charging(msm_batt_info.chg_current_adc);
-
-	/* check recharging */
-	msm_batt_check_recharging();
-
-#ifdef CONFIG_BQ27425_FUEL_GAUGE
-		msm_batt_check_level(battery_level);
-#elif  CONFIG_MAX17043_FUELGAUGE
-                msm_batt_check_level(battery_level);
-#elif CONFIG_MAX17048_FUELGAUGE
-	msm_batt_check_level(battery_level);
-#else
-	        calculate_batt_level(msm_batt_info.battery_vol);
-#endif
+	if (msm_batt_info.charger_status != charger_status) {
+		if (charger_status == CHARGER_STATUS_GOOD ||
+		    charger_status == CHARGER_STATUS_WEAK) {
+			if (msm_batt_info.current_chg_source) {
+				DBG_LIMIT("BATT: Charging.\n");
+				msm_batt_info.batt_status =
+					POWER_SUPPLY_STATUS_CHARGING;
 
-	/* temperature health for power off charging */
-	if (msm_batt_info.batt_health == POWER_SUPPLY_HEALTH_GOOD)
-		msm_batt_info.batt_temp_check = 1;
-	else
-		msm_batt_info.batt_temp_check = 0;
-	/* recheck battery status*/
-	if ((msm_batt_info.cable_status == CABLE_TYPE_UNKNOWN ||
-		msm_batt_info.charger_type == CHARGER_TYPE_NONE) &&
-		(msm_batt_info.batt_status ==
-			POWER_SUPPLY_STATUS_CHARGING ||
-		msm_batt_info.batt_status ==
-			POWER_SUPPLY_STATUS_FULL)) {
-		msm_batt_info.batt_status =
-			POWER_SUPPLY_STATUS_DISCHARGING;
-		pr_info("[BATT]forced change charging mode\n");
+				/* Correct when supp==NULL */
+				if (msm_batt_info.current_chg_source & AC_CHG)
+					supp = &msm_psy_ac;
+				else
+					supp = &msm_psy_usb;
+			}
+		} else {
+			DBG_LIMIT("BATT: No charging.\n");
+			msm_batt_info.batt_status =
+				POWER_SUPPLY_STATUS_NOT_CHARGING;
+			supp = &msm_psy_batt;
+		}
+	} else {
+		/* Correct charger status */
+		if (charger_type != CHARGER_TYPE_INVALID &&
+		    charger_status == CHARGER_STATUS_GOOD) {
+			DBG_LIMIT("BATT: In charging\n");
+			msm_batt_info.batt_status =
+				POWER_SUPPLY_STATUS_CHARGING;
 		}
+	}
 
-#ifndef DEBUG
-	if (msm_batt_info.charging_source != NO_CHG) {
-#endif
-		#if !defined(CONFIG_MACH_KYLE)
-		pr_info("[BATT] %s: charger_status= %d, charger_type= %d,"
-			"battery_status=%d, battery_temp_adc=%d,"
-			"chg_current=%d, battery_temp=%d, health %d, "
-			"status = %d\n",
-			__func__, msm_batt_info.charger_status,
-			msm_batt_info.charger_type,
-			msm_batt_info.battery_status,
-			msm_batt_info.battery_temp_adc,
-			msm_batt_info.chg_current_adc,
-			msm_batt_info.battery_temp_adc,
-			msm_batt_info.batt_health,
-			msm_batt_info.batt_status);
-		#endif
-#ifndef DEBUG
+	/* Correct battery voltage and status */
+	if (!battery_voltage) {
+		if (charger_status == CHARGER_STATUS_INVALID) {
+			DBG_LIMIT("BATT: Read VBATT\n");
+			battery_voltage = msm_batt_get_vbatt_voltage();
+		} else
+			/* Use previous */
+			battery_voltage = msm_batt_info.battery_voltage;
+	}
+	if (battery_status == BATTERY_STATUS_INVALID) {
+		if (battery_voltage >= msm_batt_info.voltage_min_design &&
+		    battery_voltage <= msm_batt_info.voltage_max_design) {
+			DBG_LIMIT("BATT: Battery valid\n");
+			msm_batt_info.batt_valid = 1;
+			battery_status = BATTERY_STATUS_GOOD;
+		}
 	}
-#endif
 
-	power_supply_changed(&msm_psy_batt);
+	if (msm_batt_info.battery_status != battery_status) {
+		if (battery_status != BATTERY_STATUS_INVALID) {
+			msm_batt_info.batt_valid = 1;
+
+			if (battery_status == BATTERY_STATUS_BAD) {
+				DBG_LIMIT("BATT: Battery bad.\n");
+				msm_batt_info.batt_health =
+					POWER_SUPPLY_HEALTH_DEAD;
+			} else if (battery_status == BATTERY_STATUS_BAD_TEMP) {
+				DBG_LIMIT("BATT: Battery overheat.\n");
+				msm_batt_info.batt_health =
+					POWER_SUPPLY_HEALTH_OVERHEAT;
+			} else {
+				DBG_LIMIT("BATT: Battery good.\n");
+				msm_batt_info.batt_health =
+					POWER_SUPPLY_HEALTH_GOOD;
+			}
+		} else {
+			msm_batt_info.batt_valid = 0;
+			DBG_LIMIT("BATT: Battery invalid.\n");
+			msm_batt_info.batt_health = POWER_SUPPLY_HEALTH_UNKNOWN;
+		}
 
-	msm_batt_info.last_poll = alarm_get_elapsed_realtime();
-	ts = ktime_to_timespec(msm_batt_info.last_poll);
+		if (msm_batt_info.batt_status != POWER_SUPPLY_STATUS_CHARGING) {
+			if (battery_status == BATTERY_STATUS_INVALID) {
+				DBG_LIMIT("BATT: Battery -> unknown\n");
+				msm_batt_info.batt_status =
+					POWER_SUPPLY_STATUS_UNKNOWN;
+			} else {
+				DBG_LIMIT("BATT: Battery -> discharging\n");
+				msm_batt_info.batt_status =
+					POWER_SUPPLY_STATUS_DISCHARGING;
+			}
+		}
 
-	if (msm_batt_unhandled_interrupt)
-		msm_batt_unhandled_interrupt = 0;
+		if (!supp) {
+			if (msm_batt_info.current_chg_source) {
+				if (msm_batt_info.current_chg_source & AC_CHG)
+					supp = &msm_psy_ac;
+				else
+					supp = &msm_psy_usb;
+			} else
+				supp = &msm_psy_batt;
+		}
+	}
 
+	msm_batt_info.charger_status 	= charger_status;
+	msm_batt_info.charger_type 	= charger_type;
+	msm_batt_info.battery_status 	= battery_status;
+	msm_batt_info.battery_level 	= battery_level;
+	msm_batt_info.battery_temp 	= battery_temp;
+
+	if (msm_batt_info.battery_voltage != battery_voltage) {
+		msm_batt_info.battery_voltage  	= battery_voltage;
+		msm_batt_info.batt_capacity =
+			msm_batt_info.calculate_capacity(battery_voltage);
+		DBG_LIMIT("BATT: voltage = %u mV [capacity = %d%%]\n",
+			 battery_voltage, msm_batt_info.batt_capacity);
+
+		if (!supp)
+			supp = msm_batt_info.current_ps;
+	}
+
+	if (supp) {
+		msm_batt_info.current_ps = supp;
+		DBG_LIMIT("BATT: Supply = %s\n", supp->name);
+		power_supply_changed(supp);
+	}
 }
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
@@ -3182,7 +771,6 @@
 			       __func__, rc);
 			return;
 		}
-		msm_batt_info.suspend_status = 1;
 	} else {
 		pr_err("%s: ERROR. invalid batt_handle\n", __func__);
 		return;
@@ -3207,12 +795,12 @@
 			       __func__, rc);
 			return;
 		}
-		msm_batt_info.suspend_status = 0;
 	} else {
 		pr_err("%s: ERROR. invalid batt_handle\n", __func__);
 		return;
 	}
 
+	msm_batt_update_psy_status();
 	pr_debug("%s: exit\n", __func__);
 }
 #endif
@@ -3369,30 +957,30 @@
 
 		return size;
 	} else {
-	*req = cpu_to_be32(batt_reg_req->desired_batt_voltage);
-	size += sizeof(u32);
-	req++;
+		*req = cpu_to_be32(batt_reg_req->desired_batt_voltage);
+		size += sizeof(u32);
+		req++;
 
-	*req = cpu_to_be32(batt_reg_req->voltage_direction);
-	size += sizeof(u32);
-	req++;
+		*req = cpu_to_be32(batt_reg_req->voltage_direction);
+		size += sizeof(u32);
+		req++;
 
-	*req = cpu_to_be32(batt_reg_req->batt_cb_id);
-	size += sizeof(u32);
-	req++;
+		*req = cpu_to_be32(batt_reg_req->batt_cb_id);
+		size += sizeof(u32);
+		req++;
 
-	*req = cpu_to_be32(batt_reg_req->cb_data);
-	size += sizeof(u32);
-	req++;
+		*req = cpu_to_be32(batt_reg_req->cb_data);
+		size += sizeof(u32);
+		req++;
 
-	*req = cpu_to_be32(batt_reg_req->more_data);
-	size += sizeof(u32);
-	req++;
+		*req = cpu_to_be32(batt_reg_req->more_data);
+		size += sizeof(u32);
+		req++;
 
-	*req = cpu_to_be32(batt_reg_req->batt_error);
-	size += sizeof(u32);
+		*req = cpu_to_be32(batt_reg_req->batt_error);
+		size += sizeof(u32);
 
-	return size;
+		return size;
 	}
 
 }
@@ -3414,13 +1002,12 @@
 		data_ptr_4_1->err = be32_to_cpu(buf_ptr_4_1->err);
 		return 0;
 	} else {
-	data_ptr = (struct batt_client_registration_rep *)data;
-	buf_ptr = (struct batt_client_registration_rep *)buf;
-
-	data_ptr->batt_handle = be32_to_cpu(buf_ptr->batt_handle);
+		data_ptr = (struct batt_client_registration_rep *)data;
+		buf_ptr = (struct batt_client_registration_rep *)buf;
 
-	return 0;
-}
+		data_ptr->batt_handle = be32_to_cpu(buf_ptr->batt_handle);
+		return 0;
+	}
 }
 
 static int msm_batt_register(u32 desired_batt_voltage,
@@ -3442,12 +1029,12 @@
 		batt_reg_req_4_1.batt_error = 1;
 		request = &batt_reg_req_4_1;
 	} else {
-	batt_reg_req.desired_batt_voltage = desired_batt_voltage;
-	batt_reg_req.voltage_direction = voltage_direction;
-	batt_reg_req.batt_cb_id = batt_cb_id;
-	batt_reg_req.cb_data = cb_data;
-	batt_reg_req.more_data = 1;
-	batt_reg_req.batt_error = 0;
+		batt_reg_req.desired_batt_voltage = desired_batt_voltage;
+		batt_reg_req.voltage_direction = voltage_direction;
+		batt_reg_req.batt_cb_id = batt_cb_id;
+		batt_reg_req.cb_data = cb_data;
+		batt_reg_req.more_data = 1;
+		batt_reg_req.batt_error = 0;
 		request = &batt_reg_req;
 	}
 
@@ -3476,11 +1063,8 @@
 			return -EIO;
 		}
 		msm_batt_info.batt_handle = batt_reg_rep_4_1.batt_handle;
-	} else {
+	} else
 		msm_batt_info.batt_handle = batt_reg_rep.batt_handle;
-	}
-
-	pr_debug("%s: got handle = %d\n", __func__, msm_batt_info.batt_handle);
 
 	return 0;
 }
@@ -3547,81 +1131,13 @@
 
 	return 0;
 }
+#endif  /* CONFIG_BATTERY_MSM_FAKE */
 
-#ifdef CONFIG_PM
-static int msm_batt_suspend(struct platform_device *pdev,
-		pm_message_t state)
-{
-	pr_debug("[BATT] %s\n", __func__);
-	if (msm_batt_info.batt_capacity < 5) {
-		msm_batt_set_alarm(ALARM_POLLING_TIME_SHORT);
-		pr_info("%s[BATT] set alarm for long time\n", __func__);
-	} else {
-		msm_batt_set_alarm(ALARM_POLLING_TIME_LONG);
-		pr_info("%s[BATT] set alarm for shor time\n", __func__);
-	}
-	del_timer_sync(&msm_batt_info.timer);
-
-	return 0;
-}
-
-static int msm_batt_resume(struct platform_device *pdev)
-{
-	pr_debug("[BATT] %s\n", __func__);
-	msm_batt_info.resume_flag = 1;
-
-	pr_info("[BATT] set alarm for resume\n");
-
-	queue_work(msm_batt_info.msm_batt_wq, &msm_batt_work);
-	mod_timer(&msm_batt_info.timer, (jiffies + BATT_CHECK_INTERVAL));
-
-	return 0;
-}
-#else
-#define msm_batt_suspend NULL
-#define msm_batt_resume NULL
-#endif
-
-int batt_restart(void)
-{
-	if (msm_batt_driver_init) {
-		del_timer_sync(&msm_batt_info.timer);
-		queue_work(msm_batt_info.msm_batt_wq, &msm_batt_work);
-		mod_timer(&msm_batt_info.timer,
-			(jiffies + BATT_CHECK_INTERVAL));
-	} else {
-		pr_err("[BATT] %s: Battery driver is not ready !!\n",
-				__func__);
-		msm_batt_unhandled_interrupt = 1;
-	}
-
-	pr_info("[BATT] %s: Bat restart is complite\n", __func__);
-
-	return 0;
-}
-EXPORT_SYMBOL(batt_restart);
-
-/*End from Bat driver */
 static int msm_batt_cleanup(void)
 {
 	int rc = 0;
 
-#if defined(CONFIG_MACH_KYLE)
-	spin_lock(&batt_lock);
-	msm_batt_progress = 1;
-#endif
-
-	pr_info("[BATT] %s\n", __func__);
-
-	if (msm_batt_info.pdata->register_callbacks)
-		msm_batt_info.pdata->register_callbacks(NULL);
-
-	alarm_cancel(&msm_batt_info.alarm);
-	del_timer_sync(&msm_batt_info.timer);
-	destroy_workqueue(msm_batt_cable_wq);
-	destroy_workqueue(msm_batt_info.msm_batt_wq);
-	msm_batt_remove_attrs(msm_psy_batt.dev);
-
+#ifndef CONFIG_BATTERY_MSM_FAKE
 	if (msm_batt_info.batt_handle != INVALID_BATT_HANDLE) {
 
 		rc = msm_batt_deregister(msm_batt_info.batt_handle);
@@ -3634,6 +1150,7 @@
 
 	if (msm_batt_info.batt_client)
 		msm_rpc_unregister_client(msm_batt_info.batt_client);
+#endif  /* CONFIG_BATTERY_MSM_FAKE */
 
 	if (msm_batt_info.msm_psy_ac)
 		power_supply_unregister(msm_batt_info.msm_psy_ac);
@@ -3643,6 +1160,7 @@
 	if (msm_batt_info.msm_psy_batt)
 		power_supply_unregister(msm_batt_info.msm_psy_batt);
 
+#ifndef CONFIG_BATTERY_MSM_FAKE
 	if (msm_batt_info.chg_ep) {
 		rc = msm_rpc_close(msm_batt_info.chg_ep);
 		if (rc < 0) {
@@ -3655,15 +1173,25 @@
 	if (msm_batt_info.early_suspend.suspend == msm_batt_early_suspend)
 		unregister_early_suspend(&msm_batt_info.early_suspend);
 #endif
-
-#if defined(CONFIG_MACH_KYLE)
-	spin_unlock(&batt_lock);
-	msm_batt_progress = 0;
 #endif
-
 	return rc;
 }
 
+static u32 msm_batt_capacity(u32 current_voltage)
+{
+	u32 low_voltage = msm_batt_info.voltage_min_design;
+	u32 high_voltage = msm_batt_info.voltage_max_design;
+
+	if (current_voltage <= low_voltage)
+		return 0;
+	else if (current_voltage >= high_voltage)
+		return 100;
+	else
+		return (current_voltage - low_voltage) * 100
+			/ (high_voltage - low_voltage);
+}
+
+#ifndef CONFIG_BATTERY_MSM_FAKE
 int msm_batt_get_charger_api_version(void)
 {
 	int rc ;
@@ -3789,53 +1317,18 @@
 	if (rc)
 		pr_err("%s: FAIL: sending reply. rc=%d\n", __func__, rc);
 
-	if (accept_status == RPC_ACCEPTSTAT_SUCCESS && set_timer == 1) {
-		pr_info("[BATT] %s: RPC_ACCEPTSTAT_SUCCESS !!\n", __func__);
-		del_timer_sync(&msm_batt_info.timer);
-		queue_work(msm_batt_info.msm_batt_wq, &msm_batt_work);
-		mod_timer(&msm_batt_info.timer,
-			(jiffies + BATT_CHECK_INTERVAL));
-	}
+	if (accept_status == RPC_ACCEPTSTAT_SUCCESS)
+		msm_batt_update_psy_status();
 
 	return rc;
 }
-
-static void msm_batt_set_charging_start_time(chg_enable_type enable)
-{
-	if (enable == START_CHARGING)
-		charging_start_time = jiffies;
-	else
-		charging_start_time = 0;
-}
-
-static int msm_batt_is_over_abs_time(void)
-{
-	unsigned int total_time;
-
-	if (charging_start_time == 0)
-		return 0;
-
-	if (msm_batt_info.batt_full_check == 1)
-		total_time = TOTAL_RECHARGING_TIME;
-	else
-		total_time = TOTAL_CHARGING_TIME;
-
-	if (time_after((unsigned long)jiffies,
-		(unsigned long)(charging_start_time + total_time))) {
-		pr_debug("[BATT] %s: abs time is over !!\n", __func__);
-		return 1;
-	} else {
-		return 0;
-	}
-}
+#endif  /* CONFIG_BATTERY_MSM_FAKE */
 
 static int __devinit msm_batt_probe(struct platform_device *pdev)
 {
 	int rc;
 	struct msm_psy_batt_pdata *pdata = pdev->dev.platform_data;
 
-	msm_batt_info.pdata = pdata->charger;
-
 	if (pdev->id != -1) {
 		dev_err(&pdev->dev,
 			"%s: MSM chipsets Can only support one"
@@ -3843,9 +1336,11 @@
 		return -EINVAL;
 	}
 
-	msm_batt_info.batt_slate_mode = 0;
-
+#ifndef CONFIG_BATTERY_MSM_FAKE
 	if (pdata->avail_chg_sources & AC_CHG) {
+#else
+	{
+#endif
 		rc = power_supply_register(&pdev->dev, &msm_psy_ac);
 		if (rc < 0) {
 			dev_err(&pdev->dev,
@@ -3885,6 +1380,7 @@
 	msm_batt_info.voltage_fail_safe  = pdata->voltage_fail_safe;
 
 	msm_batt_info.batt_technology = pdata->batt_technology;
+	msm_batt_info.calculate_capacity = pdata->calculate_capacity;
 
 	if (!msm_batt_info.voltage_min_design)
 		msm_batt_info.voltage_min_design = BATTERY_LOW;
@@ -3896,6 +1392,9 @@
 	if (msm_batt_info.batt_technology == POWER_SUPPLY_TECHNOLOGY_UNKNOWN)
 		msm_batt_info.batt_technology = POWER_SUPPLY_TECHNOLOGY_LION;
 
+	if (!msm_batt_info.calculate_capacity)
+		msm_batt_info.calculate_capacity = msm_batt_capacity;
+
 	rc = power_supply_register(&pdev->dev, &msm_psy_batt);
 	if (rc < 0) {
 		dev_err(&pdev->dev, "%s: power_supply_register failed"
@@ -3905,6 +1404,7 @@
 	}
 	msm_batt_info.msm_psy_batt = &msm_psy_batt;
 
+#ifndef CONFIG_BATTERY_MSM_FAKE
 	rc = msm_batt_register(BATTERY_LOW, BATTERY_ALL_ACTIVITY,
 			       BATTERY_CB_ID_ALL_ACTIV, BATTERY_ALL_ACTIVITY);
 	if (rc < 0) {
@@ -3924,100 +1424,17 @@
 		return rc;
 	}
 
-	rc = msm_batt_create_attrs(msm_psy_batt.dev);
-
-	if (rc < 0) {
-		dev_err(&pdev->dev,
-			"%s: msm_batt_create_attrs failed rc = %d\n",
-			__func__, rc);
-		msm_batt_cleanup();
-		return rc;
-	}
-
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	msm_batt_info.early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
 	msm_batt_info.early_suspend.suspend = msm_batt_early_suspend;
 	msm_batt_info.early_suspend.resume = msm_batt_late_resume;
 	register_early_suspend(&msm_batt_info.early_suspend);
 #endif
+	msm_batt_update_psy_status();
 
-	setup_timer(&msm_batt_info.timer, batt_timeover, 0);
-	/*mod_timer(&msm_batt_info.timer, (jiffies + BATT_CHECK_INTERVAL));*/
-#if defined(CONFIG_MACH_GEIM) || defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-	setup_timer(&msm_batt_info.bat_use_timer, msm_bat_use_timer_func, 0);
-#endif /*CONFIG_MACH_GEIM*/
-	wake_lock_init(&vbus_wake_lock, WAKE_LOCK_SUSPEND, "vbus_wake_lock");
-	wake_lock_init(&fuel_alert_wake_lock,
-			WAKE_LOCK_SUSPEND, "fuel_alert_wake_lock");
-
-	if (charging_boot == 1) {
-		wake_lock_init(&lpm_wake_lock, WAKE_LOCK_SUSPEND,
-			"lpm_wake_lock");
-		wake_lock(&lpm_wake_lock);
-	}
-
-#ifdef CONFIG_BQ27425_FUEL_GAUGE
-	if (is_attached) {
-		msm_batt_info.batt_capacity = get_level_from_fuelgauge();
-		msm_batt_info.battery_vol = get_voltage_from_fuelgauge();
-		msm_batt_info.batt_voltage_now =
-			msm_batt_info.battery_vol * 1000;
-		pr_info("[BATTERY] get bat leel and voltage from fuelgauge\n");
-	}
-#endif
-	msm_batt_info.callback.set_cable = msm_set_cable;
-	msm_batt_info.callback.set_acc_type = msm_set_acc_type;
-	msm_batt_info.callback.set_ovp_type = msm_set_ovp_type;
-#ifdef CONFIG_CHARGER_SMB328A
-	msm_batt_info.callback.charge_done = msm_batt_charge_done;
-#endif
-
-	if (msm_batt_info.pdata->register_callbacks)
-		msm_batt_info.pdata->register_callbacks
-		(&msm_batt_info.callback);
-
-
-	/* sys fs */
-	jig_class = class_create(THIS_MODULE, "jig");
-	if (IS_ERR(jig_class))
-		pr_err("Failed to create class(jig)!\n");
-
-	jig_dev = device_create(jig_class, NULL, 0, NULL, "jig");
-	if (IS_ERR(jig_dev))
-		pr_err("Failed to create device(jig)!\n");
-
-	if (device_create_file(jig_dev, &dev_attr_jig) < 0)
-		pr_err("Failed to create device file(%s)!\n",
-			dev_attr_jig.attr.name);
-	/* sys fs */
-	msm_batt_driver_init = 1;
-	set_timer = 1;
-	msm_batt_info.resume_flag = 0;
-	msm_batt_info.boot_flag = 1;
-	msm_batt_info.batt_use = 0;
-
-	/* block bellow until fuel guage modified */
-#if 0
-	if (!rc && msm_batt_info.batt_capacity < 4) {
-		wake_lock(&fuel_alert_wake_lock);
-		pr_info("[BATT] start_wake_lock for fuelgague\n");
-		fuel_alert_det = 1;
-	} else {
-		fuel_alert_det = 0;
-	}
-#endif
-
-	pr_debug("[BATT] %s : success!\n", __func__);
+#else
 	power_supply_changed(&msm_psy_ac);
-	power_supply_changed(&msm_psy_usb);
-
-	alarm_init(&msm_batt_info.alarm,
-			ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
-			msm_batt_alarm_manager);
-		queue_work(msm_batt_info.msm_batt_wq,
-			&msm_batt_work);
-		mod_timer(&msm_batt_info.timer,
-			(jiffies + BATT_CHECK_INTERVAL));
+#endif  /* CONFIG_BATTERY_MSM_FAKE */
 
 	return 0;
 }
@@ -4025,15 +1442,8 @@
 static int __devexit msm_batt_remove(struct platform_device *pdev)
 {
 	int rc;
-	pr_info("%s\n", __func__);
 	rc = msm_batt_cleanup();
 
-	wake_lock_destroy(&fuel_alert_wake_lock);
-	wake_lock_destroy(&vbus_wake_lock);
-
-	if (charging_boot)
-		wake_lock_destroy(&lpm_wake_lock);
-
 	if (rc < 0) {
 		dev_err(&pdev->dev,
 			"%s: msm_batt_cleanup  failed rc=%d\n", __func__, rc);
@@ -4042,48 +1452,22 @@
 	return 0;
 }
 
-static void msm_batt_shutdown(struct platform_device *pdev)
-{
-	int rc;
-	pr_info("%s\n", __func__);
-	rc = msm_batt_cleanup();
-
-	if (rc < 0) {
-		dev_err(&pdev->dev,
-			"%s: msm_batt_cleanup  failed rc=%d\n", __func__, rc);
-	}
-
-}
-
-
-static const struct dev_pm_ops msm_batt_pm_ops = {
-	.prepare = msm_batt_suspend,
-	.complete = msm_batt_resume,
-};
-
 static struct platform_driver msm_batt_driver = {
 	.probe = msm_batt_probe,
 	.remove = __devexit_p(msm_batt_remove),
-	.shutdown = msm_batt_shutdown,
 	.driver = {
-			.name = "msm-battery",
-			.pm = &msm_batt_pm_ops,
-			},
+		   .name = "msm-battery",
+		   .owner = THIS_MODULE,
+		   },
 };
 
 static int __devinit msm_batt_init_rpc(void)
 {
 	int rc;
 
-	msm_batt_info.msm_batt_wq =
-		create_singlethread_workqueue("msm_battery");
-	msm_batt_cable_wq =
-		create_singlethread_workqueue("msm_bat_setcable");
-
-	if (!msm_batt_info.msm_batt_wq) {
-		printk(KERN_ERR "%s: create workque failed\n", __func__);
-		return -ENOMEM;
-	}
+#ifdef CONFIG_BATTERY_MSM_FAKE
+	pr_info("Faking MSM battery\n");
+#else
 
 	msm_batt_info.chg_ep =
 		msm_rpc_connect_compatible(CHG_RPC_PROG, CHG_RPC_VER_4_1, 0);
@@ -4169,6 +1553,7 @@
 		msm_batt_info.batt_client = NULL;
 		return rc;
 	}
+#endif  /* CONFIG_BATTERY_MSM_FAKE */
 
 	rc = platform_driver_register(&msm_batt_driver);
 
@@ -4205,7 +1590,7 @@
 	platform_driver_unregister(&msm_batt_driver);
 }
 
-late_initcall(msm_batt_init);
+module_init(msm_batt_init);
 module_exit(msm_batt_exit);
 
 MODULE_LICENSE("GPL v2");
diff -ru final2/drivers/power/power_supply_core.c ics/drivers/power/power_supply_core.c
--- final2/drivers/power/power_supply_core.c	2014-08-29 08:20:15.304248000 +0200
+++ ics/drivers/power/power_supply_core.c	2013-04-19 11:37:14.000000000 +0200
@@ -155,32 +155,6 @@
 	spin_unlock_irqrestore(&psy->changed_lock, flags);
 }
 
-static void power_supply_changed_direct(struct power_supply *psy)
-{
-	unsigned long flags;
-
-	printk(KERN_ERR "%s enter.\n", __func__);
-
-	spin_lock_irqsave(&psy->changed_lock, flags);
-	if (psy->changed) {
-		psy->changed = false;
-		spin_unlock_irqrestore(&psy->changed_lock, flags);
-
-		class_for_each_device(power_supply_class, NULL, psy,
-				      __power_supply_changed_work);
-
-		power_supply_update_leds(psy);
-
-		kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
-		spin_lock_irqsave(&psy->changed_lock, flags);
-	}
-	if (!psy->changed)
-		wake_unlock(&psy->work_wake_lock);
-	spin_unlock_irqrestore(&psy->changed_lock, flags);
-
-	printk(KERN_ERR "%s exit.\n", __func__);
-}
-
 void power_supply_changed(struct power_supply *psy)
 {
 	unsigned long flags;
@@ -191,11 +165,7 @@
 	psy->changed = true;
 	wake_lock(&psy->work_wake_lock);
 	spin_unlock_irqrestore(&psy->changed_lock, flags);
-#ifdef CONFIG_MACH_KYLE
-	power_supply_changed_direct(psy);
-#else
 	schedule_work(&psy->changed_work);
-#endif
 }
 EXPORT_SYMBOL_GPL(power_supply_changed);
 
Nur in final2/drivers/power: smb328a_charger.c.
diff -ru final2/drivers/regulator/core.c ics/drivers/regulator/core.c
--- final2/drivers/regulator/core.c	2014-08-29 08:16:32.524241000 +0200
+++ ics/drivers/regulator/core.c	2013-04-19 11:37:14.000000000 +0200
@@ -30,7 +30,6 @@
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
-#include <linux/proc_fs.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/regulator.h>
@@ -2193,21 +2192,6 @@
 	return ret;
 }
 
-static unsigned int __regulator_get_mode(struct regulator_dev *rdev)
-{
-	int ret;
-
-	/* sanity check */
-	if (!rdev->desc->ops->get_mode) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	ret = rdev->desc->ops->get_mode(rdev);
-out:
-	return ret;
-}
-
 /**
  * regulator_get_mode - get regulator operating mode
  * @regulator: regulator source
@@ -2867,64 +2851,6 @@
 DEFINE_SIMPLE_ATTRIBUTE(reg_mode_fops, reg_debug_mode_get,
 			reg_debug_mode_set, "%llu\n");
 
-void regulator_showall_enabled(void)
-{
-	struct regulator_dev *rdev;
-	unsigned int cnt = 0;
-	struct regulator *reg;
-	char *supply_name;
-
-	pr_info("Enabled regulators:\n");
-	/* XXX: mutex lock can't be used during suspending
-	mutex_lock(&regulator_list_mutex);
-	*/
-	list_for_each_entry(rdev, &regulator_list, list) {
-		/*
-		mutex_lock(&rdev->mutex);
-		*/
-		if (_regulator_is_enabled(rdev)) {
-			if (rdev->desc->ops) {
-				pr_info("  %s, %duV, 0x%x mode\n",
-						rdev_get_name(rdev),
-						_regulator_get_voltage(rdev),
-						__regulator_get_mode(rdev));
-
-				list_for_each_entry(reg,
-						&rdev->consumer_list, list) {
-					if (reg->supply_name)
-						supply_name = reg->supply_name;
-					else
-						supply_name = "(null)-(null)";
-
-					pr_info("%-32s %c   %8d %8d %8d\n",
-							supply_name,
-							(reg->enabled ?
-							 'Y' : 'N'),
-							reg->min_uV,
-							reg->max_uV,
-							reg->uA_load);
-				}
-			} else {
-				pr_info("  %s\n", rdev_get_name(rdev));
-			}
-			cnt++;
-		}
-		/*
-		mutex_unlock(&rdev->mutex);
-		*/
-	}
-	/*
-	mutex_unlock(&regulator_list_mutex);
-	*/
-
-	if (cnt)
-		pr_info("Enabled regulator count: %d\n", cnt);
-	else
-		pr_info("No regulators enabled.\n");
-
-	return;
-}
-
 static int reg_debug_optimum_mode_set(void *data, u64 val)
 {
 	int err_info;
@@ -3492,39 +3418,6 @@
 /* init early to allow our consumers to complete system booting */
 core_initcall(regulator_init);
 
-static int regulator_stats_show(struct seq_file *m, void *unused)
-{
-	struct regulator_dev *rdev;
-
-	mutex_lock(&regulator_list_mutex);
-	list_for_each_entry(rdev, &regulator_list, list) {
-		mutex_lock(&rdev->mutex);
-		if (_regulator_is_enabled(rdev)) {
-			if (rdev->desc->ops)
-				seq_printf(m, "  %s, %duV, 0x%x mode\n",
-						rdev_get_name(rdev),
-						_regulator_get_voltage(rdev),
-						__regulator_get_mode(rdev));
-			else
-				seq_printf(m, "  %s\n", rdev_get_name(rdev));
-		}
-		mutex_unlock(&rdev->mutex);
-	}
-	mutex_unlock(&regulator_list_mutex);
-	return 0;
-}
-static int regulator_stats_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, regulator_stats_show, NULL);
-}
-
-static const struct file_operations regulator_stats_fops = {
-	.owner = THIS_MODULE,
-	.open = regulator_stats_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
 static int __init regulator_init_complete(void)
 {
 	struct regulator_dev *rdev;
@@ -3584,7 +3477,6 @@
 	}
 
 	mutex_unlock(&regulator_list_mutex);
-	proc_create("regulator", S_IRUGO, NULL, &regulator_stats_fops);
 
 	return 0;
 }
diff -ru final2/drivers/rtc/alarm.c ics/drivers/rtc/alarm.c
--- final2/drivers/rtc/alarm.c	2014-08-29 08:16:32.528241000 +0200
+++ ics/drivers/rtc/alarm.c	2013-04-19 11:37:14.000000000 +0200
@@ -299,72 +299,6 @@
 	return ret;
 }
 
-#ifdef CONFIG_RTC_AUTO_PWRON
-/* 0|1234|56|78|90|12 */
-/* 1|2010|01|01|00|00 */
-/* en yyyy mm dd hh mm */
-#define BOOTALM_BIT_EN       0
-#define BOOTALM_BIT_YEAR     1
-#define BOOTALM_BIT_MONTH    5
-#define BOOTALM_BIT_DAY      7
-#define BOOTALM_BIT_HOUR     9
-#define BOOTALM_BIT_MIN     11
-#define BOOTALM_BIT_TOTAL   13
-
-int alarm_set_alarm(char *alarm_data)
-{
-	struct rtc_wkalrm alm;
-	int ret;
-	char buf_ptr[BOOTALM_BIT_TOTAL+1];
-
-	if (!alarm_rtc_dev) {
-		pr_alarm(ERROR,
-			"alarm_set_alarm: no RTC, time will be lost on reboot\n");
-		return -1;
-	}
-
-	strlcpy(buf_ptr, alarm_data, BOOTALM_BIT_TOTAL+1);
-
-	alm.time.tm_sec = 0;
-	alm.time.tm_min = (buf_ptr[BOOTALM_BIT_MIN] - '0') * 10
-			+ (buf_ptr[BOOTALM_BIT_MIN+1] - '0');
-	alm.time.tm_hour = (buf_ptr[BOOTALM_BIT_HOUR] - '0') * 10
-			+ (buf_ptr[BOOTALM_BIT_HOUR+1] - '0');
-	alm.time.tm_mday = (buf_ptr[BOOTALM_BIT_DAY] - '0') * 10
-			+ (buf_ptr[BOOTALM_BIT_DAY+1] - '0');
-	alm.time.tm_mon = (buf_ptr[BOOTALM_BIT_MONTH] - '0') * 10
-			+ (buf_ptr[BOOTALM_BIT_MONTH+1] - '0');
-	alm.time.tm_year = (buf_ptr[BOOTALM_BIT_YEAR] - '0') * 1000
-			+ (buf_ptr[BOOTALM_BIT_YEAR+1] - '0') * 100
-			+ (buf_ptr[BOOTALM_BIT_YEAR+2] - '0') * 10
-			+ (buf_ptr[BOOTALM_BIT_YEAR+3] - '0');
-
-	alm.enabled = (*buf_ptr == '1');
-
-	pr_info("%s : %s => tm(%d %04d.%02d.%02d %02d:%02d:%02d)\n",
-			__func__, buf_ptr, alm.enabled,
-			alm.time.tm_year, alm.time.tm_mon, alm.time.tm_mday,
-			alm.time.tm_hour, alm.time.tm_min, alm.time.tm_sec);
-	/* case 1. if alarm has not been set
-			yet since download, alarm is set to 2030,
-			because sometimes RTC occurs,
-			so it does auto power up. */
-	if (alm.time.tm_year == 0) {
-		alm.enabled = 1;
-		alm.time.tm_year = 2030;
-	}
-	/* end of case 1. */
-	alm.time.tm_mon -= 1;
-	alm.time.tm_year -= 2000;
-	ret = rtc_set_bootalarm(alarm_rtc_dev, &alm);
-	if (ret < 0) {
-		pr_alarm(ERROR, "alarm_set_alarm: "
-			"Failed to set ALARM, time will be lost on reboot\n");
-		return -2;
-	}
-	return 0;
-}
-#endif /* CONFIG_RTC_AUTO_PWRON */
 
 void
 alarm_update_timedelta(struct timespec tmp_time, struct timespec new_time)
diff -ru final2/drivers/rtc/alarm-dev.c ics/drivers/rtc/alarm-dev.c
--- final2/drivers/rtc/alarm-dev.c	2014-08-29 08:16:32.528241000 +0200
+++ ics/drivers/rtc/alarm-dev.c	2013-04-19 11:37:14.000000000 +0200
@@ -66,9 +66,6 @@
 	struct timespec tmp_time;
 	enum android_alarm_type alarm_type = ANDROID_ALARM_IOCTL_TO_TYPE(cmd);
 	uint32_t alarm_type_mask = 1U << alarm_type;
-#ifdef CONFIG_RTC_AUTO_PWRON
-	char bootalarm_data[14];
-#endif /* CONFIG_RTC_AUTO_PWRON */
 
 	if (alarm_type >= ANDROID_ALARM_TYPE_COUNT)
 		return -EINVAL;
@@ -163,18 +160,6 @@
 		if (rv < 0)
 			goto err1;
 		break;
-
-#ifdef CONFIG_RTC_AUTO_PWRON
-	case ANDROID_ALARM_SET_ALARM:
-		if (copy_from_user(bootalarm_data, (void __user *)arg, 14)) {
-			pr_err("%s error!\n", __func__);
-			rv = -EFAULT;
-			goto err1;
-		}
-		rv = alarm_set_alarm(bootalarm_data);
-		break;
-#endif /* CONFIG_RTC_AUTO_PWRON */
-
 	case ANDROID_ALARM_GET_TIME(0):
 		switch (alarm_type) {
 		case ANDROID_ALARM_RTC_WAKEUP:
diff -ru final2/drivers/rtc/class.c ics/drivers/rtc/class.c
--- final2/drivers/rtc/class.c	2014-08-29 08:16:32.528241000 +0200
+++ ics/drivers/rtc/class.c	2013-04-19 11:37:14.000000000 +0200
@@ -20,15 +20,6 @@
 
 #include "rtc-core.h"
 
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_KYLE_I)
-#define ADJUST_KERNEL_TIME
-#endif
-
-#ifdef ADJUST_KERNEL_TIME
-#define RTC_WORK_CHECK_TIMEOUT (30 * 60 * HZ)
-static int rtc_work_check();
-static DECLARE_DELAYED_WORK(rtc_work, rtc_work_check);
-#endif
 
 static DEFINE_IDR(rtc_idr);
 static DEFINE_MUTEX(idr_lock);
@@ -99,10 +90,6 @@
 	if (strcmp(dev_name(&rtc->dev), CONFIG_RTC_HCTOSYS_DEVICE) != 0)
 		return 0;
 
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_KYLE_I) || defined(CONFIG_MACH_KYLE_CHN)
-	printk("%s [RTC] ==================================== \n", __func__);
-#endif
-
 	/* snapshot the current rtc and system time at resume */
 	getnstimeofday(&new_system);
 	rtc_read_time(rtc, &tm);
@@ -133,74 +120,12 @@
 			timespec_sub(new_system, old_system));
 
 	timekeeping_inject_sleeptime(&sleep_time);
-
-#ifdef ADJUST_KERNEL_TIME
-	schedule_delayed_work(&rtc_work, RTC_WORK_CHECK_TIMEOUT);
-#endif
-
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_KYLE_I) || defined(CONFIG_MACH_KYLE_CHN)
-	printk("%s [RTC] sleep_time = %ld \n", __func__,sleep_time.tv_sec);
-	printk("%s [RTC] time now = %ld\n", __func__,new_rtc.tv_sec);
-	printk("%s [RTC] ==================================== \n", __func__);
-#endif
-
 	return 0;
 }
 
-#ifdef ADJUST_KERNEL_TIME
-static int rtc_work_check()
-{
-	struct device *dev;
-	struct rtc_device *rtc = NULL;
-	struct timespec		ktime, adjust_ktime;
-	struct timespec		check_delta;
-	struct rtc_time		tm;
-	struct timespec		rtime;
-
-	printk(KERN_ERR "%s\n", __func__);
-
-	rtc = rtc_class_open(CONFIG_RTC_HCTOSYS_DEVICE);
-
-	if (rtc!=NULL){
-		getnstimeofday(&ktime);					// kernel_time
-		rtc_read_time(rtc, &tm);
-		rtc_tm_to_time(&tm, &rtime.tv_sec);		// rtc_time
-		rtc_tm_to_time(&tm, &adjust_ktime.tv_sec);
-		
-		/* RTC precision is 1 second; adjust delta for avg 1/2 sec err */
-		set_normalized_timespec(&check_delta, ktime.tv_sec - rtime.tv_sec, ktime.tv_nsec - (NSEC_PER_SEC >> 1));
-
-		printk(KERN_ERR "%s: 1 k_t: %10d\n", __func__, ktime.tv_sec);
-		printk(KERN_ERR "%s: 2 r_t: %10d\n", __func__, rtime.tv_sec);
-		printk(KERN_ERR "%s: 3 check_delta   s: %3d, s: %10d \n", __func__, check_delta.tv_sec, check_delta.tv_nsec);
-		printk(KERN_ERR "%s: 4 old_delta   s: %3d, s: %10d \n", __func__, old_delta.tv_sec, old_delta.tv_nsec);
-
-		if(abs(check_delta.tv_sec) >= 3)
-		{
-			adjust_ktime.tv_nsec = 0;
-			do_settimeofday(&adjust_ktime);
-
-			rtc_read_time(rtc, &tm);		//request by QC
-			
-			getnstimeofday(&adjust_ktime);
-			printk(KERN_ERR "%s: 5 adjust k time is set as: %10d\n", __func__, adjust_ktime.tv_sec);
-
-			set_normalized_timespec(&old_delta, adjust_ktime.tv_sec - rtime.tv_sec, adjust_ktime.tv_nsec - (NSEC_PER_SEC >> 1));
-			printk(KERN_ERR "%s: 5 re-set delta,  s:%3d, n:%10d\n", __func__, old_delta.tv_sec,old_delta.tv_nsec);
-		}
-	}else{
-		printk(KERN_ERR "%s: rtc_dev isn't rtc0, \n", __func__);
-
-	}
-	schedule_delayed_work(&rtc_work, RTC_WORK_CHECK_TIMEOUT);
-	return 0;
-}
-#endif
-
 #else
 #define rtc_suspend	NULL
 #define rtc_resume	NULL
-#define rtc_work_check NULL
 #endif
 
 
@@ -344,10 +269,6 @@
 	rtc_class->resume = rtc_resume;
 	rtc_dev_init();
 	rtc_sysfs_init(rtc_class);
-
-#ifdef ADJUST_KERNEL_TIME
-	schedule_delayed_work(&rtc_work, RTC_WORK_CHECK_TIMEOUT);
-#endif
 	return 0;
 }
 
diff -ru final2/drivers/rtc/interface.c ics/drivers/rtc/interface.c
--- final2/drivers/rtc/interface.c	2014-08-29 08:16:32.528241000 +0200
+++ ics/drivers/rtc/interface.c	2013-04-19 11:37:14.000000000 +0200
@@ -374,29 +374,6 @@
 	return err;
 }
 EXPORT_SYMBOL_GPL(rtc_set_alarm);
-#ifdef CONFIG_RTC_AUTO_PWRON
-int rtc_set_bootalarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
-{
-	int err;
-
-/*	err = mutex_lock_interruptible(&rtc->ops_lock); */
-/*	if (err) */
-/*		return err; */
-
-	if (!rtc->ops) {
-		dev_err(&rtc->dev, "ops not exist\n");
-		err = -ENODEV;
-	} else if (!rtc->ops->set_bootalarm) {
-		dev_err(&rtc->dev, "bootalarm func not exist\n");
-		err = -EINVAL;
-	} else
-		err = rtc->ops->set_bootalarm(rtc->dev.parent, alarm);
-
-/*	mutex_unlock(&rtc->ops_lock); */
-	return err;
-}
-EXPORT_SYMBOL_GPL(rtc_set_bootalarm);
-#endif /* CONFIG_RTC_AUTO_PWRON */
 
 /* Called once per device from rtc_device_register */
 int rtc_initialize_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
diff -ru final2/drivers/rtc/Kconfig ics/drivers/rtc/Kconfig
--- final2/drivers/rtc/Kconfig	2014-08-29 08:16:32.528241000 +0200
+++ ics/drivers/rtc/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -764,17 +764,6 @@
 	  RTC driver for Qualcomm chipsets
 
 
-config RTC_AUTO_PWRON
-	tristate "RTC Auto power on alarm"
-	depends on RTC_DRV_MSM = y
-	default n
-	help
-	  RTC Auto power on alarm.
-	  If you say Y here you will get support for this function
-	  that RTC Auto power on alarm.
-	  It can be auto power up when the target is off.
-
-
 config RTC_SECURE_TIME_SUPPORT
         bool "Support for secure time on Qualcomm Chipsets"
         depends on RTC_DRV_MSM = y
diff -ru final2/drivers/rtc/rtc-msm.c ics/drivers/rtc/rtc-msm.c
--- final2/drivers/rtc/rtc-msm.c	2014-08-29 08:20:15.304248000 +0200
+++ ics/drivers/rtc/rtc-msm.c	2013-04-19 11:37:14.000000000 +0200
@@ -27,9 +27,6 @@
 #include <linux/rtc-msm.h>
 #include <linux/msm_rpcrouter.h>
 #include <mach/msm_rpcrouter.h>
-#ifdef CONFIG_RTC_AUTO_PWRON
-#include "../../arch/arm/mach-msm/proc_comm.h"
-#endif /* CONFIG_RTC_AUTO_PWRON */
 
 #define APP_TIMEREMOTE_PDEV_NAME "rs00000000"
 
@@ -322,33 +319,12 @@
 	return 0;
 }
 
-#ifdef CONFIG_RTC_AUTO_PWRON
-#define BOOTALARM_DEBUG
-#endif /* CONFIG_RTC_AUTO_PWRON */
-#ifdef BOOTALARM_DEBUG
 static int
-msmrtc_getbootalarm(struct device *dev, struct rtc_wkalrm *a);
-#endif /* BOOTALARM_DEBUG */
 msmrtc_timeremote_read_time(struct device *dev, struct rtc_time *tm)
 {
 	int rc;
 	struct rtc_tod_args rtc_args;
 	struct msm_rtc *rtc_pdata = dev_get_drvdata(dev);
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_KYLE_I) || defined(CONFIG_MACH_KYLE_CHN)
-	unsigned long sec_tmp = 0;
-#endif
-
-#ifdef BOOTALARM_DEBUG
-	static int once = 1;
-	struct rtc_wkalrm bootalarm;
-
-	if (once == 1) {
-		pr_debug("++++++++++++++++++++++++++++++++++++++++\n");
-		msmrtc_getbootalarm(dev, &bootalarm);
-		pr_debug("++++++++++++++++++++++++++++++++++++++++\n");
-		once = 0;
-	}
-#endif /* BOOTALARM_DEBUG */
 
 	rtc_args.proc = TIMEREMOTE_PROCEEDURE_GET_JULIAN;
 	rtc_args.tm = tm;
@@ -357,20 +333,12 @@
 				TIMEREMOTE_PROCEEDURE_GET_JULIAN,
 				msmrtc_tod_proc_args, &rtc_args,
 				msmrtc_tod_proc_result, &rtc_args, -1);
-	
+
 	if (rc) {
 		dev_err(dev, "%s: Error retrieving rtc (TOD) time\n", __func__);
 		return rc;
 	}
 
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_KYLE_I) || defined(CONFIG_MACH_KYLE_CHN)
-	rtc_tm_to_time(rtc_args.tm, &sec_tmp);
-	printk("%s [RTC] sec =  %ld \n", __func__, sec_tmp);
-	printk("%s [RTC] %d-%d-%d %d:%d:%d\n",__func__,rtc_args.tm->tm_year + 1900, rtc_args.tm->tm_mon + 1,
-					 rtc_args.tm->tm_mday, rtc_args.tm->tm_hour,
-					 rtc_args.tm->tm_min, rtc_args.tm->tm_sec);
-#endif
-
 	return 0;
 }
 
@@ -396,156 +364,10 @@
 	return 0;
 }
 
-#ifdef CONFIG_RTC_AUTO_PWRON
-struct txt_time_date {
-	unsigned short year;
-	unsigned char month;
-	unsigned char day;
-} ;
-
-struct txt_time_time {
-	unsigned char hour;
-	unsigned char minute;
-	unsigned char sec;
-	unsigned char wday;
-};
-
-static void
-time_encode_txtime(struct rtc_wkalrm *a, struct txt_time_date *pdate,
-		struct txt_time_time *ptime)
-{
-	pdate->year = a->time.tm_year + 2000;
-	pdate->month = a->time.tm_mon + 1;
-	pdate->day = a->time.tm_mday;
-	ptime->hour = a->time.tm_hour;
-	ptime->minute = a->time.tm_min;
-	ptime->sec = a->time.tm_sec;
-	ptime->wday = a->time.tm_wday;
-}
-
-static void
-time_decode_txtime(struct txt_time_date *pdate, struct txt_time_time *ptime,
-		struct rtc_wkalrm *a)
-{
-	a->time.tm_year = pdate->year - 2000;
-	a->time.tm_mon = pdate->month - 1;
-	a->time.tm_mday = pdate->day;
-	a->time.tm_hour = ptime->hour;
-	a->time.tm_min = ptime->minute;
-	a->time.tm_sec = ptime->sec;
-	a->time.tm_wday = ptime->wday;
-}
-
-static int
-msmrtc_getbootalarm(struct device *dev, struct rtc_wkalrm *a)
-{
-	struct txt_time_date date;
-	struct txt_time_time time;
-	struct rtc_wkalrm b;
-	int cnt = 2;
-
-	while (cnt > 0) {
-		date.year = 0xFFFD + cnt;  /* 1st : 0xFFFF , 2st : 0xFFFE */
-		msm_proc_comm(PCOM_SET_RTC_ALARM,
-			(unsigned *)&date, (unsigned *)&time);
-
-		if (date.year >= 0xFFFE) {
-			pr_err("%s -> failed\n", __func__);
-		} else {
-			if (cnt == 2) {
-				time_decode_txtime(&date, &time, a);
-				a->enabled = 1;
-
-				pr_debug("%s [PMIC ALARM] %d-%d-%d %d:%d:%d\n",
-					__func__,
-					a->time.tm_year, a->time.tm_mon,
-					a->time.tm_mday,	a->time.tm_hour,
-					a->time.tm_min, a->time.tm_sec);
-			}	else {
-				time_decode_txtime(&date, &time, &b);
-				b.enabled = 1;
-
-				pr_debug("%s [PMIC RTC  ] %d-%d-%d %d:%d:%d\n",
-					__func__,
-					b.time.tm_year, b.time.tm_mon,
-					 b.time.tm_mday, b.time.tm_hour,
-					 b.time.tm_min, b.time.tm_sec);
-			}
-		}
-		cnt--;
-	}
-
-	return 0;
-}
-
-static int
-msmrtc_setbootalarm(struct device *dev, struct rtc_wkalrm *a)
-{
-	unsigned long now = get_seconds();
-	struct txt_time_date date;
-	struct txt_time_time time;
-	int ret;
-	struct msm_rtc *rtc_pdata = dev_get_drvdata(dev);
-
-	if (!a->enabled) {
-		date.year = 0xFFFD;  /* alarm off */
-		ret = msm_proc_comm(PCOM_SET_RTC_ALARM,
-					(unsigned *)&date, (unsigned *)&time);
-		if (ret != 0) {
-			pr_err("[%s] PCOM_SET_RTC_ALARM off failed\n",
-					__func__);
-		}
-		rtc_pdata->rtcalarm_time = 0;
-		return 0;
-	}
-
-	rtc_tm_to_time(&a->time, &rtc_pdata->rtcalarm_time);
-	pr_debug("[%s] %d-%d-%d %d:%d:%d => 0x%x\n", __func__,
-		a->time.tm_year, a->time.tm_mon, a->time.tm_mday,
-		a->time.tm_hour, a->time.tm_min, a->time.tm_sec,
-		rtc_pdata->rtcalarm_time);
-	printk(KERN_ERR"%s %d-%d-%d %d:%d:%d => 0x%x\n", __func__,
-		a->time.tm_year, a->time.tm_mon, a->time.tm_mday,
-		a->time.tm_hour, a->time.tm_min, a->time.tm_sec,
-		rtc_pdata->rtcalarm_time);
-	
-	/* To ignore invalid data from rtc-sysfs.c */
-	a->time.tm_wday = 0;
-
-	if (now > rtc_pdata->rtcalarm_time) {
-		pr_err("%s: Attempt to set alarm in the past\n", __func__);
-		rtc_pdata->rtcalarm_time = 0;
-		return -EINVAL;
-	}
-
-	/* convert to 2 byte time format */
-	time_encode_txtime(a, &date, &time);
-
-	ret = msm_proc_comm(PCOM_SET_RTC_ALARM,
-				(unsigned *)&date, (unsigned *)&time);
-	if (ret != 0) {
-		pr_err("[%s] PCOM_SET_RTC_ALARM set failed #1 -> re-try\n",
-					__func__);
-		ret = msm_proc_comm(PCOM_SET_RTC_ALARM,
-					(unsigned *)&date, (unsigned *)&time);
-		if (ret != 0) {
-			pr_err("[%s] PCOM_SET_RTC_ALARM set failed #2\n",
-					__func__);
-		}
-	}
-
-	return 0;
-}
-#endif /*CONFIG_RTC_AUTO_PWRON*/
-
 static struct rtc_class_ops msm_rtc_ops = {
 	.read_time	= msmrtc_timeremote_read_time,
 	.set_time	= msmrtc_timeremote_set_time,
 	.set_alarm	= msmrtc_virtual_alarm_set,
-#ifdef CONFIG_RTC_AUTO_PWRON
-	.read_bootalarm = msmrtc_getbootalarm,
-	.set_bootalarm  = msmrtc_setbootalarm,
-#endif /*CONFIG_RTC_AUTO_PWRON*/
 };
 
 #ifdef CONFIG_RTC_SECURE_TIME_SUPPORT
@@ -899,13 +721,6 @@
 			atomic_inc(&suspend_state.state);
 			return 0;
 		}
-		rtc_time_to_tm(rtc_pdata->rtcalarm_time, &tm);
-		#if !defined(CONFIG_MACH_KYLE)
-		pr_info("%s: wakeup alarm set to "
-				"%d-%02d-%02d %02d:%02d:%02d UTC\n", __func__,
-				tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
-				tm.tm_hour, tm.tm_min, tm.tm_sec);
-		#endif
 		msm_pm_set_max_sleep_time((int64_t)
 			((int64_t) diff * NSEC_PER_SEC));
 	} else
Nur in final2/drivers: sensors.
diff -ru final2/drivers/staging/android/logger.c ics/drivers/staging/android/logger.c
--- final2/drivers/staging/android/logger.c	2014-08-29 08:16:33.848241000 +0200
+++ ics/drivers/staging/android/logger.c	2013-04-19 11:37:14.000000000 +0200
@@ -29,283 +29,6 @@
 
 #include <asm/ioctls.h>
 
-static unsigned long platform_reset_count;
-
-#ifdef CONFIG_APPLY_GA_SOLUTION
-// @message
-static char klog_buf[256];
-#endif
-
-#ifdef CONFIG_APPLY_GA_SOLUTION
-// GAF
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-
-extern struct GAForensicINFO GAFINFO;
-
-void dump_one_task_info(struct task_struct *tsk, bool isMain)
-{
-	char stat_array[3] = { 'R', 'S', 'D'};
-	char stat_ch;
-	char *pThInf = tsk->stack;
-
-	stat_ch = tsk->state <= TASK_UNINTERRUPTIBLE ? stat_array[tsk->state] : '?';
-	printk( "%8d %8d %8d %16lld %c (%d) %3d %08x %c %s\n",
-		tsk->pid, (int)(tsk->utime), (int)(tsk->stime), tsk->se.exec_start, stat_ch, (int)(tsk->state),
-		*(int*)(pThInf + GAFINFO.thread_info_struct_cpu),
-		(int)tsk, isMain?'*':' ', tsk->comm );
-	
-	if( tsk->state == TASK_RUNNING || tsk->state == TASK_UNINTERRUPTIBLE ) {
-		show_stack(tsk, NULL);
-	}
-}
-
-void dump_all_task_info()
-{
-	struct task_struct *frst_tsk;
-	struct task_struct *curr_tsk;
-	struct task_struct *frst_thr;
-	struct task_struct *curr_thr;
-
-	printk ( "\n" );
-	printk ( " current proc: %d %s\n", current->pid, current->comm );
-	printk ( "-----------------------------------------------------------------------------------\n" );
-	printk ( "    pid     uTime     sTime              exec(ns)     stat     cpu     task_struct\n" );
-	printk ( "-----------------------------------------------------------------------------------\n" );
-
-	//process
-	frst_tsk = &init_task;
-	curr_tsk = frst_tsk;
-	while(curr_tsk != NULL )
-	{
-		dump_one_task_info( curr_tsk, true);
-		//threads
-		if( curr_tsk->thread_group.next != NULL)
-		{
-			frst_thr = container_of( curr_tsk->thread_group.next, struct task_struct, thread_group );
-			curr_thr = frst_thr;
-			if( frst_thr != curr_tsk)
-			{
-				while( curr_thr != curr_tsk)
-				{
-					dump_one_task_info( curr_thr, false);
-					curr_thr = container_of( curr_thr->thread_group.next, struct task_struct, thread_group);
-					if( curr_thr == curr_tsk)  break;
-				}
-			}
-		}
-		curr_tsk = container_of( curr_tsk->tasks.next, struct task_struct, tasks);
-		if(curr_tsk == frst_tsk) break;
-	}
-	printk ( "-----------------------------------------------------------------------------------\n" );
-}
-
-#include <linux/kernel_stat.h>
-
-#ifndef arch_irq_stat_cpu
-#define arch_irq_stat_cpu(cpu) 0
-#endif
-
-#ifndef arch_irq_stat
-#define arch_irq_stat() 0
-#endif
-
-#ifndef arch_idle_time
-#define arch_idle_time(cpu) 0
-#endif
-	
-void dump_cpu_stat()
-{
-	int i, j;
-	unsigned long jif;
-	
-	cputime64_t user, nice, system, idle, iowait, irq, softirq, steal;
-	cputime64_t guest, guest_nice;
-	u64 sum = 0;
-	u64 sum_softirq = 0;
-	unsigned int per_softirq_sums[NR_SOFTIRQS] = {0};
-	struct timespec boottime;
-	unsigned int per_irq_sum;
-	user = nice = system = idle = iowait =
-	irq = softirq = steal = cputime64_zero;
-	guest = guest_nice = cputime64_zero;
-	getboottime(&boottime);
-	jif = boottime.tv_sec;
-	
-	for_each_possible_cpu(i) {
-		user = cputime64_add(user, kstat_cpu(i).cpustat.user);
-		nice = cputime64_add(nice, kstat_cpu(i).cpustat.nice);
-		system = cputime64_add(system, kstat_cpu(i).cpustat.system);
-		idle = cputime64_add(idle, kstat_cpu(i).cpustat.idle);
-		idle = cputime64_add(idle, arch_idle_time(i));
-		iowait = cputime64_add(iowait, kstat_cpu(i).cpustat.iowait);
-		irq = cputime64_add(irq, kstat_cpu(i).cpustat.irq);
-		softirq = cputime64_add(softirq, kstat_cpu(i).cpustat.softirq);
-		//steal = cputime64_add(steal, kstat_cpu(i).cpustat.steal);
-		//guest = cputime64_add(guest, kstat_cpu(i).cpustat.guest);
-		//guest_nice = cputime64_add(guest_nice,
-		//kstat_cpu(i).cpustat.guest_nice);
-		for_each_irq_nr(j) {
-			sum += kstat_irqs_cpu(i, j);
-		}
-		
-		sum += arch_irq_stat_cpu(i);
-		
-		for (j=0; j< NR_SOFTIRQS; j++)
-		{
-			unsigned int softirq_stat = kstat_softirqs_cpu(j, i);
-			per_softirq_sums[j] += softirq_stat;
-			sum_softirq += softirq_stat;
-		}
-	}
-	sum += arch_irq_stat();
-	
-	printk("\n");
-	printk(" cpu  user:%llu nice:%llu system:%llu idle:%llu iowait:%llu irq:%llu softirq:%llu %llu %llu %llu\n",
-		(unsigned long long)cputime64_to_clock_t(user),
-		(unsigned long long)cputime64_to_clock_t(nice),
-		(unsigned long long)cputime64_to_clock_t(system),
-		(unsigned long long)cputime64_to_clock_t(idle),
-		(unsigned long long)cputime64_to_clock_t(iowait),
-		(unsigned long long)cputime64_to_clock_t(irq),
-		(unsigned long long)cputime64_to_clock_t(softirq),
-		(unsigned long long)0, //cputime64_to_clock_t(steal),
-		(unsigned long long)0, //cputime64_to_clock_t(guest),
-		(unsigned long long)0);//cputime64_to_clock_t(guest_nice));
-	printk(" -----------------------------------------------------------------------------------\n" );
-	
-	for_each_online_cpu(i) {
-		/* Copy values here to work around gcc-2.95.3, gcc-2.96 */
-		user = kstat_cpu(i).cpustat.user;
-		nice = kstat_cpu(i).cpustat.nice;
-		system = kstat_cpu(i).cpustat.system;
-		idle = kstat_cpu(i).cpustat.idle;
-		idle = cputime64_add(idle, arch_idle_time(i));
-		iowait = kstat_cpu(i).cpustat.iowait;
-		irq = kstat_cpu(i).cpustat.irq;
-		softirq = kstat_cpu(i).cpustat.softirq;
-		//steal = kstat_cpu(i).cpustat.steal;
-		//guest = kstat_cpu(i).cpustat.guest;
-		//guest_nice = kstat_cpu(i).cpustat.guest_nice;
-		
-		printk(" cpu %d user:%llu nice:%llu system:%llu idle:%llu iowait:%llu irq:%llu softirq:%llu %llu %llu %llu\n",
-			i,
-			(unsigned long long)cputime64_to_clock_t(user),
-			(unsigned long long)cputime64_to_clock_t(nice),
-			(unsigned long long)cputime64_to_clock_t(system),
-			(unsigned long long)cputime64_to_clock_t(idle),
-			(unsigned long long)cputime64_to_clock_t(iowait),
-			(unsigned long long)cputime64_to_clock_t(irq),
-			(unsigned long long)cputime64_to_clock_t(softirq),
-			(unsigned long long)0, //cputime64_to_clock_t(steal),
-			(unsigned long long)0, //cputime64_to_clock_t(guest),
-			(unsigned long long)0);//cputime64_to_clock_t(guest_nice));
-		
-	}
-	
-	printk(" -----------------------------------------------------------------------------------\n" );
-	printk("\n");
-	printk(" irq : %llu", (unsigned long long)sum);
-	printk(" -----------------------------------------------------------------------------------\n" );
-	
-	/* sum again ? it could be updated? */
-	for_each_irq_nr(j) {
-		per_irq_sum = 0;
-		for_each_possible_cpu(i)
-		per_irq_sum += kstat_irqs_cpu(j, i);
-		if(per_irq_sum) printk(" irq-%d : %u\n", j, per_irq_sum);
-	}
-	
-	printk(" -----------------------------------------------------------------------------------\n" );
-	printk("\n");
-	printk(" softirq : %llu", (unsigned long long)sum_softirq);
-	printk(" -----------------------------------------------------------------------------------\n" );
-	
-	for (i = 0; i < NR_SOFTIRQS; i++)
-		if(per_softirq_sums[i]) printk(" softirq-%d : %u", i, per_softirq_sums[i]);
-			
-	printk(" -----------------------------------------------------------------------------------\n" );
-	return 0;
-}
-
-static struct GAForensicHELP{
-	unsigned int real_pc_from_context_sp;
-	unsigned int task_struct_of_gaf_proc;
-	unsigned int thread_info_of_gaf_proc;
-	unsigned int cpu_context_of_gaf_proc;
-}GAFHELP;
-
-DEFINE_SEMAPHORE(g_gaf_mutex);
-
-int gaf_proc(void* data)
-{
-	volatile int stack[2];
-
-	stack[0] = (int)('_fag');
-	stack[1] = (int)('corp');
-
-	down_interruptible(&g_gaf_mutex);
-	return 1;
-}
-
-void gaf_helper(void)
-{
-	unsigned int *ptr_task_struct;
-	unsigned int *ptr_thread_info;
-	unsigned int *ptr_cpu_cntx;
-	unsigned int ptr_sp, context_sp;
-	unsigned int fn_down_interruptible = (unsigned int)down_interruptible;
-	unsigned int fn_down = (unsigned int)down;
-
-	down_interruptible(&g_gaf_mutex);
-	ptr_task_struct = kthread_create(gaf_proc, NULL, "gaf-proc");
-	wake_up_process(ptr_task_struct);
-	msleep(100);
-
-	ptr_thread_info = *(unsigned int*)((unsigned int)ptr_task_struct + GAFINFO.task_struct_struct_stack);
-	ptr_cpu_cntx = (unsigned int)ptr_thread_info + GAFINFO.thread_info_struct_cpu_context;
-
-	GAFHELP.task_struct_of_gaf_proc = ptr_task_struct;
-	GAFHELP.thread_info_of_gaf_proc = ptr_thread_info;
-	GAFHELP.cpu_context_of_gaf_proc = ptr_cpu_cntx;
-
-	printk("\n========== kernel thread : gaf-proc ==========\n");
-	printk("task_struct at %x\n", ptr_task_struct);
-	printk("thread_info at %x\n\n", ptr_thread_info);
-
-	printk("saved_cpu_context at %x\n", ptr_cpu_cntx);
-	printk("%08x r4 :%08x r5 :%08x r6 :%08x r7 :%08x\n", ((unsigned int)ptr_cpu_cntx + 0x00), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x00), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x04), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x08), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x0c));
-	printk("%08x r8 :%08x r9 :%08x r10:%08x r11:%08x\n", ((unsigned int)ptr_cpu_cntx + 0x10), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x10), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x14), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x18), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x1c));
-	printk("%08x sp :%08x pc :%08x \n\n", ((unsigned int)ptr_cpu_cntx + 0x20), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x20), *(unsigned int*)((unsigned int)ptr_cpu_cntx + 0x24));
-	ptr_sp = context_sp = *(unsigned int*)((unsigned int)ptr_cpu_cntx + GAFINFO.cpu_context_save_struct_sp);
-
-	printk("searching saved pc which is stopped in down_interruptible() from %08x to %08x\n", ptr_sp, (unsigned int)ptr_thread_info + THREAD_SIZE);
-	printk("down_interruptible() is from %08x to %08x\n\n", fn_down_interruptible, fn_down);
-
-	while(ptr_sp < (unsigned int)ptr_thread_info + THREAD_SIZE) {
-		//printk("%08x at %08x\n", *(unsigned int*)ptr_sp, ptr_sp);
-		if( fn_down_interruptible <= *(unsigned int*)ptr_sp && *(unsigned int*)ptr_sp < fn_down ) {
-			printk("pc (%08x) is found at %08x\n", *(unsigned int*)ptr_sp, ptr_sp);
-			break;
-		}
-		ptr_sp += 4;
-	}
-
-	if(ptr_sp < (unsigned int)ptr_thread_info + THREAD_SIZE ) {
-
-		GAFHELP.real_pc_from_context_sp = ptr_sp -context_sp;	
-		printk("%08x r4 :xxxxxxxx r5 :%08x r6 :%08x r7 :%08x\n", (ptr_sp -0x2c), *(unsigned int*)(ptr_sp -0x28), *(unsigned int*)(ptr_sp -0x24), *(unsigned int*)(ptr_sp -0x20));
-		printk("%08x r8 :%08x r9 :%08x r10:%08x r11:%08x\n", (ptr_sp -0x1c), *(unsigned int*)(ptr_sp -0x1c), *(unsigned int*)(ptr_sp -0x18), *(unsigned int*)(ptr_sp -0x14), *(unsigned int*)(ptr_sp -0x10));
-		printk("%08x r12:%08x sp :%08x lr :%08x pc :%08x\n", (ptr_sp -0x0c), *(unsigned int*)(ptr_sp -0x0c), *(unsigned int*)(ptr_sp -0x08), *(unsigned int*)(ptr_sp -0x04), *(unsigned int*)(ptr_sp -0x00));
-	} else {
-		GAFHELP.real_pc_from_context_sp = 0xFFFFFFFF;
-		printk("pc is not found\n");
-	} 
-	printk("===================\n\n");
-}
-#endif
-
 /*
  * struct logger_log - represents a specific log, such as 'main' or 'radio'
  *
@@ -588,19 +311,6 @@
 		if (copy_from_user(log->buffer, buf + len, count - len))
 			return -EFAULT;
 
-#ifdef CONFIG_APPLY_GA_SOLUTION
-// @message
-	memset(klog_buf,0,255);
-	if(strncmp(log->buffer + log->w_off, "!@", 2) == 0) {
-		if (count < 255)
-			memcpy(klog_buf,log->buffer + log->w_off, count);
-		else
-			memcpy(klog_buf,log->buffer + log->w_off, 255);
-
-		klog_buf[255]=0;
-	}
-#endif
-
 	log->w_off = logger_offset(log->w_off + count);
 
 	return count;
@@ -611,10 +321,6 @@
  * writev(), and aio_write(). Writes are our fast path, and we try to optimize
  * them above all else.
  */
-/* cpu currently holding logbuf_lock */
-#ifdef ADD_SYSTEM_TIMEINFO
-static volatile unsigned int logger_cpu = UINT_MAX;
-#endif
 ssize_t logger_aio_write(struct kiocb *iocb, const struct iovec *iov,
 			 unsigned long nr_segs, loff_t ppos)
 {
@@ -624,13 +330,6 @@
 	struct timespec now;
 	ssize_t ret = 0;
 
-#ifdef ADD_SYSTEM_TIMEINFO
-	char tbuf[50], *tp;
-	unsigned tlen;
-	unsigned long long t;
-	unsigned long nanosec_rem;
-#endif	
-
 	now = current_kernel_time();
 
 	header.pid = current->tgid;
@@ -639,19 +338,6 @@
 	header.nsec = now.tv_nsec;
 	header.len = min_t(size_t, iocb->ki_left, LOGGER_ENTRY_MAX_PAYLOAD);
 
-#ifdef ADD_SYSTEM_TIMEINFO
-	/* Follow the token with the time */
-	memset(tbuf, 0, sizeof(tbuf));
-
-	t = cpu_clock(logger_cpu);
-	nanosec_rem = do_div(t, 1000000000);
-	tlen = sprintf(tbuf, "[%5lu.%06lu] ",
-			(unsigned long) t,
-			nanosec_rem / 1000);
-	header.system_sec = (unsigned long) t;
-	header.system_nsec = nanosec_rem / 1000;
-#endif
-
 	/* null writes succeed, return zero */
 	if (unlikely(!header.len))
 		return 0;
@@ -692,22 +378,9 @@
 	/* wake up any blocked readers */
 	wake_up_interruptible(&log->wq);
 
-#ifdef CONFIG_APPLY_GA_SOLUTION
-// @message
-	if(strncmp(klog_buf, "!@", 2) == 0)
-	{
-		printk("%s\n",klog_buf);
-	}
-#endif
-
 	return ret;
 }
 
-unsigned long get_platform_reset_count(void)
-{
-	return platform_reset_count;
-}
-
 static struct logger_log *get_log_from_minor(int);
 
 /*
@@ -759,10 +432,7 @@
 {
 	if (file->f_mode & FMODE_READ) {
 		struct logger_reader *reader = file->private_data;
-		struct logger_log *log = reader->log;
-		mutex_lock(&log->mutex);
 		list_del(&reader->list);
-		mutex_unlock(&log->mutex);
 		kfree(reader);
 	}
 
@@ -885,7 +555,7 @@
 	.size = SIZE, \
 };
 
-DEFINE_LOGGER_DEVICE(log_main, LOGGER_LOG_MAIN, 512*1024)
+DEFINE_LOGGER_DEVICE(log_main, LOGGER_LOG_MAIN, 256*1024)
 DEFINE_LOGGER_DEVICE(log_events, LOGGER_LOG_EVENTS, 256*1024)
 DEFINE_LOGGER_DEVICE(log_radio, LOGGER_LOG_RADIO, 256*1024)
 DEFINE_LOGGER_DEVICE(log_system, LOGGER_LOG_SYSTEM, 256*1024)
@@ -914,90 +584,16 @@
 		return ret;
 	}
 
-	printk("logger: created %luK log '%s'\n",
+	printk(KERN_INFO "logger: created %luK log '%s'\n",
 	       (unsigned long) log->size >> 10, log->misc.name);
 
 	return 0;
 }
 
-#ifdef CONFIG_APPLY_GA_SOLUTION
-/* Mark for GetLog */
-
-struct struct_plat_log_mark  {
-	u32 special_mark_1;
-	u32 special_mark_2;
-	u32 special_mark_3;
-	u32 special_mark_4;
-	void *p_main;
-	void *p_radio;
-	void *p_events;
-	void *p_system;
-};
-
-struct struct_marks_ver_mark {
-  u32 special_mark_1;
-  u32 special_mark_2;
-  u32 special_mark_3;
-  u32 special_mark_4;
-  u32 log_mark_version;
-  u32 framebuffer_mark_version;
-  void * this;
-  u32 first_size;
-  u32 first_start_addr;
-  u32 second_size;
-  u32 second_start_addr;
-  u32 third_size;
-  u32 third_start_addr;
-};
-
-
-static struct struct_plat_log_mark plat_log_mark = {
-	.special_mark_1 = (('*' << 24) | ('^' << 16) | ('^' << 8) | ('*' << 0)),
-	.special_mark_2 = (('I' << 24) | ('n' << 16) | ('f' << 8) | ('o' << 0)),
-	.special_mark_3 = (('H' << 24) | ('e' << 16) | ('r' << 8) | ('e' << 0)),
-	.special_mark_4 = (('p' << 24) | ('l' << 16) | ('o' << 8) | ('g' << 0)),
-	.p_main = 0, 
-	.p_radio = 0,
-	.p_events = 0,
-	.p_system = 0, 
-};
-
-
-static struct struct_marks_ver_mark marks_ver_mark = {
-  .special_mark_1 = (('*' << 24) | ('^' << 16) | ('^' << 8) | ('*' << 0)),
-  .special_mark_2 = (('I' << 24) | ('n' << 16) | ('f' << 8) | ('o' << 0)),
-  .special_mark_3 = (('H' << 24) | ('e' << 16) | ('r' << 8) | ('e' << 0)),
-  .special_mark_4 = (('v' << 24) | ('e' << 16) | ('r' << 8) | ('s' << 0)),
-  .log_mark_version = 1,
-  .framebuffer_mark_version = 1,
-  .this=(&marks_ver_mark + 0x200000),
-  .first_size=256*1024*1024,
-  .first_start_addr=0x200000,
-  .second_size=0,
-  .second_start_addr=0,
-  .third_size=0,
-  .third_start_addr=0
-};
-#endif
-
 static int __init logger_init(void)
 {
 	int ret;
 
-#ifdef CONFIG_APPLY_GA_SOLUTION
-	/* Mark for GetLog */
-	plat_log_mark.p_main   = _buf_log_main+0x200000;
-	plat_log_mark.p_radio  = _buf_log_radio+0x200000;
-	plat_log_mark.p_events = _buf_log_events+0x200000;
-	plat_log_mark.p_system = _buf_log_system+0x200000;	
-	marks_ver_mark.log_mark_version = 1; 
-#endif
-
-#ifdef CONFIG_APPLY_GA_SOLUTION
-// GAF
-	gaf_helper();
-#endif
-
 	ret = init_log(&log_main);
 	if (unlikely(ret))
 		goto out;
diff -ru final2/drivers/staging/android/lowmemorykiller.c ics/drivers/staging/android/lowmemorykiller.c
--- final2/drivers/staging/android/lowmemorykiller.c	2014-08-29 08:16:33.848241000 +0200
+++ ics/drivers/staging/android/lowmemorykiller.c	2013-04-19 11:37:14.000000000 +0200
@@ -35,19 +35,8 @@
 #include <linux/oom.h>
 #include <linux/sched.h>
 #include <linux/notifier.h>
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-#include <linux/swap.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/mm_inline.h>
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 #include <linux/memory.h>
 #include <linux/memory_hotplug.h>
-//#define ENHANCED_LMK_ROUTINE
-
-#ifdef ENHANCED_LMK_ROUTINE
-#define LOWMEM_DEATHPENDING_DEPTH 3
-#endif
 
 static uint32_t lowmem_debug_level = 2;
 static int lowmem_adj[6] = {
@@ -64,42 +53,9 @@
 	16 * 1024,	/* 64MB */
 };
 static int lowmem_minfree_size = 4;
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-static struct class *lmk_class;
-static struct device *lmk_dev;
-static int lmk_kill_pid = 0;
-static int lmk_kill_ok = 0;
-
-extern atomic_t optimize_comp_on;
-
-extern int isolate_lru_page_compcache(struct page *page);
-extern void putback_lru_page(struct page *page);
-extern unsigned int zone_id_shrink_pagelist(struct zone *zone_id,struct list_head *page_list);
-
-#define lru_to_page(_head) (list_entry((_head)->prev, struct page, lru))
-
-#define SWAP_PROCESS_DEBUG_LOG 1
-/* free RAM 8M(2048 pages) */
-#define CHECK_FREE_MEMORY 2048
-/* free swap (10240 pages) */
-#define CHECK_FREE_SWAPSPACE  10240
-
-unsigned int check_free_memory;
-
-enum pageout_io {
-	PAGEOUT_IO_ASYNC,
-	PAGEOUT_IO_SYNC,
-};
-
-
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 
 static unsigned int offlining;
-#ifdef ENHANCED_LMK_ROUTINE
-static struct task_struct *lowmem_deathpending[LOWMEM_DEATHPENDING_DEPTH] = {NULL,};
-#else
 static struct task_struct *lowmem_deathpending;
-#endif
 static unsigned long lowmem_deathpending_timeout;
 
 #define lowmem_print(level, x...)			\
@@ -120,17 +76,9 @@
 {
 	struct task_struct *task = data;
 
-#ifdef ENHANCED_LMK_ROUTINE
-	int i = 0;
-	for (i = 0; i < LOWMEM_DEATHPENDING_DEPTH; i++)
-		if (task == lowmem_deathpending[i]) {
-			lowmem_deathpending[i] = NULL;
-		break;
-	}
-#else
 	if (task == lowmem_deathpending)
 		lowmem_deathpending = NULL;
-#endif
+
 	return NOTIFY_OK;
 }
 
@@ -163,30 +111,17 @@
 static int lowmem_shrink(struct shrinker *s, struct shrink_control *sc)
 {
 	struct task_struct *p;
-#ifdef ENHANCED_LMK_ROUTINE
-	struct task_struct *selected[LOWMEM_DEATHPENDING_DEPTH] = {NULL,};
-#else
 	struct task_struct *selected = NULL;
-#endif
 	int rem = 0;
 	int tasksize;
 	int i;
 	int min_adj = OOM_ADJUST_MAX + 1;
-#ifdef ENHANCED_LMK_ROUTINE
-	int selected_tasksize[LOWMEM_DEATHPENDING_DEPTH] = {0,};
-	int selected_oom_adj[LOWMEM_DEATHPENDING_DEPTH] = {OOM_ADJUST_MAX,};
-	int all_selected_oom = 0;
-#else
 	int selected_tasksize = 0;
 	int selected_oom_adj;
-#endif
 	int array_size = ARRAY_SIZE(lowmem_adj);
 	int other_free = global_page_state(NR_FREE_PAGES);
 	int other_file = global_page_state(NR_FILE_PAGES) -
 						global_page_state(NR_SHMEM);
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-	other_file -= total_swapcache_pages;
-#endif
 	struct zone *zone;
 
 	if (offlining) {
@@ -208,17 +143,9 @@
 	 * this pass.
 	 *
 	 */
-#ifdef ENHANCED_LMK_ROUTINE
-	for (i = 0; i < LOWMEM_DEATHPENDING_DEPTH; i++) {
-		if (lowmem_deathpending[i] &&
-			time_before_eq(jiffies, lowmem_deathpending_timeout))
-			return 0;
-	}
-#else
 	if (lowmem_deathpending &&
 	    time_before_eq(jiffies, lowmem_deathpending_timeout))
 		return 0;
-#endif
 
 	if (lowmem_adj_size < array_size)
 		array_size = lowmem_adj_size;
@@ -244,13 +171,7 @@
 			     sc->nr_to_scan, sc->gfp_mask, rem);
 		return rem;
 	}
-
-#ifdef ENHANCED_LMK_ROUTINE
-	for (i = 0; i < LOWMEM_DEATHPENDING_DEPTH; i++)
-		selected_oom_adj[i] = min_adj;
-#else
 	selected_oom_adj = min_adj;
-#endif
 
 	read_lock(&tasklist_lock);
 	for_each_process(p) {
@@ -274,31 +195,6 @@
 		task_unlock(p);
 		if (tasksize <= 0)
 			continue;
-
-#ifdef ENHANCED_LMK_ROUTINE
-		for (i = 0; i < LOWMEM_DEATHPENDING_DEPTH; i++) {
-			if (all_selected_oom >= LOWMEM_DEATHPENDING_DEPTH) {
-				if (oom_adj < selected_oom_adj[i])
-					continue;
-			if (oom_adj == selected_oom_adj[i] &&
-				tasksize <= selected_tasksize[i])
-				continue;
-			} else if (selected[i])
-				continue;
-
-			selected[i] = p;
-			selected_tasksize[i] = tasksize;
-			selected_oom_adj[i] = oom_adj;
-
-			if (all_selected_oom < LOWMEM_DEATHPENDING_DEPTH)
-				all_selected_oom++;
-
-			lowmem_print(2, "select %d (%s), adj %d, size %d, to kill\n",
-				p->pid, p->comm, oom_adj, tasksize);
-
-			break;
-		}
-#else
 		if (selected) {
 			if (oom_adj < selected_oom_adj)
 				continue;
@@ -311,21 +207,7 @@
 		selected_oom_adj = oom_adj;
 		lowmem_print(2, "select %d (%s), adj %d, size %d, to kill\n",
 			     p->pid, p->comm, oom_adj, tasksize);
-#endif
-	}
-#ifdef ENHANCED_LMK_ROUTINE
-	for (i = 0; i < LOWMEM_DEATHPENDING_DEPTH; i++) {
-		if (selected[i]) {
-			lowmem_print(1, "send sigkill to %d (%s), adj %d, size %d\n",
-				selected[i]->pid, selected[i]->comm,
-				selected_oom_adj[i], selected_tasksize[i]);
-		lowmem_deathpending[i] = selected[i];
-		lowmem_deathpending_timeout = jiffies + HZ;
-		force_sig(SIGKILL, selected[i]);
-		rem -= selected_tasksize[i];
-		}
 	}
-#else
 	if (selected) {
 		lowmem_print(1, "send sigkill to %d (%s), adj %d, size %d\n",
 			     selected->pid, selected->comm,
@@ -335,7 +217,6 @@
 		force_sig(SIGKILL, selected);
 		rem -= selected_tasksize;
 	}
-#endif
 	lowmem_print(4, "lowmem_shrink %lu, %x, return %d\n",
 		     sc->nr_to_scan, sc->gfp_mask, rem);
 	read_unlock(&tasklist_lock);
@@ -347,218 +228,10 @@
 	.seeks = DEFAULT_SEEKS * 16
 };
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-/*
- * zone_id_shrink_pagelist() clear page flags,
- * update the memory zone status, and swap pagelist
- */
-
-static unsigned int shrink_pages(struct mm_struct *mm,
-				 struct list_head *zone0_page_list,
-				 struct list_head *zone1_page_list,
-				 unsigned int num_to_scan)
-{
-	unsigned long addr;
-	unsigned int isolate_pages_countter = 0;
-
-	struct vm_area_struct *vma = mm->mmap;
-	while (vma != NULL) {
-
-		for (addr = vma->vm_start; addr < vma->vm_end;
-		     addr += PAGE_SIZE) {
-			struct page *page;
-			/*get the page address from virtual memory address */
-			page = follow_page(vma, addr, FOLL_GET);
-
-			if (page && !IS_ERR(page)) {
-
-				put_page(page);
-				/* only moveable, anonymous and not dirty pages can be swapped  */
-				if ((!PageUnevictable(page))
-				    && (!PageDirty(page)) && ((PageAnon(page)))
-				    && (0 == page_is_file_cache(page))) {
-					switch (page_zone_id(page)) {
-					case 0:
-						if (!isolate_lru_page_compcache(page)) {
-							/* isolate page from LRU and add to temp list  */
-							/*create new page list, it will be used in shrink_page_list */
-							list_add_tail(&page->lru, zone0_page_list);
-							isolate_pages_countter++;
-						}
-						break;
-					case 1:
-						if (!isolate_lru_page_compcache(page)) {
-							/* isolate page from LRU and add to temp list  */
-							/*create new page list, it will be used in shrink_page_list */
-							list_add_tail(&page->lru, zone1_page_list);
-							isolate_pages_countter++;
-						}
-						break;
-					default:
-						break;
-					}
-				}
-			}
-
-			if (isolate_pages_countter >= num_to_scan) {
-				return isolate_pages_countter;
-			}
-		}
-
-		vma = vma->vm_next;
-	}
-
-	return isolate_pages_countter;
-}
-
-/*
- * swap_application_pages() will search the
- * pages which can be swapped, then call
- * zone_id_shrink_pagelist to update zone
- * status
- */
-static unsigned int swap_pages(struct list_head *zone0_page_list,
-								struct list_head *zone1_page_list)
-{
-        struct zone *zone_id_0 = &NODE_DATA(0)->node_zones[0];
-        struct zone *zone_id_1 = &NODE_DATA(0)->node_zones[1];
-	unsigned int pages_counter = 0;
-
-	/*if the page list is not empty, call zone_id_shrink_pagelist to update zone status */
-	if ((zone_id_0) && (!list_empty(zone0_page_list))) {
-		pages_counter +=
-		    zone_id_shrink_pagelist(zone_id_0, zone0_page_list);
-	}
-	if ((zone_id_1) && (!list_empty(zone1_page_list))) {
-		pages_counter +=
-		    zone_id_shrink_pagelist(zone_id_1, zone1_page_list);
-	}
-	return pages_counter;
-}
-
-static ssize_t lmk_state_show(struct device *dev,
-			      struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d,%d\n", lmk_kill_pid, lmk_kill_ok);
-}
-
-/*
- * lmk_state_store() will called by framework,
- * the framework will send the pid of process that need to be swapped
- */
-static ssize_t lmk_state_store(struct device *dev,
-			       struct device_attribute *attr,
-			       const char *buf, size_t size)
-{
-	sscanf(buf, "%d,%d", &lmk_kill_pid, &lmk_kill_ok);
-
-	/* if the screen on, the optimized compcache will stop */
-	if (atomic_read(&optimize_comp_on) != 1)
-		return size;
-
-	if (lmk_kill_ok == 1) {
-		struct task_struct *p;
-		struct task_struct *selected = NULL;
-		struct sysinfo ramzswap_info = { 0 };
-
-		/*
-		 * check the free RAM and swap area,
-		 * stop the optimized compcache in cpu idle case;
-		 * leave some swap area for using in low memory case
-		 */
-		si_swapinfo(&ramzswap_info);
-		si_meminfo(&ramzswap_info);
-
-		if ((ramzswap_info.freeswap < CHECK_FREE_SWAPSPACE) ||
-		    (ramzswap_info.freeram < check_free_memory)) {
-			printk("idletime compcache is ignored : free RAM %lu, free swap %lu\n",
-				ramzswap_info.freeram, ramzswap_info.freeswap);
-			lmk_kill_ok = 0;
-			return size;
-		}
-
-		read_lock(&tasklist_lock);
-		for_each_process(p) {
-			if ((p->pid == lmk_kill_pid) &&
-			    (__task_cred(p)->uid > 10000)) {
-				task_lock(p);
-				selected = p;
-				if (!selected->mm || !selected->signal) {
-				task_unlock(p);
-				selected = NULL;
-				break;
-		        }
-#if SWAP_PROCESS_DEBUG_LOG > 0
-				#if !defined(CONFIG_MACH_KYLE)
-				printk
-				    ("idletime compcache: swap process pid %d, name %s, oom %d, task_size %ld\n",
-				     p->pid, p->comm, p->signal->oom_adj,
-				     get_mm_rss(p->mm));
-				#endif
-#endif
-				break;
-			}
-		}
-		read_unlock(&tasklist_lock);
-
-		if (selected) {
-			LIST_HEAD(zone0_page_list);
-			LIST_HEAD(zone1_page_list);
-			int pages_tofree = 0, pages_freed = 0;
-
-			pages_tofree =
-			    shrink_pages(selected->mm, &zone0_page_list,
-						&zone1_page_list, 0x7FFFFFFF);
-			task_unlock(selected);
-			pages_freed =
-			    swap_pages(&zone0_page_list,
-				       &zone1_page_list);
-			lmk_kill_ok = 0;
-
-		}
-	}
-
-	return size;
-}
-
-static DEVICE_ATTR(lmk_state, 0666, lmk_state_show, lmk_state_store);
-
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-
 static int __init lowmem_init(void)
 {
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-	struct zone *zone;
-	unsigned int high_wmark = 0;
-#endif
-
 	task_free_register(&task_nb);
 	register_shrinker(&lowmem_shrinker);
-
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-	for_each_zone(zone) {
-		if (high_wmark < zone->watermark[WMARK_HIGH])
-			high_wmark = zone->watermark[WMARK_HIGH];
-	}
-	check_free_memory = (high_wmark != 0) ? high_wmark : CHECK_FREE_MEMORY;
-
-	lmk_class = class_create(THIS_MODULE, "lmk");
-	if (IS_ERR(lmk_class)) {
-		printk(KERN_ERR "Failed to create class(lmk)\n");
-		return 0;
-	}
-	lmk_dev = device_create(lmk_class, NULL, 0, NULL, "lowmemorykiller");
-	if (IS_ERR(lmk_dev)) {
-		printk(KERN_ERR
-		       "Failed to create device(lowmemorykiller)!= %ld\n",
-		       IS_ERR(lmk_dev));
-		return 0;
-	}
-	if (device_create_file(lmk_dev, &dev_attr_lmk_state) < 0)
-		printk(KERN_ERR "Failed to create device file(%s)!\n",
-		       dev_attr_lmk_state.attr.name);
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-
 #ifdef CONFIG_MEMORY_HOTPLUG
 	hotplug_memory_notifier(lmk_hotplug_callback, 0);
 #endif
diff -ru final2/drivers/staging/rtl8712/rtl871x_mp.c ics/drivers/staging/rtl8712/rtl871x_mp.c
--- final2/drivers/staging/rtl8712/rtl871x_mp.c	2014-08-29 08:16:34.348241000 +0200
+++ ics/drivers/staging/rtl8712/rtl871x_mp.c	2013-04-19 11:37:14.000000000 +0200
@@ -1,26 +1,16 @@
 /******************************************************************************
+ * rtl871x_mp.c
  *
- * Copyright(c) 2007 - 2010 Realtek Corporation. All rights reserved.
+ * Description :
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- * Modifications for inclusion into the Linux staging tree are
- * Copyright(c) 2010 Larry Finger. All rights reserved.
- *
- * Contact information:
- * WLAN FAE <wlanfae@realtek.com>
- * Larry Finger <Larry.Finger@lwfinger.net>
+ * Author :
+ *
+ * History :
+ *
+ * Copyright 2007, Realtek Corp.
+ *
+ * The contents of this file is the sole property of Realtek Corp. It can not be
+ * be used, copied or modified without written permission from Realtek Corp.
  *
 *******************************************************************************/
 #define _RTL871X_MP_C_
diff -ru final2/drivers/staging/zram/Kconfig ics/drivers/staging/zram/Kconfig
--- final2/drivers/staging/zram/Kconfig	2014-08-29 08:16:34.524241000 +0200
+++ ics/drivers/staging/zram/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -28,10 +28,3 @@
 	help
 	  This option adds additional debugging code to the compressed
 	  RAM block device driver.
-
-config ZRAM_FOR_ANDROID
-	bool "Optimize zram behavior for android"
-	depends on ZRAM && ANDROID
-	default n
-	help
-	  This option enables modified zram behavior optimized for android
diff -ru final2/drivers/staging/zram/zram_drv.c ics/drivers/staging/zram/zram_drv.c
--- final2/drivers/staging/zram/zram_drv.c	2014-08-29 08:16:34.524241000 +0200
+++ ics/drivers/staging/zram/zram_drv.c	2013-04-19 11:37:14.000000000 +0200
@@ -32,9 +32,6 @@
 #include <linux/lzo.h>
 #include <linux/string.h>
 #include <linux/vmalloc.h>
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-#include <linux/swap.h>
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 
 #include "zram_drv.h"
 
@@ -136,22 +133,6 @@
 	zram->disksize &= PAGE_MASK;
 }
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-/*
- * Swap header (1st page of swap device) contains information
- * about a swap file/partition. Prepare such a header for the
- * given ramzswap device so that swapon can identify it as a
- * swap partition.
- */
-static void setup_swap_header(struct zram *zram, union swap_header *s)
-{
-	s->info.version = 1;
-	s->info.last_page = (zram->disksize >> PAGE_SHIFT) - 1;
-	s->info.nr_badpages = 0;
-	memcpy(s->magic.magic, "SWAPSPACE2", 10);
-}
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-
 static void zram_free_page(struct zram *zram, size_t index)
 {
 	u32 clen;
@@ -520,10 +501,6 @@
 {
 	int ret;
 	size_t num_pages;
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-	struct page *page;
-	union swap_header *swap_header;
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 
 	mutex_lock(&zram->init_lock);
 
@@ -558,19 +535,6 @@
 		goto fail;
 	}
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-	page = alloc_page(__GFP_ZERO);
-	if (!page) {
-		pr_err("Error allocating swap header page\n");
-		ret = -ENOMEM;
-		goto fail;
-	}
-	zram->table[0].page = page;
-	zram_set_flag(zram, 0, ZRAM_UNCOMPRESSED);
-	swap_header = kmap(page);
-	setup_swap_header(zram, swap_header);
-	kunmap(page);
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 	set_capacity(zram->disk, zram->disksize >> SECTOR_SHIFT);
 
 	/* zram devices sort of resembles non-rotational disks */
diff -ru final2/drivers/staging/zram/zram_sysfs.c ics/drivers/staging/zram/zram_sysfs.c
--- final2/drivers/staging/zram/zram_sysfs.c	2014-08-29 08:16:34.524241000 +0200
+++ ics/drivers/staging/zram/zram_sysfs.c	2013-04-19 11:37:14.000000000 +0200
@@ -80,41 +80,6 @@
 	return sprintf(buf, "%u\n", zram->init_done);
 }
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-extern int swapon(const char*specialfile, int swap_flags);
-
-static ssize_t initstate_store(struct device *dev,
-			       struct device_attribute *attr, const char *buf,
-			       size_t len)
-{
-	int ret;
-	unsigned long do_init;
-	struct zram *zram = dev_to_zram(dev);
-
-	if (zram->init_done) {
-		pr_info("the device is initialized device\n");
-		return -EBUSY;
-	}
-
-	ret = strict_strtoul(buf, 10, &do_init);
-	if (ret)
-		return ret;
-	if (!do_init)
-		return -EINVAL;
-
-	zram_init_device(zram);
-	swapon("/dev/block/zram0", 0);
-	return len;
-}
-#else
-static inline ssize_t initstate_store(struct device *dev,
-				      struct device_attribute *attr,
-				      const char *buf, size_t len)
-{
-	return 0;
-}
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-
 static ssize_t reset_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t len)
 {
@@ -225,7 +190,7 @@
 
 static DEVICE_ATTR(disksize, S_IRUGO | S_IWUSR,
 		disksize_show, disksize_store);
-static DEVICE_ATTR(initstate, S_IRUGO | S_IWUSR, initstate_show, initstate_store);
+static DEVICE_ATTR(initstate, S_IRUGO, initstate_show, NULL);
 static DEVICE_ATTR(reset, S_IWUSR, NULL, reset_store);
 static DEVICE_ATTR(num_reads, S_IRUGO, num_reads_show, NULL);
 static DEVICE_ATTR(num_writes, S_IRUGO, num_writes_show, NULL);
diff -ru final2/drivers/thermal/msm_thermal.c ics/drivers/thermal/msm_thermal.c
--- final2/drivers/thermal/msm_thermal.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/thermal/msm_thermal.c	2013-04-19 11:37:14.000000000 +0200
@@ -91,16 +91,6 @@
 					 "already < allowed_max_freq\n", cpu);
 			}
 		} else if (temp < allowed_max_low) {
-#ifdef CONFIG_SEC_DVFS
-			if (cpufreq_get_dvfs_state() != 1) {
-				if (cpu_policy->max
-					< cpu_policy->cpuinfo.max_freq) {
-					max_freq = cpu_policy->cpuinfo.max_freq;
-					update_policy = 1;
-				}
-			} else
-				update_policy = 0;
-#else
 			if (cpu_policy->max < cpu_policy->cpuinfo.max_freq) {
 				max_freq = cpu_policy->cpuinfo.max_freq;
 				update_policy = 1;
@@ -108,7 +98,6 @@
 				pr_debug("msm_thermal: policy max for cpu %d "
 					 "already at max allowed\n", cpu);
 			}
-#endif
 		}
 
 		if (update_policy)
diff -ru final2/drivers/tty/serial/msm_serial_hs.c ics/drivers/tty/serial/msm_serial_hs.c
--- final2/drivers/tty/serial/msm_serial_hs.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/tty/serial/msm_serial_hs.c	2013-04-19 11:37:14.000000000 +0200
@@ -63,24 +63,6 @@
 
 #include "msm_serial_hs_hwreg.h"
 
-#ifdef CONFIG_BT_CSR_7820
-#define ALRAN
-#endif
-#ifdef ALRAN
-#include <linux/sched.h>
-#define MAX_KERNEL_IRQ_LOGS	(2000)
-
-struct ScheduleLogData {
-	ktime_t time;
-	unsigned int unPid;
-	unsigned long isr_status;
-	unsigned long sr_status;
-};
-
-static struct ScheduleLogData pHSLogData[MAX_KERNEL_IRQ_LOGS];
-static int nNextLogIdx;
-#endif
-
 static int hs_serial_debug_mask = 1;
 module_param_named(debug_mask, hs_serial_debug_mask,
 		   int, S_IRUGO | S_IWUSR | S_IWGRP);
@@ -174,10 +156,6 @@
 	int dma_rx_crci;
 	struct hrtimer clk_off_timer;  /* to poll TXEMT before clock off */
 	ktime_t clk_off_delay;
-#ifdef ALRAN
-	struct hrtimer qtest_timer;  /* test force clock on & off */
-	ktime_t qtest_delay;
-#endif
 	enum msm_hs_clk_states_e clk_state;
 	enum msm_hs_clk_req_off_state_e clk_req_off_state;
 
@@ -808,13 +786,6 @@
 	if (data & UARTDM_SR_TXEMT_BMSK)
 		ret = TIOCSER_TEMT;
 
-#ifdef CONFIG_BT_CSR_7820
-	if (ret == TIOCSER_TEMT && (data & UARTDM_SR_RXRDY_BMSK) == 0)
-		ret = TIOCSER_TEMT;
-	else
-		ret = 0;
-#endif
-
 	clk_disable(msm_uport->clk);
 
 	return ret;
@@ -1420,98 +1391,10 @@
 	return ret;
 }
 
-#ifdef ALRAN
-
-#define OVERRUN_CNT 50
-#define OVERRUN_DELAY 100000000 /* 100ms */
-
-static int u_overrun_cnt;
-static int buf_overrun;
-
-void u_overrun_clock_off(struct uart_port *uport)
-{
-	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
-	unsigned long flags;
-
-	spin_lock_irqsave(&uport->lock, flags);
-
-	/* Stop RX & TX */
-	msm_hs_stop_rx_locked(uport);
-	msm_hs_stop_tx_locked(uport);
-
-	/* we really want to clock off */
-	clk_disable(msm_uport->clk);
-
-	if (msm_uport->pclk)
-		clk_disable(msm_uport->pclk);
-
-	msm_uport->clk_state = MSM_HS_CLK_OFF;
-
-	/*calling u_overrun_clock_on() after 100ms*/
-
-	hrtimer_start(&msm_uport->qtest_timer,
-			  msm_uport->qtest_delay,
-			  HRTIMER_MODE_REL);
-
-	u_overrun_cnt++;
-	pr_err("NEOBT u_overrun_cnt: %d\n", u_overrun_cnt);
-
-	spin_unlock_irqrestore(&uport->lock, flags);
-}
-
-static enum hrtimer_restart u_overrun_clock_on(struct hrtimer *timer)
-{
-	struct msm_hs_port *msm_uport = container_of(timer, struct msm_hs_port,
-						     qtest_timer);
-	struct uart_port *uport = &msm_uport->uport;
-	unsigned long flags;
-	unsigned int data;
-	int ret = HRTIMER_NORESTART;
-
-	spin_lock_irqsave(&uport->lock, flags);
-
-	/* Start TX */
-	msm_hs_start_tx_locked(uport);
-	clk_enable(msm_uport->clk);
-
-	if (msm_uport->pclk)
-		ret = clk_enable(msm_uport->pclk);
-
-	if (unlikely(ret)) {
-		dev_err(uport->dev, "Clock ON Failure"
-			"Stalling HSUART\n");
-		hrtimer_forward_now(timer, msm_uport->qtest_delay);
-		return HRTIMER_RESTART;
-	}
-
-	/* Start RX */
-	if (msm_uport->rx.flush == FLUSH_STOP ||
-		msm_uport->rx.flush == FLUSH_SHUTDOWN) {
-		msm_hs_write(uport, UARTDM_CR_ADDR, RESET_RX);
-		data = msm_hs_read(uport, UARTDM_DMEN_ADDR);
-		data |= UARTDM_RX_DM_EN_BMSK;
-		msm_hs_write(uport, UARTDM_DMEN_ADDR, data);
-		/* Complete above device write. Hence mb() here. */
-		mb();
-	}
-
-	msm_hs_start_rx_locked(uport);
-
-	if (msm_uport->rx.flush == FLUSH_STOP)
-		msm_uport->rx.flush = FLUSH_IGNORE;
-	msm_uport->clk_state = MSM_HS_CLK_ON;
-	spin_unlock_irqrestore(&uport->lock, flags);
-	return ret;
-}
-#endif
-
 static irqreturn_t msm_hs_isr(int irq, void *dev)
 {
 	unsigned long flags;
 	unsigned long isr_status;
-#ifdef ALRAN
-	unsigned long sr_status;
-#endif
 	struct msm_hs_port *msm_uport = (struct msm_hs_port *)dev;
 	struct uart_port *uport = &msm_uport->uport;
 	struct circ_buf *tx_buf = &uport->state->xmit;
@@ -1522,38 +1405,6 @@
 
 	isr_status = msm_hs_read(uport, UARTDM_MISR_ADDR);
 
-#ifdef ALRAN
-	pHSLogData[nNextLogIdx].time = ktime_get();
-	pHSLogData[nNextLogIdx].unPid = current->pid;
-	pHSLogData[nNextLogIdx].isr_status = isr_status;
-	sr_status = msm_hs_read(uport, UARTDM_SR_ADDR);
-	pHSLogData[nNextLogIdx].sr_status = sr_status;
-
-	/* extra check for spurious msm_hs_isr */
-	if(!isr_status) {
-		pr_err("%s(): try to unlock msm_hs_isr", __func__);
-		spin_unlock_irqrestore(&uport->lock, flags);
-		return IRQ_HANDLED;
-	}
-
-	/*Adding this line for using overrun workaround*/
-	if (sr_status & UARTDM_SR_OVERRUN_BMSK) {
-		buf_overrun++;
-
-		if (buf_overrun == OVERRUN_CNT) {
-			buf_overrun = 0;
-			u_overrun_clock_off(uport);
-			spin_unlock_irqrestore(&uport->lock, flags);
-			return IRQ_HANDLED;
-		}
-	}
-
-	nNextLogIdx++;
-	if (nNextLogIdx == MAX_KERNEL_IRQ_LOGS)
-		nNextLogIdx = 0;
-	pHSLogData[nNextLogIdx].unPid = 0xAAAAAAAA;
-#endif
-
 	/* Uart RX starting */
 	if (isr_status & UARTDM_ISR_RXLEV_BMSK) {
 		wake_lock(&rx->wake_lock);  /* hold wakelock while rx dma */
@@ -1858,10 +1709,6 @@
 		dev_err(uport->dev, "set active error:%d\n", ret);
 	pm_runtime_enable(uport->dev);
 
-#ifdef CONFIG_BT_CSR_7820
-	/* Temp. patch for Bluetooth hci timeout */
-	pm_runtime_get_sync(uport->dev);
-#endif
 
 	return 0;
 }
@@ -2095,13 +1942,6 @@
 	msm_uport->clk_off_timer.function = msm_hs_clk_off_retry;
 	msm_uport->clk_off_delay = ktime_set(0, 1000000);  /* 1ms */
 
-#ifdef ALRAN
-	hrtimer_init(&msm_uport->qtest_timer, CLOCK_MONOTONIC,
-		     HRTIMER_MODE_REL);
-	msm_uport->qtest_timer.function = u_overrun_clock_on;
-	msm_uport->qtest_delay = ktime_set(0, OVERRUN_DELAY);  /* 100ms */
-#endif
-
 	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_clock.attr);
 	if (unlikely(ret))
 		return ret;
@@ -2159,20 +1999,10 @@
 	tasklet_kill(&msm_uport->rx.tlet);
 	cancel_delayed_work_sync(&msm_uport->rx.flip_insert_work);
 
-#ifdef CONFIG_BT_CSR_7820
-	/* Moved free irq on top of shutdown because of deadlock issue */
-	/* Free the interrupt */
-	free_irq(uport->irq, msm_uport);
-#endif
-
 	clk_enable(msm_uport->clk);
 
 	pm_runtime_disable(uport->dev);
 	pm_runtime_set_suspended(uport->dev);
-#ifdef CONFIG_BT_CSR_7820
-	/* Temp. patch for Bluetooth hci timeout */
-	pm_runtime_put_sync(uport->dev);
-#endif
 
 	spin_lock_irqsave(&uport->lock, flags);
 	/* Disable the transmitter */
@@ -2205,11 +2035,8 @@
 	if (use_low_power_wakeup(msm_uport))
 		irq_set_irq_wake(msm_uport->wakeup.irq, 0);
 
-#ifndef CONFIG_BT_CSR_7820
 	/* Free the interrupt */
 	free_irq(uport->irq, msm_uport);
-#endif
-
 	if (use_low_power_wakeup(msm_uport))
 		free_irq(msm_uport->wakeup.irq, msm_uport);
 }
diff -ru final2/drivers/tty/vt/vt_ioctl.c ics/drivers/tty/vt/vt_ioctl.c
--- final2/drivers/tty/vt/vt_ioctl.c	2014-08-29 08:16:34.612241000 +0200
+++ ics/drivers/tty/vt/vt_ioctl.c	2013-04-19 11:37:14.000000000 +0200
@@ -1743,7 +1743,7 @@
 
 /* Perform a kernel triggered VT switch for suspend/resume */
 
-static int disable_vt_switch = 1;
+static int disable_vt_switch;
 
 int vt_move_to_console(unsigned int vt, int alloc)
 {
diff -ru final2/drivers/usb/gadget/android.c ics/drivers/usb/gadget/android.c
--- final2/drivers/usb/gadget/android.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/gadget/android.c	2013-04-19 11:37:14.000000000 +0200
@@ -46,6 +46,7 @@
 #include "config.c"
 #include "epautoconf.c"
 #include "composite.c"
+
 #include "f_diag.c"
 #include "f_rmnet_smd.c"
 #include "f_rmnet_sdio.c"
@@ -59,28 +60,16 @@
 #include "u_rmnet_ctrl_smd.c"
 #include "u_ctrl_hsic.c"
 #include "u_data_hsic.c"
-#ifdef CONFIG_USB_DUN_SUPPORT
-#include "serial_acm.c"
-#endif
-#ifdef CONFIG_USB_ACM
-#include "f_acm.c"
-#else
 #include "f_serial.c"
-#endif
+#include "f_acm.c"
 #include "f_adb.c"
 #include "f_ccid.c"
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_MTP
-#include "f_mtp_samsung.c"
-#else
 #include "f_mtp.c"
-#endif
 #include "f_accessory.c"
 #define USB_ETH_RNDIS y
-#ifdef CONFIG_USB_ANDROID_RNDIS
 #include "f_rndis.c"
 #include "rndis.c"
 #include "u_ether.c"
-#endif
 
 MODULE_AUTHOR("Mike Lockwood");
 MODULE_DESCRIPTION("Android Composite USB Driver");
@@ -89,7 +78,7 @@
 
 static const char longname[] = "Gadget Android";
 
-/* Default vendor and product IDs, overridden by platform data */
+/* Default vendor and product IDs, overridden by userspace */
 #define VENDOR_ID		0x18D1
 #define PRODUCT_ID		0x0001
 
@@ -109,12 +98,10 @@
 	/* Optional: cleanup during gadget unbind */
 	void (*cleanup)(struct android_usb_function *);
 
-	int (*bind_config)(struct android_usb_function *,
-		struct usb_configuration *);
+	int (*bind_config)(struct android_usb_function *, struct usb_configuration *);
 
 	/* Optional: called when the configuration is removed */
-	void (*unbind_config)(struct android_usb_function *,
-		struct usb_configuration *);
+	void (*unbind_config)(struct android_usb_function *, struct usb_configuration *);
 	/* Optional: handle ctrl requests before the device is configured */
 	int (*ctrlrequest)(struct android_usb_function *,
 					struct usb_composite_dev *,
@@ -182,11 +169,7 @@
 	.unbind		= android_unbind_config,
 	.bConfigurationValue = 1,
 	.bmAttributes	= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	.bMaxPower	= 0x30, /* 96ma */
-#else /* original */
 	.bMaxPower	= 0xFA, /* 500ma */
-#endif /* CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE */
 };
 
 enum android_device_state {
@@ -206,9 +189,6 @@
 	static enum android_device_state last_uevent, next_state;
 	unsigned long flags;
 
-	printk(KERN_DEBUG "usb: %s config=%p,connected=%d,sw_connected=%d\n",
-			__func__, cdev->config, dev->connected,
-			dev->sw_connected);
 	spin_lock_irqsave(&cdev->lock, flags);
 	if (cdev->config) {
 		uevent_envp = configured;
@@ -407,8 +387,8 @@
 }
 
 static DEVICE_ATTR(clients, S_IWUSR, NULL, clients_store);
-static struct device_attribute *diag_function_attributes[] =	{
-	&dev_attr_clients, NULL };
+static struct device_attribute *diag_function_attributes[] =
+					 { &dev_attr_clients, NULL };
 
 static int diag_function_init(struct android_usb_function *f,
 				 struct usb_composite_dev *cdev)
@@ -457,62 +437,64 @@
 	.attributes	= diag_function_attributes,
 };
 
-#ifdef CONFIG_USB_ACM
-
-/* ACM */
-static char acm_transports[32];	/*enabled ACM ports - "tty[,sdio]"*/
-static ssize_t acm_transports_store(
-	struct device *device, struct device_attribute *attr,
-	const char *buff, size_t size)
+/* SERIAL */
+static char serial_transports[32];	/*enabled FSERIAL ports - "tty[,sdio]"*/
+static ssize_t serial_transports_store(
+		struct device *device, struct device_attribute *attr,
+		const char *buff, size_t size)
 {
-	strlcpy(acm_transports, buff, sizeof(acm_transports));
+	strlcpy(serial_transports, buff, sizeof(serial_transports));
+
 	return size;
 }
 
-static DEVICE_ATTR(acm_transports, S_IWUSR, NULL, acm_transports_store);
-static struct device_attribute *acm_function_attributes[] = {
-			&dev_attr_acm_transports, NULL };
+static DEVICE_ATTR(transports, S_IWUSR, NULL, serial_transports_store);
+static struct device_attribute *serial_function_attributes[] =
+					 { &dev_attr_transports, NULL };
 
-static void acm_function_cleanup(struct android_usb_function *f)
+static void serial_function_cleanup(struct android_usb_function *f)
 {
 	gserial_cleanup();
 }
 
-static int acm_function_bind_config(struct android_usb_function *f,
+static int serial_function_bind_config(struct android_usb_function *f,
 					struct usb_configuration *c)
 {
 	char *name;
 	char buf[32], *b;
 	int err = -1, i;
-	static int acm_initialized, ports;
+	static int serial_initialized = 0, ports = 0;
 
-	if (acm_initialized)
+	if (serial_initialized)
 		goto bind_config;
 
-	acm_initialized = 1;
-	strlcpy(buf, acm_transports, sizeof(buf));
+	serial_initialized = 1;
+	strlcpy(buf, serial_transports, sizeof(buf));
 	b = strim(buf);
+
 	while (b) {
 		name = strsep(&b, ",");
+
 		if (name) {
-			err = acm_init_port(ports, name);
+			err = gserial_init_port(ports, name);
 			if (err) {
-				pr_err("acm: Cannot open port '%s'", name);
+				pr_err("serial: Cannot open port '%s'", name);
 				goto out;
 			}
 			ports++;
 		}
 	}
-	err = acm_port_setup(c);
+	err = gport_setup(c);
 	if (err) {
-		pr_err("acm: Cannot setup transports");
+		pr_err("serial: Cannot setup transports");
 		goto out;
 	}
+
 bind_config:
-	for (i = 0; i < ports; i++) {
-		err = acm_bind_config(c, i);
+	for (i = 0; i < ports; i++) { 
+		err = gser_bind_config(c, i);
 		if (err) {
-			pr_err("acm: bind_config failed for port %d", i);
+			pr_err("serial: bind_config failed for port %d", i);
 			goto out;
 		}
 	}
@@ -520,72 +502,72 @@
 out:
 	return err;
 }
-static struct android_usb_function acm_function = {
-	.name		= "acm",
-	.cleanup	= acm_function_cleanup,
-	.bind_config	= acm_function_bind_config,
-	.attributes	= acm_function_attributes,
+
+static struct android_usb_function serial_function = {
+	.name		= "serial",
+	.cleanup	= serial_function_cleanup,
+	.bind_config	= serial_function_bind_config,
+	.attributes	= serial_function_attributes,
 };
 
-#else
-/* SERIAL */
-static char serial_transports[32];	/*enabled FSERIAL ports - "tty[,sdio]"*/
-static ssize_t serial_transports_store(
+/* ACM */
+static char acm_transports[32];	/*enabled ACM ports - "tty[,sdio]"*/
+static ssize_t acm_transports_store(
 		struct device *device, struct device_attribute *attr,
 		const char *buff, size_t size)
 {
-	strlcpy(serial_transports, buff, sizeof(serial_transports));
+	strlcpy(acm_transports, buff, sizeof(acm_transports));
 
 	return size;
 }
 
-static DEVICE_ATTR(transports, S_IWUSR, NULL, serial_transports_store);
-static struct device_attribute *serial_function_attributes[] = {
-			&dev_attr_transports, NULL };
+static DEVICE_ATTR(acm_transports, S_IWUSR, NULL, acm_transports_store);
+static struct device_attribute *acm_function_attributes[] = {
+		&dev_attr_acm_transports, NULL };
 
-static void serial_function_cleanup(struct android_usb_function *f)
+static void acm_function_cleanup(struct android_usb_function *f)
 {
 	gserial_cleanup();
 }
 
-static int serial_function_bind_config(struct android_usb_function *f,
+static int acm_function_bind_config(struct android_usb_function *f,
 					struct usb_configuration *c)
 {
 	char *name;
 	char buf[32], *b;
 	int err = -1, i;
-	static int serial_initialized, ports;
+	static int acm_initialized, ports;
 
-	if (serial_initialized)
+	if (acm_initialized)
 		goto bind_config;
 
-	serial_initialized = 1;
-	strlcpy(buf, serial_transports, sizeof(buf));
+	acm_initialized = 1;
+	strlcpy(buf, acm_transports, sizeof(buf));
 	b = strim(buf);
 
 	while (b) {
 		name = strsep(&b, ",");
 
 		if (name) {
-			err = gserial_init_port(ports, name);
+			err = acm_init_port(ports, name);
 			if (err) {
-				pr_err("serial: Cannot open port '%s'", name);
+				pr_err("acm: Cannot open port '%s'", name);
 				goto out;
 			}
 			ports++;
 		}
 	}
-	err = gport_setup(c);
+	err = acm_port_setup(c);
 	if (err) {
-		pr_err("serial: Cannot setup transports");
+		pr_err("acm: Cannot setup transports");
 		goto out;
 	}
 
 bind_config:
 	for (i = 0; i < ports; i++) {
-		err = gser_bind_config(c, i);
+		err = acm_bind_config(c, i);
 		if (err) {
-			pr_err("serial: bind_config failed for port %d", i);
+			pr_err("acm: bind_config failed for port %d", i);
 			goto out;
 		}
 	}
@@ -593,18 +575,15 @@
 out:
 	return err;
 }
-
-static struct android_usb_function serial_function = {
-	.name		= "serial",
-	.cleanup	= serial_function_cleanup,
-	.bind_config	= serial_function_bind_config,
-	.attributes	= serial_function_attributes,
+static struct android_usb_function acm_function = {
+	.name		= "acm",
+	.cleanup	= acm_function_cleanup,
+	.bind_config	= acm_function_bind_config,
+	.attributes	= acm_function_attributes,
 };
-#endif
 
 /* ADB */
-static int adb_function_init(struct android_usb_function *f,
-					struct usb_composite_dev *cdev)
+static int adb_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
 {
 	return adb_setup();
 }
@@ -614,8 +593,7 @@
 	adb_cleanup();
 }
 
-static int adb_function_bind_config(struct android_usb_function *f,
-					struct usb_configuration *c)
+static int adb_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
 {
 	return adb_bind_config(c);
 }
@@ -652,8 +630,7 @@
 	.bind_config	= ccid_function_bind_config,
 };
 
-static int mtp_function_init(struct android_usb_function *f,
-					struct usb_composite_dev *cdev)
+static int mtp_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
 {
 	return mtp_setup();
 }
@@ -663,14 +640,12 @@
 	mtp_cleanup();
 }
 
-static int mtp_function_bind_config(struct android_usb_function *f,
-					struct usb_configuration *c)
+static int mtp_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
 {
 	return mtp_bind_config(c, false);
 }
 
-static int ptp_function_init(struct android_usb_function *f,
-				struct usb_composite_dev *cdev)
+static int ptp_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
 {
 	/* nothing to do - initialization is handled by mtp_function_init */
 	return 0;
@@ -681,8 +656,7 @@
 	/* nothing to do - cleanup is handled by mtp_function_cleanup */
 }
 
-static int ptp_function_bind_config(struct android_usb_function *f,
-				struct usb_configuration *c)
+static int ptp_function_bind_config(struct android_usb_function *f, struct usb_configuration *c)
 {
 	return mtp_bind_config(c, true);
 }
@@ -710,7 +684,6 @@
 	.bind_config	= ptp_function_bind_config,
 };
 
-#ifdef CONFIG_USB_ANDROID_RNDIS
 
 struct rndis_function_config {
 	u8      ethaddr[ETH_ALEN];
@@ -719,8 +692,7 @@
 	bool	wceis;
 };
 
-static int rndis_function_init(struct android_usb_function *f,
-				struct usb_composite_dev *cdev)
+static int rndis_function_init(struct android_usb_function *f, struct usb_composite_dev *cdev)
 {
 	f->config = kzalloc(sizeof(struct rndis_function_config), GFP_KERNEL);
 	if (!f->config)
@@ -895,8 +867,6 @@
 	.attributes	= rndis_function_attributes,
 };
 
-#endif /*CONFIG_USB_ANDROID_RNDIS*/
-
 
 struct mass_storage_function_config {
 	struct fsg_config fsg;
@@ -914,17 +884,9 @@
 								GFP_KERNEL);
 	if (!config)
 		return -ENOMEM;
-#ifdef CONFIG_USB_MASS_STORAGE_SUPPORT_LUN2
-	config->fsg.nluns = 2;
-#else
+
 	config->fsg.nluns = 1;
-#endif
 	config->fsg.luns[0].removable = 1;
-	config->fsg.luns[0].nofua = 1;
-#ifdef CONFIG_USB_MASS_STORAGE_SUPPORT_LUN2
-	config->fsg.luns[1].removable = 1;
-	config->fsg.luns[1].nofua = 1;
-#endif
 
 	common = fsg_common_init(NULL, cdev, &config->fsg);
 	if (IS_ERR(common)) {
@@ -940,15 +902,6 @@
 		kfree(config);
 		return err;
 	}
-#ifdef CONFIG_USB_MASS_STORAGE_SUPPORT_LUN2
-	err = sysfs_create_link(&f->dev->kobj,
-				&common->luns[1].dev.kobj,
-				"lun_ex");
-	if (err) {
-		kfree(config);
-		return err;
-	}
-#endif
 
 	config->common = common;
 	f->config = config;
@@ -992,70 +945,8 @@
 					mass_storage_inquiry_show,
 					mass_storage_inquiry_store);
 
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-static ssize_t mass_storage_vendor_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-	return sprintf(buf, "%s\n", config->common->vendor_string);
-}
-
-static ssize_t mass_storage_vendor_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-
-	if (size >= sizeof(config->common->vendor_string))
-		return -EINVAL;
-	if (sscanf(buf, "%s", config->common->vendor_string) != 1)
-		return -EINVAL;
-
-	printk(KERN_DEBUG "%s: vendor %s", __func__,
-				config->common->vendor_string);
-	return size;
-}
-
-static DEVICE_ATTR(vendor_string, S_IRUGO | S_IWUSR,
-					mass_storage_vendor_show,
-					mass_storage_vendor_store);
-
-static ssize_t mass_storage_product_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-	return sprintf(buf, "%s\n", config->common->product_string);
-}
-
-static ssize_t mass_storage_product_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-	struct android_usb_function *f = dev_get_drvdata(dev);
-	struct mass_storage_function_config *config = f->config;
-
-	if (size >= sizeof(config->common->product_string))
-		return -EINVAL;
-	if (sscanf(buf, "%s", config->common->product_string) != 1)
-		return -EINVAL;
-
-	printk(KERN_DEBUG "%s: product %s", __func__,
-				config->common->product_string);
-	return size;
-}
-
-static DEVICE_ATTR(product_string, S_IRUGO | S_IWUSR,
-					mass_storage_product_show,
-					mass_storage_product_store);
-#endif
-
 static struct device_attribute *mass_storage_function_attributes[] = {
 	&dev_attr_inquiry_string,
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	&dev_attr_vendor_string,
-	&dev_attr_product_string,
-#endif
 	NULL
 };
 
@@ -1107,18 +998,13 @@
 	&rmnet_smd_sdio_function,
 	&rmnet_function,
 	&diag_function,
+	&serial_function,
 	&adb_function,
 	&ccid_function,
-#ifdef CONFIG_USB_ACM
 	&acm_function,
-#else
-	&serial_function,
-#endif
 	&mtp_function,
 	&ptp_function,
-#ifdef CONFIG_USB_ANDROID_RNDIS
 	&rndis_function,
-#endif
 	&mass_storage_function,
 	&accessory_function,
 	NULL
@@ -1200,7 +1086,6 @@
 	int ret;
 
 	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
-		printk(KERN_DEBUG "usb: %s f:%s\n", __func__, f->name);
 		ret = f->bind_config(f, c);
 		if (ret) {
 			pr_err("%s: %s failed", __func__, f->name);
@@ -1226,11 +1111,9 @@
 {
 	struct android_usb_function **functions = dev->functions;
 	struct android_usb_function *f;
-	printk(KERN_DEBUG "usb: %s name=%s\n", __func__, name);
 	while ((f = *functions++)) {
 		if (!strcmp(name, f->name)) {
-			list_add_tail(&f->enabled_list,
-				&dev->enabled_functions);
+			list_add_tail(&f->enabled_list, &dev->enabled_functions);
 			return 0;
 		}
 	}
@@ -1273,11 +1156,8 @@
 	struct android_usb_function *f;
 	char *buff = buf;
 
-	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
-		printk(KERN_DEBUG "usb: %s enabled_func=%s\n",
-			__func__, f->name);
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list)
 		buff += snprintf(buff, PAGE_SIZE, "%s,", f->name);
-	}
 	if (buff != buf)
 		*(buff-1) = '\n';
 	return buff - buf;
@@ -1297,7 +1177,6 @@
 	strlcpy(buf, buff, sizeof(buf));
 	b = strim(buf);
 
-	printk(KERN_DEBUG "usb: [%s] functions = %s\n", __func__, b);
 	while (b) {
 		name = strsep(&b, ",");
 		if (name) {
@@ -1314,7 +1193,6 @@
 			   char *buf)
 {
 	struct android_dev *dev = dev_get_drvdata(pdev);
-	printk(KERN_DEBUG "usb: %s dev->enabled=%d\n", __func__,  dev->enabled);
 	return snprintf(buf, PAGE_SIZE, "%d\n", dev->enabled);
 }
 
@@ -1326,11 +1204,8 @@
 	int enabled = 0;
 
 	sscanf(buff, "%d", &enabled);
-	printk(KERN_DEBUG "usb: %s enabled=%d, !dev->enabled=%d\n",
-			__func__, enabled, !dev->enabled);
 	if (enabled && !dev->enabled) {
-		/* update values in composite driver's copy
-		of device descriptor */
+		/* update values in composite driver's copy of device descriptor */
 		cdev->desc.idVendor = device_desc.idVendor;
 		cdev->desc.idProduct = device_desc.idProduct;
 		cdev->desc.bcdDevice = device_desc.bcdDevice;
@@ -1345,13 +1220,8 @@
 		dev->enabled = true;
 	} else if (!enabled && dev->enabled) {
 		usb_gadget_disconnect(cdev->gadget);
-		/***** Cancel pending control requests ******/
-		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
 		usb_remove_config(cdev, &android_config_driver);
 		dev->enabled = false;
-	} else if (!enabled) {
-		usb_gadget_disconnect(cdev->gadget);
-		dev->enabled = false;
 	} else {
 		pr_err("android_usb: already %s\n",
 				dev->enabled ? "enabled" : "disabled");
@@ -1371,13 +1241,12 @@
 		goto out;
 
 	spin_lock_irqsave(&cdev->lock, flags);
-	if (cdev->config)
+        if (cdev->config)
 		state = "CONFIGURED";
 	else if (dev->connected)
 		state = "CONNECTED";
 	spin_unlock_irqrestore(&cdev->lock, flags);
 out:
-	printk(KERN_DEBUG "usb: %s buf=%s\n", __func__, state);
 	return snprintf(buf, PAGE_SIZE, "%s\n", state);
 }
 
@@ -1391,9 +1260,9 @@
 }									\
 static ssize_t								\
 field ## _store(struct device *dev, struct device_attribute *attr,	\
-		const char *buf, size_t size)		\
+		const char *buf, size_t size)		       		\
 {									\
-	int value;		\
+	int value;					       		\
 	if (sscanf(buf, format_string, &value) == 1) {			\
 		device_desc.field = value;				\
 		return size;						\
@@ -1411,10 +1280,9 @@
 }									\
 static ssize_t								\
 field ## _store(struct device *dev, struct device_attribute *attr,	\
-		const char *buf, size_t size)		\
+		const char *buf, size_t size)		       		\
 {									\
-	if (size >= sizeof(buffer))		\
-		return -EINVAL;			\
+	if (size >= sizeof(buffer)) return -EINVAL;			\
 	if (sscanf(buf, "%255s", buffer) == 1) {			\
 		return size;						\
 	}								\
@@ -1433,8 +1301,7 @@
 DESCRIPTOR_STRING_ATTR(iProduct, product_string)
 DESCRIPTOR_STRING_ATTR(iSerial, serial_string)
 
-static DEVICE_ATTR(functions, S_IRUGO | S_IWUSR,
-		functions_show, functions_store);
+static DEVICE_ATTR(functions, S_IRUGO | S_IWUSR, functions_show, functions_store);
 static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, enable_show, enable_store);
 static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
 static DEVICE_ATTR(remote_wakeup, S_IRUGO | S_IWUSR,
@@ -1485,7 +1352,6 @@
 	struct usb_gadget	*gadget = cdev->gadget;
 	int			gcnum, id, ret;
 
-	printk(KERN_DEBUG "usb: %s\n", __func__);
 	usb_gadget_disconnect(gadget);
 
 	ret = android_init_functions(dev->functions, cdev);
@@ -1511,14 +1377,7 @@
 	strlcpy(manufacturer_string, "Android",
 		sizeof(manufacturer_string) - 1);
 	strlcpy(product_string, "Android", sizeof(product_string) - 1);
-
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	sprintf(serial_string,
-			"%04x%04x", system_serial_high, system_serial_low);
-#else
 	strlcpy(serial_string, "0123456789ABCDEF", sizeof(serial_string) - 1);
-#endif
-	printk(KERN_INFO "%s : serial_string: %s\n", __func__, serial_string);
 
 	id = usb_string_id(cdev);
 	if (id < 0)
@@ -1526,7 +1385,6 @@
 	strings_dev[STRING_SERIAL_IDX].id = id;
 	device_desc.iSerialNumber = id;
 
-#if 0
 	gcnum = usb_gadget_controller_number(gadget);
 	if (gcnum >= 0)
 		device_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);
@@ -1542,9 +1400,6 @@
 			longname, gadget->name);
 		device_desc.bcdDevice = __constant_cpu_to_le16(0x9999);
 	}
-#endif
-	/* For kies auto start (bcdDevice is 0x0400) */
-	device_desc.bcdDevice = __constant_cpu_to_le16(0x0400);
 
 	usb_gadget_set_selfpowered(gadget);
 	dev->cdev = cdev;
@@ -1555,7 +1410,7 @@
 static int android_usb_unbind(struct usb_composite_dev *cdev)
 {
 	struct android_dev *dev = _android_dev;
-	printk(KERN_DEBUG "usb: %s\n", __func__);
+
 	cancel_work_sync(&dev->work);
 	android_cleanup_functions(dev->functions);
 	return 0;
@@ -1604,7 +1459,8 @@
 	if (!dev->connected) {
 		dev->connected = 1;
 		schedule_work(&dev->work);
-	} else if (c->bRequest == USB_REQ_SET_CONFIGURATION && cdev->config) {
+	}
+	else if (c->bRequest == USB_REQ_SET_CONFIGURATION && cdev->config) {
 		schedule_work(&dev->work);
 	}
 	spin_unlock_irqrestore(&cdev->lock, flags);
@@ -1678,7 +1534,6 @@
 	struct android_dev *dev;
 	int ret;
 
-	printk(KERN_DEBUG "%s\n", __func__);
 	android_class = class_create(THIS_MODULE, "android_usb");
 	if (IS_ERR(android_class))
 		return PTR_ERR(android_class);
diff -ru final2/drivers/usb/gadget/composite.c ics/drivers/usb/gadget/composite.c
--- final2/drivers/usb/gadget/composite.c	2014-08-29 08:16:34.656241000 +0200
+++ ics/drivers/usb/gadget/composite.c	2013-04-19 11:37:14.000000000 +0200
@@ -28,11 +28,6 @@
 
 #include <linux/usb/composite.h>
 
-#include "multi_config.h"
-/*
-#undef DBG
-#define DBG(dev, fmt, args...) printk(KERN_DEBUG "usb: "fmt, ##args)
-*/
 
 /*
  * The code in this file is utility code, used to build a gadget driver
@@ -252,11 +247,7 @@
 	c->bDescriptorType = type;
 	/* wTotalLength is written later */
 	c->bNumInterfaces = config->next_interface_id;
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	c->bConfigurationValue = get_config_number() + 1;
-#else
 	c->bConfigurationValue = config->bConfigurationValue;
-#endif
 	c->iConfiguration = config->iConfiguration;
 	c->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;
 	c->bMaxPower = config->bMaxPower ? : (CONFIG_USB_GADGET_VBUS_DRAW / 2);
@@ -275,14 +266,6 @@
 	list_for_each_entry(f, &config->functions, list) {
 		struct usb_descriptor_header **descriptors;
 
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-		if (!is_available_function(f->name)) {
-			USB_DBG("skip f->%s\n", f->name);
-			continue;
-		} else {
-			USB_DBG("f->%s\n", f->name);
-		}
-#endif
 		if (speed == USB_SPEED_HIGH)
 			descriptors = f->hs_descriptors;
 		else
@@ -293,18 +276,10 @@
 			(const struct usb_descriptor_header **) descriptors);
 		if (status < 0)
 			return status;
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-		if (change_conf(f, next, len, config, speed) < 0) {
-			USB_DBG_ESS("failed to change configuration\n");
-			return -EINVAL;
-		}
-#endif
 		len -= status;
 		next += status;
 	}
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	set_interface_count(config, c);
-#endif
+
 	len = next - buf;
 	c->wTotalLength = cpu_to_le16(len);
 	return len;
@@ -331,9 +306,6 @@
 
 	/* This is a lookup by config *INDEX* */
 	w_value &= 0xff;
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	w_value = set_config_number(w_value);
-#endif
 	list_for_each_entry(c, &cdev->configs, list) {
 		/* ignore configs that won't work at this speed */
 		if (speed == USB_SPEED_HIGH) {
@@ -373,9 +345,6 @@
 				continue;
 		}
 		count++;
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-		count = count_multi_config(c, count);
-#endif
 	}
 	return count;
 }
@@ -428,12 +397,7 @@
 
 	if (number) {
 		list_for_each_entry(c, &cdev->configs, list) {
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-			if (c->bConfigurationValue == number ||
-							check_config(number)) {
-#else
 			if (c->bConfigurationValue == number) {
-#endif
 				result = 0;
 				break;
 			}
@@ -446,14 +410,10 @@
 	INFO(cdev, "%s speed config #%d: %s\n",
 		({ char *speed;
 		switch (gadget->speed) {
-		case USB_SPEED_LOW:
-			speed = "low"; break;
-		case USB_SPEED_FULL:
-			speed = "full"; break;
-		case USB_SPEED_HIGH:
-			speed = "high"; break;
-		default:
-			speed = "?"; break;
+		case USB_SPEED_LOW:	speed = "low"; break;
+		case USB_SPEED_FULL:	speed = "full"; break;
+		case USB_SPEED_HIGH:	speed = "high"; break;
+		default:		speed = "?"; break;
 		} ; speed; }), number, c ? c->label : "unconfigured");
 
 	if (!c)
@@ -633,8 +593,6 @@
 {
 	unsigned long flags;
 
-	printk(KERN_DEBUG "usb: %s cdev->config=%p, config=%p\n",
-			__func__, cdev->config, config);
 	spin_lock_irqsave(&cdev->lock, flags);
 
 	if (cdev->config == config)
@@ -724,14 +682,6 @@
 				collect_langs(sp, s->wData);
 
 			list_for_each_entry(f, &c->functions, list) {
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-				if (!is_available_function(f->name)) {
-					USB_DBG("skip f->%s\n", f->name);
-					continue;
-				} else {
-					USB_DBG("f->%s\n", f->name);
-				}
-#endif
 				sp = f->strings;
 				if (sp)
 					collect_langs(sp, s->wData);
@@ -814,12 +764,8 @@
 		 * supported languages */
 		/* 255 reserved as well? -- mina86 */
 		cdev->next_string_id++;
-		printk(KERN_DEBUG "usb: %s cdev(0x%p)->next_string_id=%d\n",
-			__func__, cdev, cdev->next_string_id);
 		return cdev->next_string_id;
 	}
-	printk(KERN_DEBUG "usb: %s error cdev(0x%p)->next_string_id=%d\n",
-		__func__, cdev, cdev->next_string_id);
 	return -ENODEV;
 }
 
@@ -843,8 +789,6 @@
 {
 	int next = cdev->next_string_id;
 
-	printk(KERN_DEBUG "usb: %s --cdev(0x%p)->next_string_id=%d\n",
-		__func__, cdev, cdev->next_string_id);
 	for (; str->s; ++str) {
 		if (unlikely(next >= 254))
 			return -ENODEV;
@@ -878,8 +822,6 @@
 int usb_string_ids_n(struct usb_composite_dev *c, unsigned n)
 {
 	unsigned next = c->next_string_id;
-	printk(KERN_DEBUG "usb: %s --cdev(0x%p)->next_string_id=%d\n",
-		__func__, c, c->next_string_id);
 	if (unlikely(n > 254 || (unsigned)next + n > 254))
 		return -ENODEV;
 	c->next_string_id += n;
@@ -943,7 +885,6 @@
 				count_configs(cdev, USB_DT_DEVICE);
 			value = min(w_length, (u16) sizeof cdev->desc);
 			memcpy(req->buf, &cdev->desc, value);
-			printk(KERN_DEBUG "usb: GET_DES\n");
 			break;
 		case USB_DT_DEVICE_QUALIFIER:
 			if (!gadget_is_dualspeed(gadget))
@@ -962,9 +903,6 @@
 				value = min(w_length, (u16) value);
 			break;
 		case USB_DT_STRING:
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-			set_string_mode(w_length);
-#endif
 			value = get_string(cdev, req->buf,
 					w_index, w_value & 0xff);
 			if (value >= 0)
@@ -988,17 +926,12 @@
 		spin_lock(&cdev->lock);
 		value = set_config(cdev, ctrl, w_value);
 		spin_unlock(&cdev->lock);
-		printk(KERN_DEBUG "usb: SET_CON\n");
 		break;
 	case USB_REQ_GET_CONFIGURATION:
 		if (ctrl->bRequestType != USB_DIR_IN)
 			goto unknown;
 		if (cdev->config)
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-			*(u8 *)req->buf = get_config_number() + 1;
-#else
 			*(u8 *)req->buf = cdev->config->bConfigurationValue;
-#endif
 		else
 			*(u8 *)req->buf = 0;
 		value = min(w_length, (u16) 1);
@@ -1114,13 +1047,9 @@
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	unsigned long			flags;
 
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	set_string_mode(0);
-#endif
 	/* REVISIT:  should we have config and device level
 	 * disconnect callbacks?
 	 */
-	printk(KERN_DEBUG "usb: %s\n", __func__);
 	spin_lock_irqsave(&cdev->lock, flags);
 	if (cdev->config)
 		reset_config(cdev);
@@ -1247,10 +1176,6 @@
 	if (bcdDevice)
 		cdev->desc.bcdDevice = cpu_to_le16(bcdDevice);
 
-	printk(KERN_DEBUG "usb: %s idVendor=0x%x, idProduct=0x%x\n",
-			__func__, idVendor, idProduct);
-	printk(KERN_DEBUG "usb: %s bcdDevice=0x%x\n", __func__, bcdDevice);
-
 	/* string overrides */
 	if (iManufacturer || !cdev->desc.iManufacturer) {
 		if (!iManufacturer && !composite->iManufacturer &&
@@ -1266,9 +1191,6 @@
 			override_id(cdev, &cdev->desc.iManufacturer);
 	}
 
-	printk(KERN_DEBUG "usb: %s composite_manufacturer=%s\n",
-			__func__, composite_manufacturer);
-
 	if (iProduct || (!cdev->desc.iProduct && composite->iProduct))
 		cdev->product_override =
 			override_id(cdev, &cdev->desc.iProduct);
diff -ru final2/drivers/usb/gadget/f_acm.c ics/drivers/usb/gadget/f_acm.c
--- final2/drivers/usb/gadget/f_acm.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/gadget/f_acm.c	2013-04-19 11:37:14.000000000 +0200
@@ -8,13 +8,6 @@
  * Copyright (c) 2011 The Linux Foundation. All rights reserved.
  * Author: Michal Nazarewicz (m.nazarewicz@samsung.com)
  *
- * This file from the Code Aurora Forum is free software; you can
- * redistribute it and/or modify it under the GNU General Public
- * License version 2 and only version 2 as published by the Free Software
- * Foundation. The original work available from
- * [http://android.git.kernel.org/?p=kernel/common.git] is subject to
- * the notice below.
- *
  * This software is distributed under the terms of the GNU General
  * Public License ("GPL") as published by the Free Software Foundation,
  * either version 2 of that License or (at your option) any later version.
@@ -25,6 +18,7 @@
 #include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/device.h>
+#include <linux/usb/android_composite.h>
 #include <mach/usb_gadget_xport.h>
 
 #include "u_serial.h"
@@ -98,8 +92,6 @@
 static unsigned int no_acm_smd_ports;
 static unsigned int nr_acm_ports;
 
-#define GSERIAL_NO_PORTS 2
-
 static struct acm_port_info {
 	enum transport_type	transport;
 	unsigned		port_num;
@@ -116,32 +108,6 @@
 	return container_of(p, struct f_acm, port);
 }
 
-static enum transport_type acm_str_to_transport(const char *name)
-{
-	if (!strcasecmp("SDIO", name))
-		return USB_GADGET_XPORT_SDIO;
-	if (!strcasecmp("SMD", name))
-		return USB_GADGET_XPORT_SMD;
-
-	return USB_GADGET_XPORT_TTY;
-}
-
-static char *transport_to_str(enum transport_type t)
-{
-	switch (t) {
-	case USB_GADGET_XPORT_TTY:
-		return "TTY";
-	case USB_GADGET_XPORT_SDIO:
-		return "SDIO";
-	case USB_GADGET_XPORT_SMD:
-		return "SMD";
-	default:
-		break;
-	}
-
-	return "NONE";
-}
-
 static int acm_port_setup(struct usb_configuration *c)
 {
 	int ret = 0;
@@ -168,7 +134,7 @@
 
 
 	pr_debug("%s: transport:%s f_acm:%p gserial:%p port_num:%d cl_port_no:%d\n",
-			__func__, transport_to_str(acm->transport),
+			__func__, xport_to_str(acm->transport),
 			acm, &acm->port, acm->port_num, port_num);
 
 	switch (acm->transport) {
@@ -183,7 +149,7 @@
 		break;
 	default:
 		pr_err("%s: Un-supported transport: %s\n", __func__,
-				transport_to_str(acm->transport));
+				xport_to_str(acm->transport));
 		return -ENODEV;
 	}
 
@@ -197,7 +163,7 @@
 	port_num = gacm_ports[acm->port_num].client_port_num;
 
 	pr_debug("%s: transport:%s f_acm:%p gserial:%p port_num:%d cl_pno:%d\n",
-			__func__, transport_to_str(acm->transport),
+			__func__, xport_to_str(acm->transport),
 			acm, &acm->port, acm->port_num, port_num);
 
 	switch (acm->transport) {
@@ -212,7 +178,7 @@
 		break;
 	default:
 		pr_err("%s: Un-supported transport:%s\n", __func__,
-				transport_to_str(acm->transport));
+				xport_to_str(acm->transport));
 		return -ENODEV;
 	}
 
@@ -233,7 +199,7 @@
 	.bDescriptorType =	USB_DT_INTERFACE_ASSOCIATION,
 
 	/* .bFirstInterface =	DYNAMIC, */
-	.bInterfaceCount =	2, /* control + data */
+	.bInterfaceCount = 	2,	// control + data
 	.bFunctionClass =	USB_CLASS_COMM,
 	.bFunctionSubClass =	USB_CDC_SUBCLASS_ACM,
 	.bFunctionProtocol =	USB_CDC_ACM_PROTO_AT_V25TER,
@@ -382,7 +348,7 @@
 static struct usb_string acm_string_defs[] = {
 	[ACM_CTRL_IDX].s = "CDC Abstract Control Model (ACM)",
 	[ACM_DATA_IDX].s = "CDC ACM Data",
-	[ACM_IAD_IDX].s = "CDC Serial",
+	[ACM_IAD_IDX ].s = "CDC Serial",
 	{  /* ZEROES END LIST */ },
 };
 
@@ -485,9 +451,6 @@
 		 * that bit, we should return to that no-flow state.
 		 */
 		acm->port_handshake_bits = w_value;
-#ifdef CONFIG_USB_DUN_SUPPORT
-		notify_control_line_state((unsigned long)w_value);
-#endif
 		if (acm->port.notify_modem) {
 			unsigned port_num =
 				gacm_ports[acm->port_num].client_port_num;
@@ -524,7 +487,6 @@
 {
 	struct f_acm		*acm = func_to_acm(f);
 	struct usb_composite_dev *cdev = f->config->cdev;
-	int ret = 0;
 
 	/* we know alt == 0, so this is an activation or a reset */
 
@@ -538,12 +500,7 @@
 		acm->notify_desc = ep_choose(cdev->gadget,
 				acm->hs.notify,
 				acm->fs.notify);
-		ret = usb_ep_enable(acm->notify, acm->notify_desc);
-		if (ret) {
-			ERROR(cdev, "can't enable %s, result %d\n",
-						acm->notify->name, ret);
-			return ret;
-		}
+		usb_ep_enable(acm->notify, acm->notify_desc);
 		acm->notify->driver_data = acm;
 
 	} else if (intf == acm->data_id) {
@@ -593,7 +550,7 @@
  * about the only notification we issue:  SerialState change.
  */
 static int acm_cdc_notify(struct f_acm *acm, u8 type, u16 value,
-		void *data, unsigned length, unsigned long * flags)
+		void *data, unsigned length)
 {
 	struct usb_ep			*ep = acm->notify;
 	struct usb_request		*req;
@@ -619,9 +576,9 @@
 	memcpy(buf, data, length);
 
 	/* ep_queue() can complete immediately if it fills the fifo... */
-	spin_unlock_irqrestore(&acm->lock, *flags);
+	spin_unlock(&acm->lock);
 	status = usb_ep_queue(ep, req, GFP_ATOMIC);
-	spin_lock_irqsave(&acm->lock, *flags);
+	spin_lock(&acm->lock);
 
 	if (status < 0) {
 		ERROR(acm->port.func.config->cdev,
@@ -637,20 +594,18 @@
 {
 	struct usb_composite_dev *cdev = acm->port.func.config->cdev;
 	int			status;
-	unsigned long flags;
 
-	spin_lock_irqsave(&acm->lock, flags);
+	spin_lock(&acm->lock);
 	if (acm->notify_req) {
 		DBG(cdev, "acm ttyGS%d serial state %04x\n",
 				acm->port_num, acm->serial_state);
 		status = acm_cdc_notify(acm, USB_CDC_NOTIFY_SERIAL_STATE,
-				0, &acm->serial_state,
-				sizeof(acm->serial_state), &flags);
+				0, &acm->serial_state, sizeof(acm->serial_state));
 	} else {
 		acm->pending = true;
 		status = 0;
 	}
-	spin_unlock_irqrestore(&acm->lock, flags);
+	spin_unlock(&acm->lock);
 	return status;
 }
 
@@ -658,30 +613,20 @@
 {
 	struct f_acm		*acm = req->context;
 	u8			doit = false;
-	unsigned long flags;
 
 	/* on this call path we do NOT hold the port spinlock,
 	 * which is why ACM needs its own spinlock
 	 */
-	spin_lock_irqsave(&acm->lock, flags);
+	spin_lock(&acm->lock);
 	if (req->status != -ESHUTDOWN)
 		doit = acm->pending;
 	acm->notify_req = req;
-	spin_unlock_irqrestore(&acm->lock, flags);
+	spin_unlock(&acm->lock);
 
 	if (doit)
 		acm_notify_serial_state(acm);
 }
 
-#ifdef CONFIG_USB_DUN_SUPPORT
-void acm_notify(void *dev, u16 state)
-{
-	struct f_acm	*acm = (struct f_acm *)dev;
-
-	acm->serial_state = state;
-	acm_notify_serial_state(acm);
-}
-#endif
 /* connect == the TTY link is open */
 
 static void acm_connect(struct gserial *port)
@@ -826,9 +771,6 @@
 			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
 			acm->port.in->name, acm->port.out->name,
 			acm->notify->name);
-#ifdef CONFIG_USB_DUN_SUPPORT
-	modem_register(acm);
-#endif
 	return 0;
 
 fail:
@@ -862,9 +804,6 @@
 		usb_free_descriptors(f->hs_descriptors);
 	usb_free_descriptors(f->descriptors);
 	gs_free_req(acm->notify, acm->notify_req);
-#ifdef CONFIG_USB_DUN_SUPPORT
-	modem_unregister();
-#endif
 	kfree(acm->port.func.name);
 	kfree(acm);
 }
@@ -959,8 +898,8 @@
 }
 
 /**
-* acm_init_port - bind a acm_port to its transport
-*/
+ * acm_init_port - bind a acm_port to its transport
+ */
 static int acm_init_port(int port_num, const char *name)
 {
 	enum transport_type transport;
@@ -968,14 +907,14 @@
 	if (port_num >= GSERIAL_NO_PORTS)
 		return -ENODEV;
 
-	transport = acm_str_to_transport(name);
+	transport = str_to_xport(name);
 	pr_debug("%s, port:%d, transport:%s\n", __func__,
-		port_num, transport_to_str(transport));
+			port_num, xport_to_str(transport));
 
 	gacm_ports[port_num].transport = transport;
 	gacm_ports[port_num].port_num = port_num;
 
-	switch (gacm_ports[port_num].transport) {
+	switch (transport) {
 	case USB_GADGET_XPORT_TTY:
 		gacm_ports[port_num].client_port_num = no_acm_tty_ports;
 		no_acm_tty_ports++;
@@ -990,15 +929,11 @@
 		break;
 	default:
 		pr_err("%s: Un-supported transport transport: %u\n",
-			__func__, gacm_ports[port_num].transport);
+				__func__, gacm_ports[port_num].transport);
 		return -ENODEV;
 	}
-	nr_acm_ports++;
 
-	pr_info("%s:gport:tty_ports:%u sdio_ports:%u "
-			"smd_ports:%u nr_ports:%u\n",
-			__func__, no_acm_tty_ports, no_acm_sdio_ports,
-			no_acm_smd_ports, nr_acm_ports);
+	nr_acm_ports++;
 
 	return 0;
 }
diff -ru final2/drivers/usb/gadget/f_diag.c ics/drivers/usb/gadget/f_diag.c
--- final2/drivers/usb/gadget/f_diag.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/gadget/f_diag.c	2013-04-19 11:37:14.000000000 +0200
@@ -35,13 +35,8 @@
 	.bDescriptorType    =	USB_DT_INTERFACE,
 	.bNumEndpoints      =	2,
 	.bInterfaceClass    =	0xFF,
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	.bInterfaceSubClass =	0x10,
-	.bInterfaceProtocol =	0x01,
-#else
 	.bInterfaceSubClass =	0xFF,
 	.bInterfaceProtocol =	0xFF,
-#endif
 };
 
 static struct usb_endpoint_descriptor hs_bulk_in_desc = {
diff -ru final2/drivers/usb/gadget/f_mass_storage.c ics/drivers/usb/gadget/f_mass_storage.c
--- final2/drivers/usb/gadget/f_mass_storage.c	2014-08-29 08:16:34.656241000 +0200
+++ ics/drivers/usb/gadget/f_mass_storage.c	2013-04-19 11:37:14.000000000 +0200
@@ -409,10 +409,6 @@
 	 */
 	char inquiry_string[8 + 16 + 4 + 1];
 
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	char vendor_string[8 + 1];
-	char product_string[16 + 1];
-#endif
 	struct kref		ref;
 };
 
@@ -1115,8 +1111,7 @@
 							BUF_STATE_BUSY)
 						break;
 				}
-				if (!amount_left_to_req &&
-						i == FSG_NUM_BUFFERS) {
+				if (!amount_left_to_req && i == FSG_NUM_BUFFERS) {
 					csw_hack_sent = 1;
 					send_status(common);
 				}
@@ -1274,9 +1269,6 @@
 {
 	struct fsg_lun *curlun = common->curlun;
 	u8	*buf = (u8 *) bh->buf;
-#if defined(CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE)
-	static char new_product_name[16 + 1];
-#endif
 
 	if (!curlun) {		/* Unsupported LUNs are okay */
 		common->bad_lun_okay = 1;
@@ -1294,24 +1286,6 @@
 	buf[5] = 0;		/* No special options */
 	buf[6] = 0;
 	buf[7] = 0;
-
-#if defined(CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE)
-	strncpy(new_product_name, common->product_string, 16);
-	new_product_name[16] = '\0';
-	/* Prevent CID: 61745 */
-	if (strlen(common->product_string) <= 11 && /*check string length*/
-		common->lun > 0) {
-		strncat(new_product_name, " Card", 16);
-		new_product_name[16] = '\0';
-	}
-
-	snprintf(common->inquiry_string,
-		sizeof common->inquiry_string,
-		"%-8s%-16s%04x",
-		common->vendor_string,
-		new_product_name, 1);
-#endif
-
 	memcpy(buf + 8, common->inquiry_string, sizeof common->inquiry_string);
 	return 36;
 }
@@ -2990,18 +2964,6 @@
 				     : "File-CD Gadget"),
 		 i);
 
-#ifdef	CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	/* Default INQUIRY strings */
-	strncpy(common->vendor_string, "SAMSUNG",
-			sizeof(common->vendor_string) - 1);
-	/* Prevent CID:61521*/
-	common->vendor_string[sizeof(common->vendor_string) - 1] = 0;
-	strncpy(common->product_string, "File-Stor Gadget",
-			sizeof(common->product_string) - 1);
-	/* Prevent CID:61521*/
-	common->product_string[sizeof(common->product_string) - 1] = 0;
-#endif
-
 	/*
 	 * Some peripheral controllers are known not to be able to
 	 * halt bulk endpoints correctly.  If one of them is present,
Nur in final2/drivers/usb/gadget: f_mtp.h.
Nur in final2/drivers/usb/gadget: f_mtp_samsung.c.
diff -ru final2/drivers/usb/gadget/f_rmnet.c ics/drivers/usb/gadget/f_rmnet.c
--- final2/drivers/usb/gadget/f_rmnet.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/gadget/f_rmnet.c	2013-04-19 11:37:14.000000000 +0200
@@ -82,13 +82,8 @@
 	.bDescriptorType =	USB_DT_INTERFACE,
 	.bNumEndpoints =	3,
 	.bInterfaceClass =	USB_CLASS_VENDOR_SPEC,
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	.bInterfaceSubClass = 0xE0,
-	.bInterfaceProtocol = 0x00,
-#else
 	.bInterfaceSubClass =	USB_CLASS_VENDOR_SPEC,
 	.bInterfaceProtocol =	USB_CLASS_VENDOR_SPEC,
-#endif
 	/* .iInterface = DYNAMIC */
 };
 
diff -ru final2/drivers/usb/gadget/f_rmnet_sdio.c ics/drivers/usb/gadget/f_rmnet_sdio.c
--- final2/drivers/usb/gadget/f_rmnet_sdio.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/gadget/f_rmnet_sdio.c	2013-04-19 11:37:14.000000000 +0200
@@ -144,13 +144,8 @@
 	/* .bInterfaceNumber = DYNAMIC */
 	.bNumEndpoints =        3,
 	.bInterfaceClass =      USB_CLASS_VENDOR_SPEC,
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	.bInterfaceSubClass = 0xE0,
-	.bInterfaceProtocol = 0x00,
-#else
 	.bInterfaceSubClass =   USB_CLASS_VENDOR_SPEC,
 	.bInterfaceProtocol =   USB_CLASS_VENDOR_SPEC,
-#endif
 	/* .iInterface = DYNAMIC */
 };
 
@@ -1261,36 +1256,16 @@
 	int ret = 0;
 
 	dev->epin->driver_data = dev;
-	ret = usb_ep_enable(dev->epin, ep_choose(cdev->gadget,
+	usb_ep_enable(dev->epin, ep_choose(cdev->gadget,
 				&rmnet_sdio_hs_in_desc,
 				&rmnet_sdio_fs_in_desc));
-	if (ret) {
-		ERROR(cdev, "can't enable %s, result %d\n",
-					dev->epin->name, ret);
-		return ret;
-	}
-
 	dev->epout->driver_data = dev;
-	ret = usb_ep_enable(dev->epout, ep_choose(cdev->gadget,
+	usb_ep_enable(dev->epout, ep_choose(cdev->gadget,
 				&rmnet_sdio_hs_out_desc,
 				&rmnet_sdio_fs_out_desc));
-	if (ret) {
-		ERROR(cdev, "can't enable %s, result %d\n",
-					dev->epout->name, ret);
-		usb_ep_disable(dev->epin);
-		return ret;
-	}
-
-	ret = usb_ep_enable(dev->epnotify, ep_choose(cdev->gadget,
+	usb_ep_enable(dev->epnotify, ep_choose(cdev->gadget,
 				&rmnet_sdio_hs_notify_desc,
 				&rmnet_sdio_fs_notify_desc));
-	if (ret) {
-		ERROR(cdev, "can't enable %s, result %d\n",
-					dev->epnotify->name, ret);
-		usb_ep_disable(dev->epin);
-		usb_ep_disable(dev->epout);
-		return ret;
-	}
 
 	/* allocate notification */
 	dev->notify_req = rmnet_sdio_alloc_req(dev->epnotify,
diff -ru final2/drivers/usb/gadget/f_rmnet_smd_sdio.c ics/drivers/usb/gadget/f_rmnet_smd_sdio.c
--- final2/drivers/usb/gadget/f_rmnet_smd_sdio.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/gadget/f_rmnet_smd_sdio.c	2013-04-19 11:37:14.000000000 +0200
@@ -1354,7 +1354,6 @@
 								function);
 	struct rmnet_mux_sdio_dev *sdio_dev = &dev->sdio_dev;
 	struct usb_composite_dev *cdev = dev->cdev;
-	int ret = 0;
 
 	/* allocate notification */
 	dev->notify_req = rmnet_mux_alloc_req(dev->epnotify,
@@ -1366,37 +1365,18 @@
 	dev->notify_req->complete = rmnet_mux_notify_complete;
 	dev->notify_req->context = dev;
 	dev->notify_req->length = RMNET_MUX_SDIO_MAX_NFY_SZE;
-	ret = usb_ep_enable(dev->epnotify, ep_choose(cdev->gadget,
+	usb_ep_enable(dev->epnotify, ep_choose(cdev->gadget,
 				&rmnet_mux_hs_notify_desc,
 				&rmnet_mux_fs_notify_desc));
-	if (ret) {
-		ERROR(cdev, "can't enable %s, result %d\n",
-					dev->epnotify->name, ret);
-		return ret;
-	}
 
 	dev->epin->driver_data = dev;
-	ret = usb_ep_enable(dev->epin, ep_choose(cdev->gadget,
+	usb_ep_enable(dev->epin, ep_choose(cdev->gadget,
 				&rmnet_mux_hs_in_desc,
 				&rmnet_mux_fs_in_desc));
-	if (ret) {
-		ERROR(cdev, "can't enable %s, result %d\n",
-					dev->epin->name, ret);
-		usb_ep_disable(dev->epnotify);
-		return ret;
-	}
-
 	dev->epout->driver_data = dev;
-	ret = usb_ep_enable(dev->epout, ep_choose(cdev->gadget,
+	usb_ep_enable(dev->epout, ep_choose(cdev->gadget,
 				&rmnet_mux_hs_out_desc,
 				&rmnet_mux_fs_out_desc));
-	if (ret) {
-		ERROR(cdev, "can't enable %s, result %d\n",
-					dev->epout->name, ret);
-		usb_ep_disable(dev->epnotify);
-		usb_ep_disable(dev->epin);
-		return ret;
-	}
 
 	dev->dpkts_tolaptop = 0;
 	dev->cpkts_tolaptop = 0;
diff -ru final2/drivers/usb/gadget/Kconfig ics/drivers/usb/gadget/Kconfig
--- final2/drivers/usb/gadget/Kconfig	2014-08-29 08:16:34.652241000 +0200
+++ ics/drivers/usb/gadget/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -961,41 +961,6 @@
 	  The functions can be configured via a board file and may be
 	  enabled and disabled dynamically.
 
-config USB_ANDROID_SAMSUNG_COMPOSITE
-	boolean "Samsung Composite function"
-	depends on USB_G_ANDROID
-	help
-		Provides SAMSUNG composite driver.
-		It also provides KIES connection and
-		Multi Configuration.
-		If you enable this option, android composite will be changed.
-
-config USB_ANDROID_SAMSUNG_MTP
-	boolean "Samsung MTP function"
-	depends on USB_G_ANDROID
-	help
-		Provides Media Transfer Protocol (MTP) support
-		for samsung gadget driver.
-		If you enable this option,
-		google mtp will be changed to samsung mtp.
-
-config USB_ANDROID_RNDIS
-	boolean "Samsung USB RNDIS function"
-	depends on USB_G_ANDROID
-
-config USB_MASS_STORAGE_SUPPORT_LUN2
-	boolean "Mass storage Feature for LUN2 "
-	depends on USB_G_ANDROID
-
-config USB_DUN_SUPPORT
-	boolean "DUN support function"
-	depends on USB_G_ANDROID
-	help
-	  Provides USB modem serial driver.
-	  This function makes connection to acm from data router.
-	  It uses misc register.
-	  Support fops : open, close, release, read, poll, llseek, ioctl
-
 config USB_CDC_COMPOSITE
 	tristate "CDC Composite Device (Ethernet and ACM)"
 	depends on NET
Nur in final2/drivers/usb/gadget: lh7a40x_udc.c.
Nur in final2/drivers/usb/gadget: lh7a40x_udc.h.
diff -ru final2/drivers/usb/gadget/Makefile ics/drivers/usb/gadget/Makefile
--- final2/drivers/usb/gadget/Makefile	2014-08-29 08:16:34.652241000 +0200
+++ ics/drivers/usb/gadget/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -70,4 +70,3 @@
 obj-$(CONFIG_USB_G_WEBCAM)	+= g_webcam.o
 obj-$(CONFIG_USB_G_NCM)		+= g_ncm.o
 obj-$(CONFIG_USB_G_ANDROID)	+= g_android.o
-obj-$(CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE)	+= multi_config.o
diff -ru final2/drivers/usb/gadget/msm72k_udc.c ics/drivers/usb/gadget/msm72k_udc.c
--- final2/drivers/usb/gadget/msm72k_udc.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/gadget/msm72k_udc.c	2013-04-19 11:37:14.000000000 +0200
@@ -291,18 +291,10 @@
 
 static inline enum chg_type usb_get_chg_type(struct usb_info *ui)
 {
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	if (ui->pdata->get_usb_chg_type &&
-		ui->pdata->get_usb_chg_type() == USB_CHG_TYPE__WALLCHARGER)
-		return USB_CHG_TYPE__WALLCHARGER;
-	else
-		return USB_CHG_TYPE__SDP;
-#else
 	if ((readl(USB_PORTSC) & PORTSC_LS) == PORTSC_LS)
 		return USB_CHG_TYPE__WALLCHARGER;
 	else
 		return USB_CHG_TYPE__SDP;
-#endif
 }
 
 #define USB_WALLCHARGER_CHG_CURRENT 1800
@@ -2006,11 +1998,11 @@
 		return;
 
 	debugfs_create_file("status", 0444, dent, ui, &debug_stat_ops);
-	debugfs_create_file("reset", 0444, dent, ui, &debug_reset_ops);
-	debugfs_create_file("cycle", 0444, dent, ui, &debug_cycle_ops);
-	debugfs_create_file("release_wlocks", 0664, dent, ui,
+	debugfs_create_file("reset", 0222, dent, ui, &debug_reset_ops);
+	debugfs_create_file("cycle", 0222, dent, ui, &debug_cycle_ops);
+	debugfs_create_file("release_wlocks", 0666, dent, ui,
 						&debug_wlocks_ops);
-	debugfs_create_file("prime_fail_countt", 0664, dent, ui,
+	debugfs_create_file("prime_fail_countt", 0666, dent, ui,
 						&prime_fail_ops);
 }
 #else
Nur in final2/drivers/usb/gadget: multi_config.c.
Nur in final2/drivers/usb/gadget: multi_config.h.
Nur in final2/drivers/usb/gadget: serial_acm.c.
diff -ru final2/drivers/usb/gadget/storage_common.c ics/drivers/usb/gadget/storage_common.c
--- final2/drivers/usb/gadget/storage_common.c	2014-08-29 08:16:34.732241000 +0200
+++ ics/drivers/usb/gadget/storage_common.c	2013-04-19 11:37:14.000000000 +0200
@@ -816,15 +816,8 @@
 	struct rw_semaphore	*filesem = dev_get_drvdata(dev);
 	int		rc = 0;
 
-/*
-Always allow disabling mass storage by writing to lun file
-For android builds we disable the check for curlun->prevent_medium_removal.
-Instead we let the framework manage unmounting policy, as we sometimes need
-to unmount after the media has been removed.
-This also helps support hosts that do not inform the device when the media
-has been unmounted.
-*/
-#if !defined(CONFIG_USB_ANDROID_MASS_STORAGE) && !defined(CONFIG_USB_G_ANDROID)
+
+#ifndef CONFIG_USB_ANDROID_MASS_STORAGE
 	/* disabled in android because we need to allow closing the backing file
 	 * if the media was removed
 	 */
diff -ru final2/drivers/usb/gadget/u_ether.h ics/drivers/usb/gadget/u_ether.h
--- final2/drivers/usb/gadget/u_ether.h	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/gadget/u_ether.h	2013-04-19 11:37:14.000000000 +0200
@@ -116,7 +116,7 @@
 int ncm_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN]);
 int eem_bind_config(struct usb_configuration *c);
 
-#if defined(USB_ETH_RNDIS) || defined(CONFIG_USB_ANDROID_RNDIS)
+#ifdef USB_ETH_RNDIS
 
 int rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
 				u32 vendorID, const char *manufacturer);
diff -ru final2/drivers/usb/gadget/u_rmnet_ctrl_smd.c ics/drivers/usb/gadget/u_rmnet_ctrl_smd.c
--- final2/drivers/usb/gadget/u_rmnet_ctrl_smd.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/gadget/u_rmnet_ctrl_smd.c	2013-04-19 11:37:14.000000000 +0200
@@ -33,38 +33,38 @@
 #define CH_OPENED	0
 #define CH_READY	1
 struct smd_ch_info {
-struct smd_channel	*ch;
-char			*name;
-unsigned long		flags;
-wait_queue_head_t	wait;
-unsigned		dtr;
-
-struct list_head	tx_q;
-unsigned long		tx_len;
-
-struct work_struct	read_w;
-struct work_struct	write_w;
-
-struct rmnet_ctrl_port	*port;
-
-int			cbits_tomodem;
-/* stats */
-unsigned long		to_modem;
-unsigned long		to_host;
+	struct smd_channel	*ch;
+	char			*name;
+	unsigned long		flags;
+	wait_queue_head_t	wait;
+	unsigned		dtr;
+
+	struct list_head	tx_q;
+	unsigned long		tx_len;
+
+	struct work_struct	read_w;
+	struct work_struct	write_w;
+
+	struct rmnet_ctrl_port	*port;
+
+	int			cbits_tomodem;
+	/* stats */
+	unsigned long		to_modem;
+	unsigned long		to_host;
 };
 
 struct rmnet_ctrl_port {
-struct smd_ch_info	ctrl_ch;
-unsigned int		port_num;
-struct grmnet		*port_usb;
+	struct smd_ch_info	ctrl_ch;
+	unsigned int		port_num;
+	struct grmnet		*port_usb;
 
-spinlock_t		port_lock;
-struct delayed_work	connect_w;
+	spinlock_t		port_lock;
+	struct delayed_work	connect_w;
 };
 
 static struct rmnet_ctrl_ports {
-struct rmnet_ctrl_port *port;
-struct platform_driver pdrv;
+	struct rmnet_ctrl_port *port;
+	struct platform_driver pdrv;
 } ctrl_smd_ports[NR_CTRL_SMD_PORTS];
 
 
@@ -72,27 +72,27 @@
 
 static struct rmnet_ctrl_pkt *alloc_rmnet_ctrl_pkt(unsigned len, gfp_t flags)
 {
-struct rmnet_ctrl_pkt *pkt;
+	struct rmnet_ctrl_pkt *pkt;
 
-pkt = kzalloc(sizeof(struct rmnet_ctrl_pkt), flags);
-if (!pkt)
-return ERR_PTR(-ENOMEM);
-
-pkt->buf = kmalloc(len, flags);
-if (!pkt->buf) {
-kfree(pkt);
-return ERR_PTR(-ENOMEM);
-}
+	pkt = kzalloc(sizeof(struct rmnet_ctrl_pkt), flags);
+	if (!pkt)
+		return ERR_PTR(-ENOMEM);
+
+	pkt->buf = kmalloc(len, flags);
+	if (!pkt->buf) {
+		kfree(pkt);
+		return ERR_PTR(-ENOMEM);
+	}
 
-pkt->len = len;
+	pkt->len = len;
 
-return pkt;
+	return pkt;
 }
 
 static void free_rmnet_ctrl_pkt(struct rmnet_ctrl_pkt *pkt)
 {
-kfree(pkt->buf);
-kfree(pkt);
+	kfree(pkt->buf);
+	kfree(pkt);
 }
 
 /*--------------------------------------------- */
@@ -101,17 +101,15 @@
 
 static void grmnet_ctrl_smd_read_w(struct work_struct *w)
 {
-struct smd_ch_info *c = container_of(w, struct smd_ch_info, read_w);
-struct rmnet_ctrl_port *port = c->port;
-int sz;
-size_t len;
-void *buf;
-unsigned long flags;
+	struct smd_ch_info *c = container_of(w, struct smd_ch_info, read_w);
+	struct rmnet_ctrl_port *port = c->port;
+	int sz;
+	size_t len;
+	void *buf;
+	unsigned long flags;
 
 	spin_lock_irqsave(&port->port_lock, flags);
 	while (c->ch) {
-                if (c->ch == NULL)
-                        break;
 		sz = smd_cur_packet_size(c->ch);
 		if (sz <= 0)
 			break;
diff -ru final2/drivers/usb/gadget/u_serial.c ics/drivers/usb/gadget/u_serial.c
--- final2/drivers/usb/gadget/u_serial.c	2014-08-29 08:16:34.732241000 +0200
+++ ics/drivers/usb/gadget/u_serial.c	2013-04-19 11:37:14.000000000 +0200
@@ -1313,7 +1313,7 @@
 		return;
 
 	debugfs_create_file("readstatus", 0444, dent, ui_dev, &debug_adb_ops);
-	debugfs_create_file("reset", 0444, dent, ui_dev, &debug_rst_ops);
+	debugfs_create_file("reset", 0222, dent, ui_dev, &debug_rst_ops);
 }
 #else
 static void usb_debugfs_init(struct gs_port *ui_dev) {}
diff -ru final2/drivers/usb/gadget/u_serial.h ics/drivers/usb/gadget/u_serial.h
--- final2/drivers/usb/gadget/u_serial.h	2014-08-29 08:16:34.732241000 +0200
+++ ics/drivers/usb/gadget/u_serial.h	2013-04-19 11:37:14.000000000 +0200
@@ -84,10 +84,4 @@
 int gser_bind_config(struct usb_configuration *c, u8 port_num);
 int obex_bind_config(struct usb_configuration *c, u8 port_num);
 
-#ifdef CONFIG_USB_DUN_SUPPORT
-extern int modem_register(void *data);
-extern void modem_unregister(void);
-extern void notify_control_line_state(u32 value);
-#endif
-
 #endif /* __U_SERIAL_H */
diff -ru final2/drivers/usb/Kconfig ics/drivers/usb/Kconfig
--- final2/drivers/usb/Kconfig	2014-08-29 08:16:34.620241000 +0200
+++ ics/drivers/usb/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -129,12 +129,6 @@
 comment "USB port drivers"
 	depends on USB
 
-config USB_ANDROID
-	boolean "Support for Important Usb functions"
-	default n
-	help
-	  USB Important functions are decided depends on this flag value  .
-
 config USB_USS720
 	tristate "USS720 parport driver"
 	depends on USB && PARPORT
diff -ru final2/drivers/usb/otg/Kconfig ics/drivers/usb/otg/Kconfig
--- final2/drivers/usb/otg/Kconfig	2014-08-29 08:16:34.836241000 +0200
+++ ics/drivers/usb/otg/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -176,12 +176,6 @@
           Enable this to support the USB OTG transceiver in AB8500 chip.
           This transceiver supports high and full speed devices plus,
           in host mode, low speed.
-	  
-config USB_RECEIVER_SENSITIVITY
-	boolean "Support USB receiver sensitivity"
-	depends on USB_ANDROID
-	help
-	  Adjust USB receiver sensitivity squelch.
 
 config FSL_USB2_OTG
 	bool "Freescale USB OTG Transceiver Driver"
diff -ru final2/drivers/usb/otg/msm72k_otg.c ics/drivers/usb/otg/msm72k_otg.c
--- final2/drivers/usb/otg/msm72k_otg.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/usb/otg/msm72k_otg.c	2013-04-19 11:37:14.000000000 +0200
@@ -318,32 +318,6 @@
 	ulpi_write(dev, res, ULPI_CONFIG_REG2);
 }
 
-#ifdef CONFIG_USB_RECEIVER_SENSITIVITY
-/* for receiver sensitivity */
-#define ULPI_SQUELCH_LEVEL_MASK	(3 << 6)
-#define ULPI_CONFIG_REG4	0X33
-
-enum squelch_level {
-	SQUELCH_LEVEL_1,
-	SQUELCH_LEVEL_2 = (1 << 6),
-	SQUELCH_LEVEL_3 = (2 << 6),
-	SQUELCH_LEVEL_4 = (3 << 6),
-};
-
-static inline void set_squelch_level(struct msm_otg *dev)
-{
-	unsigned res = 0;
-
-	if (!dev->pdata)
-		return;
-
-	res = ulpi_read(dev, ULPI_CONFIG_REG4);
-	res &= ~ULPI_SQUELCH_LEVEL_MASK;
-	res |= SQUELCH_LEVEL_1;
-	ulpi_write(dev, res, ULPI_CONFIG_REG4);
-}
-#endif
-
 static const char *state_string(enum usb_otg_state state)
 {
 	switch (state) {
@@ -1610,9 +1584,7 @@
 	set_cdr_auto_reset(dev);
 	set_driver_amplitude(dev);
 	set_se1_gating(dev);
-	#if defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE_I)
-	set_squelch_level(dev);
-	#endif
+
 	writel(0x0, USB_AHB_BURST);
 	writel(0x00, USB_AHB_MODE);
 	if (dev->pdata->bam_disable) {
@@ -1764,13 +1736,7 @@
 			dev->otg.state = OTG_STATE_B_PERIPHERAL;
 			spin_unlock_irqrestore(&dev->lock, flags);
 			msm_otg_set_power(&dev->otg, 0);
-			if (dev->pdata->chg_mode_check &&
-					dev->pdata->chg_mode_check()) {
-				pr_info("[USB] entering into lpm.\n");
-				msm_otg_put_suspend(dev);
-			} else {
-				msm_otg_start_peripheral(&dev->otg, 1);
-			}
+			msm_otg_start_peripheral(&dev->otg, 1);
 		} else if (test_bit(B_BUS_REQ, &dev->inputs)) {
 			pr_debug("b_sess_end && b_bus_req\n");
 			ret = msm_otg_start_srp(&dev->otg);
@@ -2577,7 +2543,7 @@
 	if (!otg_debug_root)
 		return -ENOENT;
 
-	otg_debug_mode = debugfs_create_file("mode", 0444,
+	otg_debug_mode = debugfs_create_file("mode", 0222,
 						otg_debug_root, dev,
 						&otgfs_fops);
 	if (!otg_debug_mode)
diff -ru final2/drivers/usb/storage/isd200.c ics/drivers/usb/storage/isd200.c
--- final2/drivers/usb/storage/isd200.c	2014-08-29 08:16:34.888241000 +0200
+++ ics/drivers/usb/storage/isd200.c	2013-04-19 11:37:14.000000000 +0200
@@ -499,7 +499,6 @@
 	memset(&ata, 0, sizeof(ata));
 	srb->cmnd = info->cmnd;
 	srb->device = &srb_dev;
-	++srb->serial_number;
 
 	ata.generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;
 	ata.generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;
@@ -1510,7 +1509,7 @@
  * Protocol and Transport for the ISD200 ASIC
  *
  * This protocol and transport are for ATA devices connected to an ISD200
- * ASIC.  An ATAPI device that is conected as a slave device will be
+ * ASIC.  An ATAPI device that is connected as a slave device will be
  * detected in the driver initialization function and the protocol will
  * be changed to an ATAPI protocol (Transparent SCSI).
  *
diff -ru final2/drivers/usb/storage/sierra_ms.c ics/drivers/usb/storage/sierra_ms.c
--- final2/drivers/usb/storage/sierra_ms.c	2014-08-29 08:16:34.892241000 +0200
+++ ics/drivers/usb/storage/sierra_ms.c	2013-04-19 11:37:14.000000000 +0200
@@ -126,13 +126,11 @@
 int sierra_ms_init(struct us_data *us)
 {
 	int result, retries;
-	signed long delay_t;
 	struct swoc_info *swocInfo;
 	struct usb_device *udev;
 	struct Scsi_Host *sh;
 	struct scsi_device *sd;
 
-	delay_t = 2;
 	retries = 3;
 	result = 0;
 	udev = us->pusb_dev;
diff -ru final2/drivers/video/fbmem.c ics/drivers/video/fbmem.c
--- final2/drivers/video/fbmem.c	2014-08-29 08:16:34.968241000 +0200
+++ ics/drivers/video/fbmem.c	2013-04-19 11:37:14.000000000 +0200
@@ -1345,12 +1345,15 @@
 {
 	struct fb_info *info = file_fb_info(file);
 	struct fb_ops *fb;
-	unsigned long mmio_pgoff;
+	unsigned long off;
 	unsigned long start;
 	u32 len;
 
 	if (!info)
 		return -ENODEV;
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
+		return -EINVAL;
+	off = vma->vm_pgoff << PAGE_SHIFT;
 	fb = info->fbops;
 	if (!fb)
 		return -ENODEV;
@@ -1362,24 +1365,33 @@
 		return res;
 	}
 
-	/*
-	 * Ugh. This can be either the frame buffer mapping, or
-	 * if pgoff points past it, the mmio mapping.
-	 */
+	/* frame buffer memory */
 	start = info->fix.smem_start;
-	len = info->fix.smem_len;
-	mmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;
-	if (vma->vm_pgoff >= mmio_pgoff) {
-		vma->vm_pgoff -= mmio_pgoff;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);
+	if (off >= len) {
+		/* memory mapped io */
+		off -= len;
+		if (info->var.accel_flags) {
+			mutex_unlock(&info->mm_lock);
+			return -EINVAL;
+		}
 		start = info->fix.mmio_start;
-		len = info->fix.mmio_len;
+		len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);
 	}
 	mutex_unlock(&info->mm_lock);
-
+	start &= PAGE_MASK;
+	if ((vma->vm_end - vma->vm_start + off) > len)
+		return -EINVAL;
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+	/* This is an IO map - tell maydump to skip this VMA */
+	vma->vm_flags |= VM_IO | VM_RESERVED;
 	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
-	fb_pgprotect(file, vma, start);
-
-	return vm_iomap_memory(vma, start, len);
+	fb_pgprotect(file, vma, off);
+	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
+			     vma->vm_end - vma->vm_start, vma->vm_page_prot))
+		return -EAGAIN;
+	return 0;
 }
 
 static int
diff -ru final2/drivers/video/msm/Kconfig ics/drivers/video/msm/Kconfig
--- final2/drivers/video/msm/Kconfig	2014-08-29 08:16:34.996241000 +0200
+++ ics/drivers/video/msm/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -10,7 +10,6 @@
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
-	select FB_LCD
 	---help---
 	  Support for MSM Framebuffer.
 
@@ -112,12 +111,6 @@
 	bool
 	default n
 
-config DISABLE_HDMI_FB_CLEAR
-	bool
-	default n
-	---help---
-	  Say Y here to disable clearing framebuffer for HDMI in early_suspend sequence
-
 config FB_MSM_MDDI_TOSHIBA_COMMON
 	bool
 	select FB_MSM_MDDI
@@ -177,19 +170,6 @@
         select FB_MSM_MIPI_DSI
         default n
 
-config FB_MSM_MIPI_DSI_NT35510
-	bool
-	select FB_MSM_MIPI_DSI
-
-config FB_MSM_MIPI_DSI_ORISE
-        bool
-        select FB_MSM_MIPI_DSI
-        default n
-
-config FB_MSM_MIPI_DSI_NT35516
-	bool
-	select FB_MSM_MIPI_DSI
-
 config FB_MSM_MIPI_DSI_TC358764_DSI2LVDS
 	bool
 	select FB_MSM_MIPI_DSI
@@ -242,22 +222,6 @@
 	select FB_MSM_LCDC_PANEL
 	default n
 
-config FB_MSM_LCDC_S6D16A0X_HVGA
-	bool
-	select FB_MSM_LCDC_PANEL
-	default n
-config FB_MSM_LCDC_TREBON_HVGA
-	bool
-	select FB_MSM_LCDC_PANEL
-	default n
-config FB_MSM_LCDC_AMAZING_HVGA
-	bool
-	select FB_MSM_LCDC_PANEL
-	default n
-config FB_MSM_LCDC_JENA_HVGA
-	bool
-	select FB_MSM_LCDC_PANEL
-	default n
 config FB_MSM_LCDC_SHARP_WVGA_PT
 	bool
 	select FB_MSM_LCDC_PANEL
@@ -318,32 +282,6 @@
 	select FB_MSM_MIPI_DSI_RENESAS
 	default n
 
-config FB_MSM_MIPI_NT35510_VIDEO_HYDIS_WVGA_PT
-	bool
-	select FB_MSM_MIPI_DSI_NT35510
-	default n
-
-config FB_MSM_MIPI_NT35510_CMD_HYDIS_WVGA_PT
-	bool
-	select FB_MSM_MIPI_DSI_NT35510
-	default n
-
-config FB_MSM_MIPI_NT35510_CMD_BOE_WVGA_PT
-	bool
-	select FB_MSM_MIPI_DSI_NT35510
-	default n
-
-config FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
-        bool
-        select FB_MSM_MIPI_DSI_NT35516
-        default n
-
-config FB_MSM_MIPI_NT35516_CMD_QHD_PT
-        bool
-        select FB_MSM_MIPI_DSI_NT35516
-        default n
-
-
 config FB_MSM_MIPI_CHIMEI_WXGA
 	bool "LVDS Chimei WXGA Panel using Toshiba MIPI DSI-to-LVDS bridge."
 	select FB_MSM_MIPI_DSI_TC358764_DSI2LVDS
@@ -380,16 +318,9 @@
         bool "MDP overlay write back panel enable"
 	---help---
 	  Support for MDP4 OVERLAY write back mode
-
-config FB_LCD
-	depends on FB_MSM
-	tristate "LCD Panel drivers"
-	default y
-	---help---
-	  Enable primary LCD panel support.
-       
-
-if FB_LCD
+choice
+	prompt "LCD Panel"
+	default FB_MSM_MDDI_AUTO_DETECT
 
 config FB_MSM_LCDC_PRISM_WVGA_PANEL
 	depends on FB_MSM_LCDC_HW
@@ -434,28 +365,6 @@
 	  Support for LCDC Toshiba FWVGA PT (480x864) panel. This
 	  configuration has to be selected to support the Toshiba
 	  FWVGA (480x864) portrait panel.
-config FB_MSM_LCDC_S6D16A0X_HVGA_PANEL
-	depends on FB_MSM_LCDC_HW
-	bool "FB MSM LCDC S6D16A0X HVGA Panel"
-	select FB_MSM_LCDC_S6D16A0X_HVGA
-	---help---
-	  Support for LCDC S6D16A0X HVGA (320x480) panel
-	  .
-	  .
-config FB_MSM_LCDC_TREBON_HVGA_PANEL
-	depends on FB_MSM_LCDC_HW
-	bool "FB MSM LCDC TREBON HVGA Panel"
-	select FB_MSM_LCDC_TREBON_HVGA
-	---help---
-	  Support for LCDC TREBON HVGA (320x480) panel
-	  .
-	  .
-config FB_MSM_LCDC_AMAZING_HVGA_PANEL
-	depends on FB_MSM_LCDC_HW
-	bool "FB MSM LCDC AMAZING HVGA Panel"
-	select FB_MSM_LCDC_AMAZING_HVGA
-	---help---
-	  Support for LCDC AMAZING HVGA (320x480) panel
 
 config FB_MSM_LCDC_SHARP_WVGA_PT_PANEL
 	depends on FB_MSM_LCDC_HW
@@ -494,8 +403,6 @@
 	select FB_MSM_LCDC_WXGA
 	select FB_MSM_LCDC_TOSHIBA_WVGA_PT
 	select FB_MSM_LCDC_TOSHIBA_FWVGA_PT
-	select FB_MSM_LCDC_TREBON_HVGA
-	select FB_MSM_LCDC_AMAZING_HVGA
 	select FB_MSM_LCDC_SHARP_WVGA_PT
 	select FB_MSM_LCDC_ST15_WXGA
 	---help---
@@ -512,16 +419,8 @@
 	select FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT
 	select FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT
 	select FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
-	select FB_MSM_MIPI_NT35510_VIDEO_HYDIS_WVGA_PT
-	select FB_MSM_MIPI_NT35510_CMD_HYDIS_WVGA_PT
-	select FB_MSM_MIPI_NT35510_CMD_BOE_WVGA_PT
-	select FB_MSM_MIPI_ORISE_VIDEO_720P_PT
-	select FB_MSM_MIPI_ORISE_CMD_720P_PT
-	select FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
-	select FB_MSM_MIPI_NT35516_CMD_QHD_PT
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
 	select FB_MSM_MIPI_CHIMEI_WXGA
-	select FB_MSM_MIPI_CHIMEI_WUXGA
 	---help---
 	  Support for MIPI panel auto detect
 
@@ -555,37 +454,10 @@
 	select FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT
 	select FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT
 	select FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
-	select FB_MSM_MIPI_NT35510_VIDEO_HYDIS_WVGA_PT
-	select FB_MSM_MIPI_NT35510_CMD_HYDIS_WVGA_PT
-	select FB_MSM_MIPI_NT35510_CMD_BOE_WVGA_PT
-	select FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
-	select FM_MSM_MIPI_NT35516_CMD_QHD_PT
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
 	---help---
 	  Support for LCDC + MIPI panel auto detect
 
-config FB_MSM_LVDS_MIPI_PANEL_DETECT
-	bool "LVDS + MIPI Panel Auto Detect"
-	select FB_MSM_LVDS_CHIMEI_WXGA
-	select FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT
-	select FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT
-	select FB_MSM_MIPI_TOSHIBA_VIDEO_WUXGA
-	select FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT
-	select FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT
-	select FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT
-	select FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT
-	select FB_MSM_MIPI_NOVATEK_CMD_QHD_PT
-	select FB_MSM_MIPI_NT35510_VIDEO_HYDIS_WVGA_PT
-	select FB_MSM_MIPI_NT35510_CMD_HYDIS_WVGA_PT
-	select FB_MSM_MIPI_NT35510_CMD_BOE_WVGA_PT
-	select FB_MSM_MIPI_ORISE_VIDEO_720P_PT
-	select FB_MSM_MIPI_ORISE_CMD_720P_PT
-	select FB_MSM_MIPI_SIMULATOR_VIDEO
-	select FB_MSM_MIPI_CHIMEI_WXGA
-	select FB_MSM_MIPI_CHIMEI_WUXGA
-	---help---
-	  Support for LVDS + MIPI panel auto detect
-
 config FB_MSM_MDDI_PRISM_WVGA
 	bool "MDDI Prism WVGA Panel"
 	select FB_MSM_MDDI
@@ -652,26 +524,6 @@
 	bool "MIPI Truly Video WVGA PT Panel"
 	select FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT
 
-config FB_MSM_MIPI_NT35510_VIDEO_HYDIS_WVGA_PT_PANEL
-	bool "MIPI NT35510 Video HYDIS WVGA PT Panel"
-	select FB_MSM_MIPI_NT35510_VIDEO_HYDIS_WVGA_PT
-
-config FB_MSM_MIPI_NT35510_CMD_HYDIS_WVGA_PT_PANEL
-	bool "MIPI NT35510 Command HYDIS WVGA PT Panel"
-	select FB_MSM_MIPI_NT35510_CMD_HYDIS_WVGA_PT
-
-config FB_MSM_MIPI_NT35510_CMD_BOE_WVGA_PT_PANEL
-	bool "MIPI NT35510 Command BOE WVGA PT Panel"
-	select FB_MSM_MIPI_NT35510_CMD_BOE_WVGA_PT
-
-config FB_MSM_MIPI_NT35516_VIDEO_QHD_PT_PANEL
-        bool "MIPI NT35516 Video qHD PT Panel"
-        select FB_MSM_MIPI_NT35516_VIDEO_QHD_PT
-
-config FB_MSM_MIPI_NT35516_CMD_QHD_PT_PANEL
-        bool "MIPI NT35516 Command qHD PT Panel"
-        select FB_MSM_MIPI_NT35516_CMD_QHD_PT
-
 config FB_MSM_MIPI_SIMULATOR_VIDEO_PANEL
 	bool "MIPI Simulator Video Panel"
 	select FB_MSM_MIPI_SIMULATOR_VIDEO
@@ -692,7 +544,7 @@
 	bool "NONE"
 	---help---
 	  This will disable LCD panel
-endif
+endchoice
 
 choice
 	prompt "Secondary LCD Panel"
@@ -877,7 +729,7 @@
 
 choice
 	prompt "Default framebuffer color depth"
-	depends on FB_MSM_MDP40 || FB_MSM_MDP31 || FB_MSM_MDP30
+	depends on FB_MSM_MDP40 || FB_MSM_MDP31
 	default FB_MSM_DEFAULT_DEPTH_RGBA8888
 
 config FB_MSM_DEFAULT_DEPTH_RGB565
@@ -892,4 +744,3 @@
 endchoice
 
 endif
-
Nur in final2/drivers/video/msm: lcdc_amazing.c.
Nur in final2/drivers/video/msm: lcdc_backlight_ic.c.
Nur in final2/drivers/video/msm: lcdc_backlight_ic.h.
diff -ru final2/drivers/video/msm/lcdc.c ics/drivers/video/msm/lcdc.c
--- final2/drivers/video/msm/lcdc.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/video/msm/lcdc.c	2013-04-19 11:37:14.000000000 +0200
@@ -29,7 +29,6 @@
 #include <linux/clk.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
-#include <mach/clk.h>
 
 #include "msm_fb.h"
 
@@ -78,7 +77,7 @@
 #ifndef CONFIG_MSM_BUS_SCALING
 	if (mfd->ebi1_clk) {
 		if (mdp_rev == MDP_REV_303) {
-			if (clk_set_min_rate(mfd->ebi1_clk, 0))
+			if (clk_set_rate(mfd->ebi1_clk, 0))
 				pr_err("%s: ebi1_lcdc_clk set rate failed\n",
 					__func__);
 		}
@@ -117,7 +116,7 @@
 
 	if (mfd->ebi1_clk) {
 		if (mdp_rev == MDP_REV_303) {
-			if (clk_set_min_rate(mfd->ebi1_clk, 65000000))
+			if (clk_set_rate(mfd->ebi1_clk, 65000000))
 				pr_err("%s: ebi1_lcdc_clk set rate failed\n",
 					__func__);
 		} else {
@@ -127,28 +126,16 @@
 	}
 
 #endif
-
 	mfd = platform_get_drvdata(pdev);
 
 	mfd->fbi->var.pixclock = clk_round_rate(pixel_mdp_clk,
 					mfd->fbi->var.pixclock);
-
-#if defined(CONFIG_MACH_TREBON) || defined(CONFIG_MACH_GEIM) \
-						|| defined(CONFIG_MACH_JENA) \
-						|| defined(CONFIG_MACH_AMAZING) \
-						|| defined(CONFIG_MACH_AMAZING_CDMA) \
-						|| defined(CONFIG_MACH_KYLE)
 	ret = clk_set_rate(pixel_mdp_clk, mfd->fbi->var.pixclock);
-
-	pr_err("%s:Trebon: set MDP LCDC pixel clock to %u\n",
-		__func__, mfd->fbi->var.pixclock);
-
 	if (ret) {
 		pr_err("%s: Can't set MDP LCDC pixel clock to rate %u\n",
 			__func__, mfd->fbi->var.pixclock);
 		goto out;
 	}
-#endif
 
 	clk_enable(pixel_mdp_clk);
 	clk_enable(pixel_lcdc_clk);
Nur in final2/drivers/video/msm: lcdc_s6d05a1x01.c.
Nur in final2/drivers/video/msm: lcdc_s6d16a0x_jena.c.
Nur in final2/drivers/video/msm: lcdc_s6d_backlight.c.
Nur in final2/drivers/video/msm: lcdc_s6d_backlight.h.
Nur in final2/drivers/video/msm: lcdc_trebon.c.
diff -ru final2/drivers/video/msm/logo.c ics/drivers/video/msm/logo.c
--- final2/drivers/video/msm/logo.c	2014-08-29 08:16:35.000241000 +0200
+++ ics/drivers/video/msm/logo.c	2013-04-19 11:37:14.000000000 +0200
@@ -23,7 +23,6 @@
 
 #include <linux/irq.h>
 #include <asm/system.h>
-#include <asm/cacheflush.h>
 
 #define fb_width(fb)	((fb)->var.xres)
 #define fb_height(fb)	((fb)->var.yres)
@@ -37,25 +36,6 @@
 		*ptr++ = val;
 }
 
-/* convert RGB565 to RBG8888 */
-static void memset16_rgb8888(void *_ptr, unsigned short val, unsigned count)
-{
-	unsigned short *ptr = _ptr;
-	unsigned short red;
-	unsigned short green;
-	unsigned short blue;
-
-	red = ( val & 0xF800) >> 8;
-	green = (val & 0x7E0) >> 3;
-	blue = (val & 0x1F) << 3;
-
-	count >>= 1;
-	while (count--) {
-		*ptr++ = (red<<8) | green;
-		*ptr++ = blue;
-	}
-}
-
 /* 565RLE image format: [count(2 bytes), rle(2 bytes)] */
 int load_565rle_image(char *filename, bool bf_supported)
 {
@@ -63,9 +43,6 @@
 	int fd, count, err = 0;
 	unsigned max;
 	unsigned short *data, *bits, *ptr;
-#ifndef CONFIG_FRAMEBUFFER_CONSOLE
-	struct module *owner;
-#endif
 
 	info = registered_fb[0];
 	if (!info) {
@@ -74,16 +51,6 @@
 		return -ENODEV;
 	}
 
-#ifndef CONFIG_FRAMEBUFFER_CONSOLE
-	owner = info->fbops->owner;
-	if (!try_module_get(owner))
-		return -ENODEV;
-	if (info->fbops->fb_open && info->fbops->fb_open(info, 0)) {
-		module_put(owner);
-		return -ENODEV;
-	}
-#endif
-
 	fd = sys_open(filename, O_RDONLY, 0);
 	if (fd < 0) {
 		printk(KERN_WARNING "%s: Can not open %s\n",
@@ -120,128 +87,17 @@
 		unsigned n = ptr[0];
 		if (n > max)
 			break;
-		if (info->var.bits_per_pixel >= 24) { /* rgb888 */
-			memset16_rgb8888(bits, ptr[1], n << 1);
-			bits += n * 2;
-		} else {
-			memset16(bits, ptr[1], n << 1);
-			bits += n;
-		}
+		memset16(bits, ptr[1], n << 1);
+		bits += n;
 		max -= n;
 		ptr += 2;
 		count -= 4;
 	}
 
-	flush_cache_all();
-	outer_flush_all();
-
 err_logo_free_data:
 	kfree(data);
 err_logo_close_file:
 	sys_close(fd);
-
 	return err;
 }
 EXPORT_SYMBOL(load_565rle_image);
-
-int draw_rgb888_screen(void)
-{
-	struct fb_info *fb = registered_fb[0];
-	u32 height = fb->var.yres / 5;
-	u32 line = fb->fix.line_length;
-	u32 i, j;
-
-	for (i = 0; i < height; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0x00, 1);
-		}
-	}
-
-	for (i = height; i < height * 2; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0x00, 1);
-		}
-	}
-
-	for (i = height * 2; i < height * 3; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0x00, 1);
-		}
-	}
-
-	for (i = height * 3; i < height * 4; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0x00, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0xff, 1);
-		}
-	}
-
-	for (i = height * 4; i < height * 5; i++) {
-		for (j = 0; j < fb->var.xres; j++) {
-			memset(fb->screen_base + i * line + j * 4 + 0, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 1, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 2, 0xff, 1);
-			memset(fb->screen_base + i * line + j * 4 + 3, 0x00, 1);
-		}
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(draw_rgb888_screen);
-
-int draw_rgb888_black_screen(void)
-{
-	struct fb_info *fb = registered_fb[0];
-	if (!fb) {
-		printk(KERN_WARNING "%s: Can not access framebuffer\n",
-			__func__);
-		return -ENODEV;
-	}
-	u32 height = fb->var.yres;
-	u32 line = fb->fix.line_length;
-	u32 i, j;
-#ifndef CONFIG_FRAMEBUFFER_CONSOLE
-	struct module *owner;
-#endif
-
-	if (!fb) {
-		printk(KERN_WARNING "%s: Can not access framebuffer\n",
-			__func__);
-		return -ENODEV;
-	}
-
-#ifndef CONFIG_FRAMEBUFFER_CONSOLE
-	owner = fb->fbops->owner;
-	if (!try_module_get(owner))
-		return -ENODEV;
-	if (fb->fbops->fb_open && fb->fbops->fb_open(fb, 0)) {
-		module_put(owner);
-		return -ENODEV;
-	}
-#endif
-
-/* #ifndef CONFIG_MACH_AMAZING */
-#if !defined(CONFIG_MACH_AMAZING) && !defined(CONFIG_MACH_AMAZING_CDMA)
-	for (i = 0; i < height ; i++) {
-		for (j = 0; j < fb->var.xres; j++)
-			memset(fb->screen_base + i * line + j * 4 + 0,
-				0xff000000, 4);
-	}
-#endif
-	flush_cache_all();
-	outer_flush_all();
-
-	return 0;
-}
-EXPORT_SYMBOL(draw_rgb888_black_screen);
diff -ru final2/drivers/video/msm/Makefile ics/drivers/video/msm/Makefile
--- final2/drivers/video/msm/Makefile	2014-08-29 08:16:34.996241000 +0200
+++ ics/drivers/video/msm/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -73,8 +73,8 @@
 obj-$(CONFIG_FB_MSM_MIPI_DSI_NOVATEK) += mipi_novatek.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_RENESAS) += mipi_renesas.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_TRULY) += mipi_truly.o
-obj-$(CONFIG_FB_MSM_MIPI_DSI_NT35510) += mipi_NT35510.o lcdc_backlight_ic.o
 obj-$(CONFIG_FB_MSM_MIPI_DSI_SIMULATOR) += mipi_simulator.o
+
 # MIPI Bridge
 obj-$(CONFIG_FB_MSM_MIPI_DSI_TC358764_DSI2LVDS) += mipi_tc358764_dsi2lvds.o
 
@@ -113,8 +113,6 @@
 obj-y += mipi_toshiba_video_wvga_pt.o mipi_toshiba_video_wsvga_pt.o mipi_toshiba_video_wuxga.o
 obj-y += mipi_novatek_video_qhd_pt.o mipi_novatek_cmd_qhd_pt.o
 obj-y += mipi_renesas_video_fwvga_pt.o mipi_renesas_cmd_fwvga_pt.o
-obj-y += mipi_NT35510_video_hydis_wvga_pt.o mipi_NT35510_cmd_hydis_wvga_pt.o
-obj-y += mipi_NT35510_cmd_boe_wvga_pt.o
 obj-y += mipi_chimei_wxga_pt.o
 obj-y += mipi_truly_video_wvga_pt.o
 else
@@ -126,9 +124,6 @@
 obj-$(CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT) += mipi_renesas_video_fwvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT) += mipi_renesas_cmd_fwvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_TRULY_VIDEO_WVGA_PT) += mipi_truly_video_wvga_pt.o
-obj-$(CONFIG_FB_MSM_MIPI_NT35510_CMD_HYDIS_WVGA_PT) += mipi_NT35510_cmd_hydis_wvga_pt.o
-obj-$(CONFIG_FB_MSM_MIPI_NT35510_VIDEO_HYDIS_WVGA_PT) += mipi_NT35510_video_hydis_wvga_pt.o
-obj-$(CONFIG_FB_MSM_MIPI_NT35510_CMD_BOE_WVGA_PT) += mipi_NT35510_cmd_boe_wvga_pt.o
 obj-$(CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO) += mipi_simulator_video.o
 obj-$(CONFIG_FB_MSM_MIPI_CHIMEI_WXGA) += mipi_chimei_wxga_pt.o
 endif
@@ -149,23 +144,9 @@
 obj-$(CONFIG_FB_MSM_LCDC_SAMSUNG_OLED_PT) += lcdc_samsung_oled_pt.o
 obj-$(CONFIG_FB_MSM_HDMI_ADV7520_PANEL) += adv7520.o
 obj-$(CONFIG_FB_MSM_LCDC_ST15_WXGA) += lcdc_st15.o
-obj-$(CONFIG_FB_MSM_LCDC_QRDC_WXGA) += lcdc_qrdc.o
 obj-$(CONFIG_FB_MSM_HDMI_MSM_PANEL) += hdmi_msm.o
 obj-$(CONFIG_FB_MSM_EXT_INTERFACE_COMMON) += external_common.o
 
-
-##################################
-# Lcd driver for Samsung Project #
-##################################
-obj-$(CONFIG_FB_MSM_LCDC_S6D16A0X_HVGA) += lcdc_s6d05a1x01.o lcdc_s6d_backlight.o
-obj-$(CONFIG_FB_MSM_LCDC_TREBON_HVGA) += lcdc_trebon.o lcdc_backlight_ic.o 
-obj-$(CONFIG_FB_MSM_LCDC_TREBON_HVGA) += lcdc_s6d16a0x_jena.c lcdc_backlight_ic.o 
-obj-$(CONFIG_FB_MSM_LCDC_GEIM_HVGA) += lcdc_geim.o lcdc_backlight_ic.o 
-obj-$(CONFIG_FB_MSM_LCDC_JENA_HVGA) += lcdc_jena.o lcdc_backlight_ic.o
-obj-$(CONFIG_FB_MSM_LCDC_AMAZING_HVGA) += lcdc_amazing.o lcdc_backlight_ic.o
-
-
-
 obj-$(CONFIG_FB_MSM_TVOUT) += tvout_msm.o
 
 obj-$(CONFIG_FB_MSM_EXTMDDI_SVGA) += mddi_ext_lcd.o
@@ -173,6 +154,7 @@
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += mdp4_wfd_writeback_panel.o
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += mdp4_wfd_writeback.o
 obj-$(CONFIG_FB_MSM_WRITEBACK_MSM_PANEL) += mdp4_overlay_writeback.o
+
 obj-$(CONFIG_MSM_VIDC_1080P) += vidc/
 obj-$(CONFIG_MSM_VIDC_720P) += vidc/
 
diff -ru final2/drivers/video/msm/mdp.c ics/drivers/video/msm/mdp.c
--- final2/drivers/video/msm/mdp.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/video/msm/mdp.c	2013-04-19 11:37:14.000000000 +0200
@@ -1156,7 +1156,7 @@
 static int _mdp_copy_hist_data(struct mdp_histogram_data *hist,
 						struct mdp_hist_mgmt *mgmt)
 {
-	int ret = 0;
+	int ret;
 
 	if (hist->c0) {
 		ret = copy_to_user(hist->c0, mgmt->c0,
diff -ru final2/drivers/video/msm/mdp_dma_lcdc.c ics/drivers/video/msm/mdp_dma_lcdc.c
--- final2/drivers/video/msm/mdp_dma_lcdc.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/video/msm/mdp_dma_lcdc.c	2013-04-19 11:37:14.000000000 +0200
@@ -112,13 +112,9 @@
 	bpp = fbi->var.bits_per_pixel / 8;
 	buf = (uint8 *) fbi->fix.smem_start;
 
-#if defined(CONFIG_MACH_AMAZING_CDMA)
-	dma2_cfg_reg = DMA_PACK_ALIGN_LSB | DMA_DITHER_EN |
-		DMA_OUT_SEL_LCDC; /* sjlee_0223 (enable dithering) */
-#else
 	buf += calc_fb_offset(mfd, fbi, bpp);
+
 	dma2_cfg_reg = DMA_PACK_ALIGN_LSB | DMA_OUT_SEL_LCDC;
-#endif
 
 	if (mfd->fb_imgType == MDP_BGR_565)
 		dma2_cfg_reg |= DMA_PACK_PATTERN_BGR;
@@ -203,17 +199,15 @@
 	hsync_start_x = hsync_pulse_width + h_back_porch;
 	hsync_end_x = hsync_period - h_front_porch - 1;
 	display_hctl = (hsync_end_x << 16) | hsync_start_x;
-    /*back vsync_period, display_v_end-daesu.jeong 12.02.20*/
-    vsync_period =
-	    (vsync_pulse_width + v_back_porch + lcdc_height +
-	     v_front_porch)* hsync_period;
 
-    display_v_start =
-	    (vsync_pulse_width + v_back_porch) * hsync_period +
-							lcdc_hsync_skew;
+	vsync_period =
+	    (vsync_pulse_width + v_back_porch + lcdc_height +
+	     v_front_porch) * hsync_period;
+	display_v_start =
+	    (vsync_pulse_width + v_back_porch) * hsync_period + lcdc_hsync_skew;
+	display_v_end =
+	    vsync_period - (v_front_porch * hsync_period) + lcdc_hsync_skew - 1;
 
-    display_v_end =
-      vsync_period - (v_front_porch * hsync_period) + lcdc_hsync_skew - 1;
 	if (lcdc_width != var->xres) {
 		active_h_start = hsync_start_x + first_pixel_start_x;
 		active_h_end = active_h_start + var->xres - 1;
@@ -250,10 +244,6 @@
 	hsync_polarity = 0;
 	vsync_polarity = 0;
 #endif
-#if !defined(CONFIG_MACH_AMAZING_CDMA)
-	hsync_polarity = 1;
-	vsync_polarity = 1;
-#endif
 	data_en_polarity = 0;
 
 	ctrl_polarity =
@@ -261,8 +251,7 @@
 
 	MDP_OUTP(MDP_BASE + timer_base + 0x4, hsync_ctrl);
 	MDP_OUTP(MDP_BASE + timer_base + 0x8, vsync_period);
-	MDP_OUTP(MDP_BASE + timer_base + 0xc,
-					vsync_pulse_width * hsync_period);
+	MDP_OUTP(MDP_BASE + timer_base + 0xc, vsync_pulse_width * hsync_period);
 	if (timer_base == LCDC_BASE) {
 		MDP_OUTP(MDP_BASE + timer_base + 0x10, display_hctl);
 		MDP_OUTP(MDP_BASE + timer_base + 0x14, display_v_start);
@@ -287,20 +276,12 @@
 		MDP_OUTP(MDP_BASE + timer_base + 0x38, active_v_end);
 	}
 
-#if defined(CONFIG_MACH_AMAZING) || defined(CONFIG_MACH_AMAZING_CDMA)
-  /* enable LCDC block */
-	MDP_OUTP(MDP_BASE + timer_base, 1);
-	mdp_pipe_ctrl(block, MDP_BLOCK_POWER_ON, FALSE);
-	ret = panel_next_on(pdev);
-#else
 	ret = panel_next_on(pdev);
 	if (ret == 0) {
 		/* enable LCDC block */
 		MDP_OUTP(MDP_BASE + timer_base, 1);
 		mdp_pipe_ctrl(block, MDP_BLOCK_POWER_ON, FALSE);
 	}
-#endif
-
 	/* MDP cmd block disable */
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 
@@ -322,6 +303,7 @@
 		timer_base = DTV_BASE;
 	}
 #endif
+
 	/* MDP cmd block enable */
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
 	MDP_OUTP(MDP_BASE + timer_base, 0);
@@ -329,7 +311,7 @@
 	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
 	mdp_pipe_ctrl(block, MDP_BLOCK_POWER_OFF, FALSE);
 
-		ret = panel_next_off(pdev);
+	ret = panel_next_off(pdev);
 
 	/* delay to make sure the last frame finishes */
 	msleep(16);
diff -ru final2/drivers/video/msm/mdp_lcdc.c ics/drivers/video/msm/mdp_lcdc.c
--- final2/drivers/video/msm/mdp_lcdc.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/video/msm/mdp_lcdc.c	2013-04-19 11:37:14.000000000 +0200
@@ -283,6 +283,7 @@
 	struct msm_lcdc_platform_data *pdata = pdev->dev.platform_data;
 	struct mdp_lcdc_info *lcdc;
 	int ret = 0;
+
 	if (!pdata) {
 		pr_err("%s: no LCDC platform data found\n", __func__);
 		return -EINVAL;
diff -ru final2/drivers/video/msm/mdp_ppp_v20.c ics/drivers/video/msm/mdp_ppp_v20.c
--- final2/drivers/video/msm/mdp_ppp_v20.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/video/msm/mdp_ppp_v20.c	2013-04-19 11:37:14.000000000 +0200
@@ -2422,10 +2422,7 @@
 			   uint32 width,
 			   uint32 height, int bpp, MDPIBUF *iBuf, int layer)
 {
-	if (iBuf->mdpImg.imgType == MDP_Y_CBCR_H2V2_ADRENO && layer == 0)
-		*src0 += (x + y * ALIGN(width, 32)) * bpp;
-	else
-		*src0 += (x + y * width) * bpp;
+	*src0 += (x + y * width) * bpp;
 
 	/* if it's dest/bg buffer, we need to adjust it for rotation */
 	if (layer != 0)
@@ -2436,14 +2433,9 @@
 		 * MDP_Y_CBCR_H2V2/MDP_Y_CRCB_H2V2 cosite for now
 		 * we need to shift x direction same as y dir for offsite
 		 */
-		if (iBuf->mdpImg.imgType == MDP_Y_CBCR_H2V2_ADRENO
-			&& layer == 0)
-			*src1 += ((x / h_slice) * h_slice + ((y == 0) ? 0 :
-			(((y + 1) / v_slice - 1) *
-			(ALIGN(width/2, 32) * 2)))) * bpp;
-		else
-			*src1 += ((x / h_slice) * h_slice +
-			((y == 0) ? 0 : ((y + 1) / v_slice - 1) * width)) * bpp;
+		*src1 +=
+		    ((x / h_slice) * h_slice +
+		     ((y == 0) ? 0 : ((y + 1) / v_slice - 1) * width)) * bpp;
 
 		/* if it's dest/bg buffer, we need to adjust it for rotation */
 		if (layer != 0)
diff -ru final2/drivers/video/msm/mipi_dsi.h ics/drivers/video/msm/mipi_dsi.h
--- final2/drivers/video/msm/mipi_dsi.h	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/video/msm/mipi_dsi.h	2013-04-19 11:37:14.000000000 +0200
@@ -183,11 +183,7 @@
 #define DSI_HDR_DATA1(data)	((data) & 0x0ff)
 #define DSI_HDR_WC(wc)		((wc) & 0x0ffff)
 
-#if defined(CONFIG_MACH_KYLE)
-#define DSI_BUF_SIZE	2048
-#else
 #define DSI_BUF_SIZE	1024
-#endif
 #define MIPI_DSI_MRPS	0x04  /* Maximum Return Packet Size */
 
 #define MIPI_DSI_LEN 8 /* 4 x 4 - 6 - 2, bytes dcs header+crc-align  */
Nur in final2/drivers/video/msm: mipi_NT35510.c.
Nur in final2/drivers/video/msm: mipi_NT35510_cmd_boe_wvga_pt.c.
Nur in final2/drivers/video/msm: mipi_NT35510_cmd_hydis_wvga_pt.c.
Nur in final2/drivers/video/msm: mipi_NT35510.h.
Nur in final2/drivers/video/msm: mipi_NT35510_video_hydis_wvga_pt.c.
diff -ru final2/drivers/video/msm/msm_dss_io_7x27a.c ics/drivers/video/msm/msm_dss_io_7x27a.c
--- final2/drivers/video/msm/msm_dss_io_7x27a.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/video/msm/msm_dss_io_7x27a.c	2013-04-19 11:37:14.000000000 +0200
@@ -341,11 +341,7 @@
 	mb();
 
 	clk_set_rate(dsi_byte_div_clk, data);
-#if defined(CONFIG_MACH_KYLE)
-	clk_set_rate(dsi_esc_clk, 1 << 24 | 0 << 16 | 0 << 8 | 0 );
-#else
 	clk_set_rate(dsi_esc_clk, data);
-#endif
 	clk_enable(mdp_dsi_pclk);
 	clk_enable(dsi_byte_div_clk);
 	clk_enable(dsi_esc_clk);
diff -ru final2/drivers/video/msm/msm_fb.c ics/drivers/video/msm/msm_fb.c
--- final2/drivers/video/msm/msm_fb.c	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/video/msm/msm_fb.c	2013-04-19 11:37:14.000000000 +0200
@@ -48,17 +48,6 @@
 #include "mdp.h"
 #include "mdp4.h"
 
-extern int charging_boot;
-#ifdef CONFIG_FB_MSM_LOGO
-#if defined(CONFIG_MACH_KYLE)
-#define INIT_IMAGE_FILE         "/initlogo.rle"
-#else
-#define INIT_IMAGE_FILE		"/GT-S7500.rle" /*"/initlogo.rle"*/
-#endif // End of CONFIG_FB_MSM_LOGO
-
-extern int load_565rle_image(char *filename, bool bf_supported);
-#endif
-
 #ifdef CONFIG_FB_MSM_TRIPLE_BUFFER
 #define MSM_FB_NUM	3
 #endif
@@ -256,33 +245,6 @@
 	return ret;
 }
 
-#ifdef CONFIG_APPLY_GA_SOLUTION
-/* Mark for GetLog */
-struct struct_frame_buf_mark {
-	u32 special_mark_1;
-	u32 special_mark_2;
-	u32 special_mark_3;
-	u32 special_mark_4;
-	void *p_fb;
-	u32 resX;
-	u32 resY;
-	u32 bpp;    //color depth : 16 or 24
-	u32 frames; // frame buffer count : 2
-};
-
-static struct struct_frame_buf_mark  frame_buf_mark = {
-	.special_mark_1 = (('*' << 24) | ('^' << 16) | ('^' << 8) | ('*' << 0)),
-	.special_mark_2 = (('I' << 24) | ('n' << 16) | ('f' << 8) | ('o' << 0)),
-	.special_mark_3 = (('H' << 24) | ('e' << 16) | ('r' << 8) | ('e' << 0)),
-	.special_mark_4 = (('f' << 24) | ('b' << 16) | ('u' << 8) | ('f' << 0)),
-	.p_fb   = 0,
-	.resX   = 320,
-	.resY   = 480,
-	.bpp    = 24,
-	.frames = 2
-};
-#endif
-
 static ssize_t msm_fb_msm_fb_type(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
@@ -365,6 +327,7 @@
 	struct msm_fb_data_type *mfd;
 	int rc;
 	int err = 0;
+
 	MSM_FB_DEBUG("msm_fb_probe\n");
 
 	if ((pdev->id == 0) && (pdev->num_resources > 0)) {
@@ -395,11 +358,6 @@
 	if (!msm_fb_resource_initialized)
 		return -EPERM;
 
-#ifdef CONFIG_APPLY_GA_SOLUTION
-	/* Mark for GetLog */
-	frame_buf_mark.p_fb = fbram_phys;
-#endif
-
 	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
 
 	if (!mfd)
@@ -758,7 +716,7 @@
 {
 	struct msm_fb_data_type *mfd = container_of(h, struct msm_fb_data_type,
 						    early_suspend);
-#if defined(CONFIG_FB_MSM_MDP303) && !defined CONFIG_DISABLE_HDMI_FB_CLEAR
+#if defined(CONFIG_FB_MSM_MDP303)
 	/*
 	* For MDP with overlay, set framebuffer with black pixels
 	* to show black screen on HDMI.
@@ -864,6 +822,7 @@
 			curr_pwr_state = mfd->panel_power_on;
 			mfd->panel_power_on = FALSE;
 			bl_updated = 0;
+
 			msleep(16);
 			ret = pdata->off(mfd->pdev);
 			if (ret)
@@ -877,16 +836,6 @@
 	return ret;
 }
 
-static int msm_fb_count_yres_remainder(int line_length, int yres)
-{
-	int remainder = (line_length * yres) & (PAGE_SIZE - 1);
-					/* PAGE_SIZE is a power of 2 */
-	if (!remainder)
-		remainder = PAGE_SIZE;
-
-	return remainder;
-}
-
 int calc_fb_offset(struct msm_fb_data_type *mfd, struct fb_info *fbi, int bpp)
 {
 	struct msm_panel_info *panel_info = &mfd->panel_info;
@@ -894,11 +843,14 @@
 
 	if (panel_info->mode2_yres != 0) {
 		yres = panel_info->mode2_yres;
+		remainder = (fbi->fix.line_length*yres) & (PAGE_SIZE - 1);
 	} else {
 		yres = panel_info->yres;
+		remainder = (fbi->fix.line_length*yres) & (PAGE_SIZE - 1);
 	}
 
-	remainder = msm_fb_count_yres_remainder(fbi->fix.line_length, yres);
+	if (!remainder)
+		remainder = PAGE_SIZE;
 
 	if (fbi->var.yoffset < yres) {
 		offset = (fbi->var.xoffset * bpp);
@@ -1002,13 +954,21 @@
 	u32 len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);
 	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
-
-	if ((vma->vm_end <= vma->vm_start) || (off >= len) ||
-		((vma->vm_end - vma->vm_start) > (len - off)))
-		return -EINVAL;	
+	if (off >= len) {
+		/* memory mapped io */
+		off -= len;
+		if (info->var.accel_flags) {
+			mutex_unlock(&info->lock);
+			return -EINVAL;
+		}
+		start = info->fix.mmio_start;
+		len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);
+	}
 
 	/* Set VM flags. */
 	start &= PAGE_MASK;
+	if ((vma->vm_end - vma->vm_start + off) > len)
+		return -EINVAL;
 	off += start;
 	vma->vm_pgoff = off >> PAGE_SHIFT;
 	/* This is an IO map - tell maydump to skip this VMA */
@@ -1226,11 +1186,14 @@
 	/* Make sure all buffers can be addressed on a page boundary by an x
 	 * and y offset */
 
-	remainder = msm_fb_count_yres_remainder(fix->line_length,
-						panel_info->yres);
-	remainder_mode2 = msm_fb_count_yres_remainder(fix->line_length,
-						      panel_info->mode2_yres);
-
+	remainder = (fix->line_length * panel_info->yres) & (PAGE_SIZE - 1);
+					/* PAGE_SIZE is a power of 2 */
+	if (!remainder)
+		remainder = PAGE_SIZE;
+	remainder_mode2 = (fix->line_length *
+				panel_info->mode2_yres) & (PAGE_SIZE - 1);
+	if (!remainder_mode2)
+		remainder_mode2 = PAGE_SIZE;
 
 	/*
 	 * calculate smem_len based on max size of two supplied modes.
@@ -1398,46 +1361,8 @@
 
 #ifdef CONFIG_FB_MSM_LOGO
 	/* Flip buffer */
-#if defined(CONFIG_MACH_TREBON)	|| defined(CONFIG_MACH_AMAZING_CDMA) \
-	|| defined(CONFIG_MACH_AMAZING)
-
-#if defined(CONFIG_TARGET_LOCALE_EUR_VODA)
-	if (!load_565rle_image("GT-S7509.rle", bf_supported))
+	if (!load_565rle_image(INIT_IMAGE_FILE, bf_supported))
 		;
-#else
-	if (charging_boot != 1)
-		if (!load_565rle_image("initlogo.rle", bf_supported))	/* Flip buffer */
-			;
-#endif
-#elif defined(CONFIG_MACH_GEIM)
-	if (charging_boot != 1)
-		if (!load_565rle_image("SGH-I827.rle", bf_supported))	/* Flip buffer */
-			;
-#elif defined(CONFIG_MACH_JENA)
-	if (charging_boot != 1)
-		if (!load_565rle_image("GT-S6500.rle", bf_supported))	/* Flip buffer */
-			;
-#elif defined(CONFIG_MACH_KYLE_CU)
-	if (charging_boot != 1)
-		if (!load_565rle_image("initlogo_cu.rle", bf_supported))	/* Flip buffer */
-			;
-#elif defined(CONFIG_MACH_KYLE)
-	if (charging_boot != 1)
-		if (!load_565rle_image("/initlogo.rle", bf_supported))	/* Flip buffer */
-			;
-#else
-	if (charging_boot != 1)
-		if (!load_565rle_image("initlogo.rle", bf_supported))	/* Flip buffer */
-			;
-#endif
-#if !defined(CONFIG_TARGET_LOCALE_EUR_VODA)
-	/*
-	*Check the LPM Mode
-	*If the value of charging_boot is '1', that is LPM Mode.
-	*/
-	if (charging_boot == 1)
-		draw_rgb888_black_screen();
-#endif
 #endif
 	ret = 0;
 
@@ -1742,11 +1667,6 @@
 		pdata = (struct msm_fb_panel_data *)mfd->pdev->
 			dev.platform_data;
 		if ((pdata) && (pdata->set_backlight)) {
-#if defined(CONFIG_MACH_KYLE)
-			/* setting brightness for the first time after sleep
-			 * we have to wait for the screen to update itself */
-			msleep(80);
-#endif
 			down(&mfd->sem);
 			mfd->bl_level = unset_bl_level;
 			pdata->set_backlight(mfd);
@@ -1894,8 +1814,6 @@
 	struct fb_var_screeninfo *var = &info->var;
 	int old_imgType;
 	int blank = 0;
-	int fb_page = 0;
-	int remainder;
 
 	old_imgType = mfd->fb_imgType;
 	switch (var->bits_per_pixel) {
@@ -1941,15 +1859,6 @@
 	mfd->fbi->fix.line_length = msm_fb_line_length(mfd->index, var->xres,
 						       var->bits_per_pixel/8);
 
-	/* recompure var->yres_virtual to count in remainder part */
-	remainder = msm_fb_count_yres_remainder(mfd->fbi->fix.line_length,
-		var->yres);
-	fb_page = var->yres_virtual / var->yres;
-
-	var->yres_virtual = var->yres * fb_page +
-		((PAGE_SIZE - remainder) / mfd->fbi->fix.line_length) * fb_page;
-
-
 	if (blank) {
 		msm_fb_blank_sub(FB_BLANK_POWERDOWN, info, mfd->op_enable);
 		msm_fb_blank_sub(FB_BLANK_UNBLANK, info, mfd->op_enable);
@@ -2904,11 +2813,6 @@
 		pdata = (struct msm_fb_panel_data *)mfd->pdev->
 			dev.platform_data;
 		if ((pdata) && (pdata->set_backlight)) {
-#if defined(CONFIG_MACH_KYLE)
-			/* setting brightness for the first time after sleep
-			 * we have to wait for the screen to update itself */
-			msleep(80);
-#endif
 			down(&mfd->sem);
 			mfd->bl_level = unset_bl_level;
 			pdata->set_backlight(mfd);
@@ -3740,7 +3644,7 @@
 	struct fb_info *info;
 	struct msm_fb_data_type *mfd;
 
-	if (fb_num >= MAX_FBI_LIST ||
+	if (fb_num > MAX_FBI_LIST ||
 		(subsys_id != DISPLAY_SUBSYSTEM_ID &&
 		 subsys_id != ROTATOR_SUBSYSTEM_ID)) {
 		pr_err("%s(): Invalid parameters\n", __func__);
diff -ru final2/drivers/video/msm/msm_fb.h ics/drivers/video/msm/msm_fb.h
--- final2/drivers/video/msm/msm_fb.h	2014-08-29 08:20:15.308248000 +0200
+++ ics/drivers/video/msm/msm_fb.h	2013-04-19 11:37:14.000000000 +0200
@@ -217,10 +217,8 @@
 				struct fb_info *info);
 
 #ifdef CONFIG_FB_MSM_LOGO
-extern int draw_rgb888_black_screen(void);
-#endif
-#if !defined(CONFIG_TARGET_LOCALE_EUR_VODA)
-extern int charging_boot;
+#define INIT_IMAGE_FILE "/initlogo.rle"
+int load_565rle_image(char *filename, bool bf_supported);
 #endif
 
 #endif /* MSM_FB_H */
diff -ru final2/fs/ecryptfs/ecryptfs_kernel.h ics/fs/ecryptfs/ecryptfs_kernel.h
--- final2/fs/ecryptfs/ecryptfs_kernel.h	2014-08-29 08:16:35.348241000 +0200
+++ ics/fs/ecryptfs/ecryptfs_kernel.h	2013-04-19 11:37:14.000000000 +0200
@@ -37,13 +37,6 @@
 #include <linux/nsproxy.h>
 #include <linux/backing-dev.h>
 
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-#define ENC_NAME_FILTER_MAX_INSTANCE 5
-#define ENC_NAME_FILTER_MAX_LEN (256*5)
-#define ENC_EXT_FILTER_MAX_INSTANCE 60
-#define ENC_EXT_FILTER_MAX_LEN 16
-#endif
-
 /* Version verification for shared data structures w/ userspace */
 #define ECRYPTFS_VERSION_MAJOR 0x00
 #define ECRYPTFS_VERSION_MINOR 0x04
@@ -386,10 +379,6 @@
 #define ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK   0x00000020
 #define ECRYPTFS_GLOBAL_ENCFN_USE_FEK          0x00000040
 #define ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY    0x00000080
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-#define ECRYPTFS_ENABLE_FILTERING              0x00000100
-#define ECRYPTFS_ENABLE_NEW_PASSTHROUGH        0x00000200
-#endif
 	u32 flags;
 	struct list_head global_auth_tok_list;
 	struct mutex global_auth_tok_list_mutex;
@@ -400,14 +389,6 @@
 	unsigned char global_default_fn_cipher_name[
 		ECRYPTFS_MAX_CIPHER_NAME_SIZE + 1];
 	char global_default_fnek_sig[ECRYPTFS_SIG_SIZE_HEX + 1];
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-	int max_name_filter_len;
-	char enc_filter_name[ENC_NAME_FILTER_MAX_INSTANCE]
-				[ENC_NAME_FILTER_MAX_LEN];
-	char enc_filter_ext[ENC_EXT_FILTER_MAX_INSTANCE]
-				[ENC_EXT_FILTER_MAX_LEN];
-#endif
-
 };
 
 /* superblock private data. */
@@ -787,11 +768,4 @@
 int ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,
 		       loff_t offset);
 
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-extern int is_file_name_match(struct ecryptfs_mount_crypt_stat *mcs,
-			      struct dentry *fp_dentry);
-extern int is_file_ext_match(struct ecryptfs_mount_crypt_stat *mcs,
-			     char *str);
-#endif
-
 #endif /* #ifndef ECRYPTFS_KERNEL_H */
diff -ru final2/fs/ecryptfs/file.c ics/fs/ecryptfs/file.c
--- final2/fs/ecryptfs/file.c	2014-08-29 08:16:35.352241000 +0200
+++ ics/fs/ecryptfs/file.c	2013-04-19 11:37:14.000000000 +0200
@@ -33,13 +33,6 @@
 #include <linux/fs_stack.h>
 #include "ecryptfs_kernel.h"
 
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-#include <linux/ctype.h>
-#define ECRYPTFS_IOCTL_GET_ATTRIBUTES	_IOR('l', 0x10, __u32)
-#define ECRYPTFS_WAS_ENCRYPTED 128
-#endif
-
-
 /**
  * ecryptfs_read_update_atime
  *
@@ -223,37 +216,6 @@
 		rc = 0;
 		goto out;
 	}
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-	mutex_lock(&crypt_stat->cs_mutex);
-	if ((mount_crypt_stat->flags & ECRYPTFS_ENABLE_NEW_PASSTHROUGH)
-			&& (crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {
-		if (ecryptfs_read_metadata(ecryptfs_dentry)) {
-			crypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED
-					| ECRYPTFS_ENCRYPTED);
-			mutex_unlock(&crypt_stat->cs_mutex);
-			goto out;
-		}
-	} else if ((mount_crypt_stat->flags & ECRYPTFS_ENABLE_FILTERING)
-			&& (crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {
-		struct dentry *fp_dentry =
-			ecryptfs_inode_to_private(inode)->lower_file->f_dentry;
-		char filename[NAME_MAX+1] = {0};
-		if (fp_dentry->d_name.len <= NAME_MAX)
-			memcpy(filename, fp_dentry->d_name.name,
-					fp_dentry->d_name.len + 1);
-
-		if (is_file_name_match(mount_crypt_stat, fp_dentry)
-			|| is_file_ext_match(mount_crypt_stat, filename)) {
-			if (ecryptfs_read_metadata(ecryptfs_dentry))
-				crypt_stat->flags &=
-				~(ECRYPTFS_I_SIZE_INITIALIZED
-				| ECRYPTFS_ENCRYPTED);
-			mutex_unlock(&crypt_stat->cs_mutex);
-			goto out;
-		}
-	}
-	mutex_unlock(&crypt_stat->cs_mutex);
-#endif
 	mutex_lock(&crypt_stat->cs_mutex);
 	if (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED)
 	    || !(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {
@@ -336,36 +298,7 @@
 {
 	struct file *lower_file = NULL;
 	long rc = -ENOTTY;
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-	if (cmd == ECRYPTFS_IOCTL_GET_ATTRIBUTES) {
-		u32 __user *user_attr = (u32 __user *)arg;
-		u32 attr = 0;
-		char filename[NAME_MAX+1] = {0};
-		struct dentry *ecryptfs_dentry = file->f_path.dentry;
-		struct ecryptfs_mount_crypt_stat *mount_crypt_stat =
-			&ecryptfs_superblock_to_private(ecryptfs_dentry->d_sb)
-				->mount_crypt_stat;
-
-		struct inode *inode = ecryptfs_dentry->d_inode;
-		struct ecryptfs_crypt_stat *crypt_stat =
-			&ecryptfs_inode_to_private(inode)->crypt_stat;
-		struct dentry *fp_dentry =
-			ecryptfs_inode_to_private(inode)->lower_file->f_dentry;
-		if (fp_dentry->d_name.len <= NAME_MAX)
-			memcpy(filename, fp_dentry->d_name.name,
-					fp_dentry->d_name.len + 1);
 
-		mutex_lock(&crypt_stat->cs_mutex);
-		if ((crypt_stat->flags & ECRYPTFS_ENCRYPTED) ||
-			((mount_crypt_stat->flags & ECRYPTFS_ENABLE_FILTERING)
-			&& (is_file_name_match(mount_crypt_stat, fp_dentry)
-			|| is_file_ext_match(mount_crypt_stat, filename))))
-			attr = ECRYPTFS_WAS_ENCRYPTED;
-		mutex_unlock(&crypt_stat->cs_mutex);
-		put_user(attr, user_attr);
-		return 0;
-	}
-#endif
 	if (ecryptfs_file_to_private(file))
 		lower_file = ecryptfs_file_to_lower(file);
 	if (lower_file && lower_file->f_op && lower_file->f_op->unlocked_ioctl)
@@ -388,88 +321,6 @@
 }
 #endif
 
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-int is_file_name_match(struct ecryptfs_mount_crypt_stat *mcs,
-					struct dentry *fp_dentry)
-{
-	int i;
-	char *str = NULL;
-	if (!(strcmp("/", fp_dentry->d_name.name))
-		|| !(strcmp("", fp_dentry->d_name.name)))
-		return 0;
-	str = kzalloc(mcs->max_name_filter_len + 1, GFP_KERNEL);
-	if (!str) {
-		printk(KERN_ERR "%s: Out of memory whilst attempting "
-			       "to kzalloc [%zd] bytes\n", __func__,
-			       (mcs->max_name_filter_len + 1));
-		return 0;
-	}
-
-	for (i = 0; i < ENC_NAME_FILTER_MAX_INSTANCE; i++) {
-		int len = 0;
-		struct dentry *p = fp_dentry;
-		if (!mcs->enc_filter_name[i] ||
-			 !strlen(mcs->enc_filter_name[i]))
-			break;
-
-		while (1) {
-			if (len == 0) {
-				len = strlen(p->d_name.name);
-				if (len > mcs->max_name_filter_len)
-					break;
-				strcpy(str, p->d_name.name);
-			} else {
-				len = len + 1 + strlen(p->d_name.name) ;
-				if (len > mcs->max_name_filter_len)
-					break;
-				strcat(str, "/");
-				strcat(str, p->d_name.name);
-			}
-
-			if (strnicmp(str, mcs->enc_filter_name[i], len))
-				break;
-			p = p->d_parent;
-
-			if (!(strcmp("/", p->d_name.name))
-				|| !(strcmp("", p->d_name.name))) {
-				if (len == strlen(mcs->enc_filter_name[i])) {
-					kfree(str);
-					return 1;
-				}
-				break;
-			}
-		}
-	}
-	kfree(str);
-	return 0;
-}
-
-int is_file_ext_match(struct ecryptfs_mount_crypt_stat *mcs, char *str)
-{
-	int i;
-	char ext[NAME_MAX + 1] = {0};
-
-	char *token;
-	int count = 0;
-	while ((token = strsep(&str, ".")) != NULL) {
-		strncpy(ext, token, NAME_MAX);
-		count++;
-	}
-	if (count <= 1)
-		return 0;
-
-	for (i = 0; i < ENC_EXT_FILTER_MAX_INSTANCE; i++) {
-		if (!mcs->enc_filter_ext[i] || !strlen(mcs->enc_filter_ext[i]))
-			return 0;
-		if (strlen(ext) != strlen(mcs->enc_filter_ext[i]))
-			continue;
-		if (!strnicmp(ext, mcs->enc_filter_ext[i], strlen(ext)))
-			return 1;
-	}
-	return 0;
-}
-#endif
-
 const struct file_operations ecryptfs_dir_fops = {
 	.readdir = ecryptfs_readdir,
 	.read = generic_read_dir,
diff -ru final2/fs/ecryptfs/inode.c ics/fs/ecryptfs/inode.c
--- final2/fs/ecryptfs/inode.c	2014-08-29 08:16:35.352241000 +0200
+++ ics/fs/ecryptfs/inode.c	2013-04-19 11:37:14.000000000 +0200
@@ -269,43 +269,10 @@
 			ecryptfs_dentry->d_name.name, rc);
 		goto out;
 	}
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-	mutex_lock(&crypt_stat->cs_mutex);
-	if (crypt_stat->flags & ECRYPTFS_ENCRYPTED) {
-		struct dentry *fp_dentry =
-			ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)
-			->lower_file->f_dentry;
-		struct ecryptfs_mount_crypt_stat *mount_crypt_stat =
-			&ecryptfs_superblock_to_private(ecryptfs_dentry->d_sb)
-			->mount_crypt_stat;
-		char filename[NAME_MAX+1] = {0};
-		if (fp_dentry->d_name.len <= NAME_MAX)
-			memcpy(filename, fp_dentry->d_name.name,
-					fp_dentry->d_name.len + 1);
-
-		if ((mount_crypt_stat->flags & ECRYPTFS_ENABLE_NEW_PASSTHROUGH)
-		|| ((mount_crypt_stat->flags & ECRYPTFS_ENABLE_FILTERING) &&
-			(is_file_name_match(mount_crypt_stat, fp_dentry) ||
-			is_file_ext_match(mount_crypt_stat, filename)))) {
-			crypt_stat->flags &= ~(ECRYPTFS_I_SIZE_INITIALIZED
-				| ECRYPTFS_ENCRYPTED);
-			ecryptfs_put_lower_file(ecryptfs_dentry->d_inode);
-		} else {
-			rc = ecryptfs_write_metadata(ecryptfs_dentry);
-			if (rc)
-				printk(
-				KERN_ERR "Error writing headers; rc = [%d]\n"
-				    , rc);
-			ecryptfs_put_lower_file(ecryptfs_dentry->d_inode);
-		}
-	}
-	mutex_unlock(&crypt_stat->cs_mutex);
-#else
 	rc = ecryptfs_write_metadata(ecryptfs_dentry);
 	if (rc)
 		printk(KERN_ERR "Error writing headers; rc = [%d]\n", rc);
 	ecryptfs_put_lower_file(ecryptfs_dentry->d_inode);
-#endif
 out:
 	return rc;
 }
diff -ru final2/fs/ecryptfs/Kconfig ics/fs/ecryptfs/Kconfig
--- final2/fs/ecryptfs/Kconfig	2014-08-29 08:16:35.348241000 +0200
+++ ics/fs/ecryptfs/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -12,10 +12,3 @@
 
 	  To compile this file system support as a module, choose M here: the
 	  module will be called ecryptfs.
-
-config WTL_ENCRYPTION_FILTER
-	bool "Enables filtering for some files not to encrypt on eCryptfs"
-	default n
-	depends on ECRYPT_FS
-	help
-	Modification of encrypted filesystem for SD card encryption
diff -ru final2/fs/ecryptfs/main.c ics/fs/ecryptfs/main.c
--- final2/fs/ecryptfs/main.c	2014-08-29 08:16:35.352241000 +0200
+++ ics/fs/ecryptfs/main.c	2013-04-19 11:37:14.000000000 +0200
@@ -39,12 +39,6 @@
 #include <linux/magic.h>
 #include "ecryptfs_kernel.h"
 
-
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-#include <linux/ctype.h>
-#endif
-
-
 /**
  * Module parameter that defines the ecryptfs_verbosity level.
  */
@@ -182,9 +176,6 @@
        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,
        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,
        ecryptfs_opt_check_dev_ruid,
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-	ecryptfs_opt_enable_filtering,
-#endif
        ecryptfs_opt_err };
 
 static const match_table_t tokens = {
@@ -202,9 +193,6 @@
 	{ecryptfs_opt_unlink_sigs, "ecryptfs_unlink_sigs"},
 	{ecryptfs_opt_mount_auth_tok_only, "ecryptfs_mount_auth_tok_only"},
 	{ecryptfs_opt_check_dev_ruid, "ecryptfs_check_dev_ruid"},
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-	{ecryptfs_opt_enable_filtering, "ecryptfs_enable_filtering=%s"},
-#endif
 	{ecryptfs_opt_err, NULL}
 };
 
@@ -245,57 +233,7 @@
 	mutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);
 	mount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;
 }
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-
-static int parse_enc_file_filter_parms(
-	struct ecryptfs_mount_crypt_stat *mcs, char *str)
-{
-	char *token = NULL;
-	int count = 0;
-	mcs->max_name_filter_len = 0;
-	while ((token = strsep(&str, "|")) != NULL) {
-		if (count >= ENC_NAME_FILTER_MAX_INSTANCE)
-			return -1;
-		strncpy(mcs->enc_filter_name[count++],
-			token, ENC_NAME_FILTER_MAX_LEN);
-		if (mcs->max_name_filter_len < strlen(token))
-			mcs->max_name_filter_len = strlen(token);
-	}
-	return 0;
-}
-
-
-static int parse_enc_ext_filter_parms(
-	struct ecryptfs_mount_crypt_stat *mcs, char *str)
-{
-	char *token = NULL;
-	int count = 0;
-	while ((token = strsep(&str, "|")) != NULL) {
-		if (count >= ENC_EXT_FILTER_MAX_INSTANCE)
-			return -1;
-		strncpy(mcs->enc_filter_ext[count++],
-			token, ENC_EXT_FILTER_MAX_LEN);
-	}
-	return 0;
-}
 
-static int parse_enc_filter_parms(
-	struct ecryptfs_mount_crypt_stat *mcs, char *str)
-{
-	char *token = NULL;
-	if (!strcmp("*", str)) {
-		mcs->flags |= ECRYPTFS_ENABLE_NEW_PASSTHROUGH;
-		return 0;
-	}
-	token = strsep(&str, ":");
-	if (token != NULL)
-		parse_enc_file_filter_parms(mcs, token);
-	token = strsep(&str, ":");
-	if (token != NULL)
-		parse_enc_ext_filter_parms(mcs, token);
-	return 0;
-}
-#endif
 /**
  * ecryptfs_parse_options
  * @sb: The ecryptfs super block
@@ -451,19 +389,6 @@
 		case ecryptfs_opt_check_dev_ruid:
 			*check_ruid = 1;
 			break;
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-		case ecryptfs_opt_enable_filtering:
-			rc = parse_enc_filter_parms(mount_crypt_stat,
-							 args[0].from);
-			if (rc) {
-				printk(KERN_ERR "Error attempting to parse encryption "
-							"filtering parameters.\n");
-				rc = -EINVAL;
-				goto out;
-			}
-			mount_crypt_stat->flags |= ECRYPTFS_ENABLE_FILTERING;
-			break;
-#endif
 		case ecryptfs_opt_err:
 		default:
 			printk(KERN_WARNING
@@ -933,7 +858,6 @@
 	ecryptfs_free_kmem_caches();
 }
 
-
 MODULE_AUTHOR("Michael A. Halcrow <mhalcrow@us.ibm.com>");
 MODULE_DESCRIPTION("eCryptfs");
 
diff -ru final2/fs/ecryptfs/super.c ics/fs/ecryptfs/super.c
--- final2/fs/ecryptfs/super.c	2014-08-29 08:16:35.352241000 +0200
+++ ics/fs/ecryptfs/super.c	2013-04-19 11:37:14.000000000 +0200
@@ -156,10 +156,6 @@
 	if (mount_crypt_stat->global_default_cipher_key_size)
 		seq_printf(m, ",ecryptfs_key_bytes=%zd",
 			   mount_crypt_stat->global_default_cipher_key_size);
-#ifdef CONFIG_WTL_ENCRYPTION_FILTER
-	if (mount_crypt_stat->flags & ECRYPTFS_ENABLE_FILTERING)
-		seq_printf(m, ",ecryptfs_enable_filtering");
-#endif
 	if (mount_crypt_stat->flags & ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED)
 		seq_printf(m, ",ecryptfs_passthrough");
 	if (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)
diff -ru final2/fs/ext4/extents.c ics/fs/ext4/extents.c
--- final2/fs/ext4/extents.c	2014-08-29 08:16:35.388241000 +0200
+++ ics/fs/ext4/extents.c	2013-04-19 11:37:14.000000000 +0200
@@ -2469,6 +2469,10 @@
 		if (uninitialized && num)
 			ext4_ext_mark_uninitialized(ex);
 
+		err = ext4_ext_dirty(handle, inode, path + depth);
+		if (err)
+			goto out;
+
 		/*
 		 * If the extent was completely released,
 		 * we need to remove it from the leaf
@@ -2490,10 +2494,6 @@
 			le16_add_cpu(&eh->eh_entries, -1);
 		}
 
-		err = ext4_ext_dirty(handle, inode, path + depth);
-		if (err)
-			goto out;
-
 		ext_debug("new extent: %u:%u:%llu\n", block, num,
 				ext4_ext_pblock(ex));
 		ex--;
diff -ru final2/fs/fuse/dev.c ics/fs/fuse/dev.c
--- final2/fs/fuse/dev.c	2014-08-29 08:16:35.416241000 +0200
+++ ics/fs/fuse/dev.c	2013-04-19 11:37:14.000000000 +0200
@@ -19,8 +19,6 @@
 #include <linux/pipe_fs_i.h>
 #include <linux/swap.h>
 #include <linux/splice.h>
-#include <linux/iocontext.h>
-#include <linux/ioprio.h>
 #include <linux/freezer.h>
 
 MODULE_ALIAS_MISCDEV(FUSE_MINOR);
@@ -240,39 +238,17 @@
 	return fc->reqctr;
 }
 
-static inline int is_rt(struct fuse_conn *fc)
-{
-	/* Returns 1 if request is RT class                     */
-	/* && FUSE_HANDLE_RT_CLASS bit of fc->flags is set.     */
-	/* FUSE_HANDLE_RT_CLASS bit is set by 'handle_rt_class' */
-	/* mount option while mounting a file system.           */
-	struct io_context *ioc;
-
-	if (!fc)
-		return 0;
-
-	if (!(fc->flags & FUSE_HANDLE_RT_CLASS)) /* Don't handle RT class */
-		return 0;
-
-	ioc = get_io_context(GFP_NOWAIT, 0);
-	if (ioc && IOPRIO_PRIO_CLASS(ioc->ioprio) == IOPRIO_CLASS_RT)
-		return 1;
-
-	return 0;
-}
-
-
 static void queue_request(struct fuse_conn *fc, struct fuse_req *req)
 {
 	req->in.h.len = sizeof(struct fuse_in_header) +
 		len_args(req->in.numargs, (struct fuse_arg *) req->in.args);
-	list_add_tail(&req->list, &fc->pending[is_rt(fc)]);
+	list_add_tail(&req->list, &fc->pending);
 	req->state = FUSE_REQ_PENDING;
 	if (!req->waiting) {
 		req->waiting = 1;
 		atomic_inc(&fc->num_waiting);
 	}
-	wake_up(&fc->waitq[is_rt(fc)]);
+	wake_up(&fc->waitq);
 	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
 }
 
@@ -286,7 +262,7 @@
 	if (fc->connected) {
 		fc->forget_list_tail->next = forget;
 		fc->forget_list_tail = forget;
-		wake_up(&fc->waitq[is_rt(fc)]);
+		wake_up(&fc->waitq);
 		kill_fasync(&fc->fasync, SIGIO, POLL_IN);
 	} else {
 		kfree(forget);
@@ -362,8 +338,8 @@
 
 static void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)
 {
-	list_add_tail(&req->intr_entry, &fc->interrupts[is_rt(fc)]);
-	wake_up(&fc->waitq[is_rt(fc)]);
+	list_add_tail(&req->intr_entry, &fc->interrupts);
+	wake_up(&fc->waitq);
 	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
 }
 
@@ -941,8 +917,8 @@
 
 static int request_pending(struct fuse_conn *fc)
 {
-	return !list_empty(&fc->pending[is_rt(fc)]) ||
-		!list_empty(&fc->interrupts[is_rt(fc)]) || forget_pending(fc);
+	return !list_empty(&fc->pending) || !list_empty(&fc->interrupts) ||
+		forget_pending(fc);
 }
 
 /* Wait until a request is available on the pending list */
@@ -952,7 +928,7 @@
 {
 	DECLARE_WAITQUEUE(wait, current);
 
-	add_wait_queue_exclusive(&fc->waitq[is_rt(fc)], &wait);
+	add_wait_queue_exclusive(&fc->waitq, &wait);
 	while (fc->connected && !request_pending(fc)) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (signal_pending(current))
@@ -963,7 +939,7 @@
 		spin_lock(&fc->lock);
 	}
 	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&fc->waitq[is_rt(fc)], &wait);
+	remove_wait_queue(&fc->waitq, &wait);
 }
 
 /*
@@ -1150,22 +1126,21 @@
 	if (!request_pending(fc))
 		goto err_unlock;
 
-	if (!list_empty(&fc->interrupts[is_rt(fc)])) {
-		req = list_entry(fc->interrupts[is_rt(fc)].next,
-				struct fuse_req, intr_entry);
+	if (!list_empty(&fc->interrupts)) {
+		req = list_entry(fc->interrupts.next, struct fuse_req,
+				 intr_entry);
 		return fuse_read_interrupt(fc, cs, nbytes, req);
 	}
 
 	if (forget_pending(fc)) {
-		if (list_empty(&fc->pending[is_rt(fc)]) ||
-			fc->forget_batch-- > 0)
+		if (list_empty(&fc->pending) || fc->forget_batch-- > 0)
 			return fuse_read_forget(fc, cs, nbytes);
 
 		if (fc->forget_batch <= -8)
 			fc->forget_batch = 16;
 	}
 
-	req = list_entry(fc->pending[is_rt(fc)].next, struct fuse_req, list);
+	req = list_entry(fc->pending.next, struct fuse_req, list);
 	req->state = FUSE_REQ_READING;
 	list_move(&req->list, &fc->io);
 
@@ -1866,7 +1841,7 @@
 	if (!fc)
 		return POLLERR;
 
-	poll_wait(file, &fc->waitq[is_rt(fc)], wait);
+	poll_wait(file, &fc->waitq, wait);
 
 	spin_lock(&fc->lock);
 	if (!fc->connected)
@@ -1939,8 +1914,7 @@
 {
 	fc->max_background = UINT_MAX;
 	flush_bg_queue(fc);
-	end_requests(fc, &fc->pending[0]);
-	end_requests(fc, &fc->pending[1]);
+	end_requests(fc, &fc->pending);
 	end_requests(fc, &fc->processing);
 	while (forget_pending(fc))
 		kfree(dequeue_forget(fc, 1, NULL));
@@ -1989,8 +1963,7 @@
 		end_io_requests(fc);
 		end_queued_requests(fc);
 		end_polls(fc);
-		wake_up_all(&fc->waitq[0]);
-		wake_up_all(&fc->waitq[1]);
+		wake_up_all(&fc->waitq);
 		wake_up_all(&fc->blocked_waitq);
 		kill_fasync(&fc->fasync, SIGIO, POLL_IN);
 	}
diff -ru final2/fs/fuse/fuse_i.h ics/fs/fuse/fuse_i.h
--- final2/fs/fuse/fuse_i.h	2014-08-29 08:16:35.416241000 +0200
+++ ics/fs/fuse/fuse_i.h	2013-04-19 11:37:14.000000000 +0200
@@ -44,11 +44,6 @@
     doing the mount will be allowed to access the filesystem */
 #define FUSE_ALLOW_OTHER         (1 << 1)
 
-/** If the FUSE_HANDLE_RT_CLASS flag is given,
-    then fuse handle RT class I/O in different request queue  */
-#define FUSE_HANDLE_RT_CLASS   (1 << 2)
-
-
 /** List of active connections */
 extern struct list_head fuse_conn_list;
 
@@ -347,10 +342,10 @@
 	unsigned max_write;
 
 	/** Readers of the connection are waiting on this */
-	wait_queue_head_t waitq[2];
+	wait_queue_head_t waitq;
 
 	/** The list of pending requests */
-	struct list_head pending[2];
+	struct list_head pending;
 
 	/** The list of requests being processed */
 	struct list_head processing;
@@ -380,7 +375,7 @@
 	struct list_head bg_queue;
 
 	/** Pending interrupts */
-	struct list_head interrupts[2];
+	struct list_head interrupts;
 
 	/** Queue of pending forgets */
 	struct fuse_forget_link forget_list_head;
diff -ru final2/fs/fuse/inode.c ics/fs/fuse/inode.c
--- final2/fs/fuse/inode.c	2014-08-29 08:16:35.416241000 +0200
+++ ics/fs/fuse/inode.c	2013-04-19 11:37:14.000000000 +0200
@@ -329,8 +329,7 @@
 	spin_unlock(&fc->lock);
 	/* Flush all readers on this fs */
 	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
-	wake_up_all(&fc->waitq[0]);
-	wake_up_all(&fc->waitq[1]);
+	wake_up_all(&fc->waitq);
 	wake_up_all(&fc->blocked_waitq);
 	wake_up_all(&fc->reserved_req_waitq);
 	mutex_lock(&fuse_mutex);
@@ -406,7 +405,6 @@
 	OPT_ALLOW_OTHER,
 	OPT_MAX_READ,
 	OPT_BLKSIZE,
-	OPT_HANDLE_RT_CLASS,
 	OPT_ERR
 };
 
@@ -419,7 +417,6 @@
 	{OPT_ALLOW_OTHER,		"allow_other"},
 	{OPT_MAX_READ,			"max_read=%u"},
 	{OPT_BLKSIZE,			"blksize=%u"},
-	{OPT_HANDLE_RT_CLASS,		"handle_rt_class"},
 	{OPT_ERR,			NULL}
 };
 
@@ -455,10 +452,6 @@
 			d->rootmode_present = 1;
 			break;
 
-		case OPT_HANDLE_RT_CLASS:
-			d->flags |= FUSE_HANDLE_RT_CLASS;
-			break;
-
 		case OPT_USER_ID:
 			if (match_int(&args[0], &value))
 				return 0;
@@ -530,16 +523,13 @@
 	mutex_init(&fc->inst_mutex);
 	init_rwsem(&fc->killsb);
 	atomic_set(&fc->count, 1);
-	init_waitqueue_head(&fc->waitq[0]);
-	init_waitqueue_head(&fc->waitq[1]);
+	init_waitqueue_head(&fc->waitq);
 	init_waitqueue_head(&fc->blocked_waitq);
 	init_waitqueue_head(&fc->reserved_req_waitq);
-	INIT_LIST_HEAD(&fc->pending[0]);
-	INIT_LIST_HEAD(&fc->pending[1]);
+	INIT_LIST_HEAD(&fc->pending);
 	INIT_LIST_HEAD(&fc->processing);
 	INIT_LIST_HEAD(&fc->io);
-	INIT_LIST_HEAD(&fc->interrupts[0]);
-	INIT_LIST_HEAD(&fc->interrupts[1]);
+	INIT_LIST_HEAD(&fc->interrupts);
 	INIT_LIST_HEAD(&fc->bg_queue);
 	INIT_LIST_HEAD(&fc->entry);
 	fc->forget_list_tail = &fc->forget_list_head;
diff -ru final2/fs/jbd2/transaction.c ics/fs/jbd2/transaction.c
--- final2/fs/jbd2/transaction.c	2014-08-29 08:16:35.460241000 +0200
+++ ics/fs/jbd2/transaction.c	2013-04-19 11:37:14.000000000 +0200
@@ -178,13 +178,6 @@
 		if (!new_transaction)
 			goto alloc_transaction;
 		write_lock(&journal->j_state_lock);
-		/* sangwoo2.lee, between previous 'write_lock' and
-		   'read_unlock', j_barrier_count could be set */
-		if (journal->j_barrier_count) {
-			write_unlock(&journal->j_state_lock);
-			goto repeat;
-		}
-
 		if (!journal->j_running_transaction) {
 			jbd2_get_transaction(journal, new_transaction);
 			new_transaction = NULL;
Nur in final2/include: compat.
diff -ru final2/include/linux/android_alarm.h ics/include/linux/android_alarm.h
--- final2/include/linux/android_alarm.h	2014-08-29 08:16:35.880241000 +0200
+++ ics/include/linux/android_alarm.h	2013-04-19 11:37:14.000000000 +0200
@@ -74,10 +74,6 @@
 
 /* set rtc while preserving elapsed realtime */
 int alarm_set_rtc(const struct timespec ts);
-#ifdef CONFIG_RTC_AUTO_PWRON
-int alarm_set_alarm(char *alarm_data);
-extern int rtc_set_bootalarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm);
-#endif /* CONFIG_RTC_AUTO_PWRON */
 void alarm_update_timedelta(struct timespec tv, struct timespec ts);
 
 #endif
@@ -105,7 +101,6 @@
 #define ANDROID_ALARM_SET_AND_WAIT(type)    ALARM_IOW(3, type, struct timespec)
 #define ANDROID_ALARM_GET_TIME(type)        ALARM_IOW(4, type, struct timespec)
 #define ANDROID_ALARM_SET_RTC               _IOW('a', 5, struct timespec)
-#define ANDROID_ALARM_SET_ALARM             _IOW('a', 7, struct timespec)
 #define ANDROID_ALARM_BASE_CMD(cmd)         (cmd & ~(_IOC(0, 0, 0xf0, 0)))
 #define ANDROID_ALARM_IOCTL_TO_TYPE(cmd)    (_IOC_NR(cmd) >> 4)
 
Nur in final2/include/linux: battery_charger.h.
Nur in final2/include/linux: bma023_dev.h.
Nur in final2/include/linux: bma222.h.
diff -ru final2/include/linux/clk.h ics/include/linux/clk.h
--- final2/include/linux/clk.h	2014-08-29 08:16:35.904241000 +0200
+++ ics/include/linux/clk.h	2013-04-19 11:37:14.000000000 +0200
@@ -220,5 +220,4 @@
 int clk_add_alias(const char *alias, const char *alias_dev_name, char *id,
 			struct device *dev);
 
-int clk_set_min_rate(struct clk *clk, unsigned long rate);
 #endif
diff -ru final2/include/linux/cpufreq.h ics/include/linux/cpufreq.h
--- final2/include/linux/cpufreq.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/linux/cpufreq.h	2013-04-19 11:37:14.000000000 +0200
@@ -339,63 +339,6 @@
 }
 #endif
 
-#ifdef CONFIG_SEC_DVFS
-enum {
-	BOOT_CPU = 0,
-	NON_BOOT_CPU = 1
-};
-
-#ifdef CONFIG_MACH_AMAZING
-
-#define MAX_FREQ_LIMIT		800000
-#define MIN_FREQ_LIMIT		122880
-#define MAX_TOUCH_LIMIT		600000
-#define MAX_UNICPU_LIMIT	600000
-
-#elif defined(CONFIG_MACH_KYLE)
-
-#define MAX_FREQ_LIMIT		1008000
-#define MIN_FREQ_LIMIT		122880
-#define MAX_TOUCH_LIMIT		600000
-#define MAX_UNICPU_LIMIT	600000
-
-#else	/* default */
-
-#define MAX_FREQ_LIMIT		800000
-#define MIN_FREQ_LIMIT		122880
-#define MAX_TOUCH_LIMIT		600000
-#define MAX_UNICPU_LIMIT	600000
-
-#endif
-
-#define UPDATE_NOW_BITS		0xFF
-
-enum {
-	DVFS_NO_ID = 0,
-
-	/* need to update now */
-	DVFS_TOUCH_ID = 0x00000001,
-	DVFS_APPS_MIN_ID = 0x00000002,
-	DVFS_APPS_MAX_ID = 0x00000004,
-	DVFS_UNICPU_ID = 0x00000008,
-
-	/* DO NOT UPDATE NOW */
-	DVFS_THERMALD_ID = 0x00000100,
-
-	DVFS_MAX_ID
-};
-
-#ifdef CONFIG_SEC_DVFS_DUAL
-void dual_boost(unsigned int boost_on);
-#endif
-
-int set_freq_limit(unsigned long id, unsigned int freq);
-
-unsigned int get_min_lock(void);
-unsigned int get_max_lock(void);
-void set_min_lock(int freq);
-void set_max_lock(int freq);
-#endif
 
 /*********************************************************************
  *                       CPUFREQ DEFAULT GOVERNOR                    *
Nur in final2/include/linux: fsaxxxx_usbsw.h.
diff -ru final2/include/linux/fs.h ics/include/linux/fs.h
--- final2/include/linux/fs.h	2014-08-29 08:16:35.920241000 +0200
+++ ics/include/linux/fs.h	2013-04-19 11:37:14.000000000 +0200
@@ -1552,7 +1552,6 @@
 	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	int (*readdir) (struct file *, void *, filldir_t);
 	unsigned int (*poll) (struct file *, struct poll_table_struct *);
-	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);
@@ -1627,7 +1626,6 @@
    	void (*dirty_inode) (struct inode *, int flags);
 	int (*write_inode) (struct inode *, struct writeback_control *wbc);
 	int (*drop_inode) (struct inode *);
-	void (*delete_inode) (struct inode *);
 	void (*evict_inode) (struct inode *);
 	void (*put_super) (struct super_block *);
 	void (*write_super) (struct super_block *);
@@ -1636,7 +1634,6 @@
 	int (*unfreeze_fs) (struct super_block *);
 	int (*statfs) (struct dentry *, struct kstatfs *);
 	int (*remount_fs) (struct super_block *, int *, char *);
-	void (*clear_inode) (struct inode *);
 	void (*umount_begin) (struct super_block *);
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
@@ -2278,7 +2275,6 @@
 
 extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);
-extern void clear_inode(struct inode *);
 extern void end_writeback(struct inode *);
 extern void __destroy_inode(struct inode *);
 extern struct inode *new_inode_pseudo(struct super_block *sb);
@@ -2488,7 +2484,6 @@
 
 extern int inode_change_ok(const struct inode *, struct iattr *);
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
-extern int __must_check inode_setattr(struct inode *, struct iattr *);
 extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
 extern void file_update_time(struct file *file);
Nur in final2/include/linux: fuelgauge_max17043.h.
Nur in final2/include/linux: fuelgauge_max17048.h.
Nur in final2/include/linux: gp2a.h.
diff -ru final2/include/linux/gpio_event.h ics/include/linux/gpio_event.h
--- final2/include/linux/gpio_event.h	2014-08-29 08:16:35.924241000 +0200
+++ ics/include/linux/gpio_event.h	2013-04-19 11:37:14.000000000 +0200
@@ -82,10 +82,6 @@
 	unsigned int *output_gpios;
 	unsigned int ninputs;
 	unsigned int noutputs;
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-	unsigned int *wakeup_gpios;
-	unsigned int nwakeups;
-#endif
 	/* time to wait before reading inputs after driving each output */
 	struct timespec settle_time;
 	/* time to wait before scanning the keypad a second time */
@@ -125,8 +121,6 @@
 	size_t keymap_size;
 };
 
-extern struct class *sec_class;
-
 /* outputs */
 extern int gpio_event_output_func(struct gpio_event_input_devs *input_devs,
 			struct gpio_event_info *info, void **data, int func);
@@ -173,7 +167,4 @@
 uint16_t gpio_axis_5bit_singletrack_map(
 			struct gpio_event_axis_info *info, uint16_t in);
 
-#if defined(CONFIG_MACH_KYLE) || defined(CONFIG_MACH_AMAZING)
-int gpio_event_get_wakeup_keys_status(void);
-#endif
 #endif
Nur in final2/include/linux/i2c: europa_tsp_gpio.h.
Nur in final2/include/linux/i2c: melfas_ts.h.
Nur in final2/include/linux/i2c: tsp_gpio.h.
Nur in final2/include/linux/input: stmpe1801.h.
diff -ru final2/include/linux/ion.h ics/include/linux/ion.h
--- final2/include/linux/ion.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/linux/ion.h	2013-04-19 11:37:14.000000000 +0200
@@ -44,7 +44,7 @@
 	ION_HEAP_TYPE_CP,
 	ION_HEAP_TYPE_CUSTOM, /* must be last so device specific heaps always
 				 are at the end of this enum */
-	ION_NUM_HEAPS = 16,
+	ION_NUM_HEAPS,
 };
 
 #define ION_HEAP_SYSTEM_MASK		(1 << ION_HEAP_TYPE_SYSTEM)
diff -ru final2/include/linux/ktime.h ics/include/linux/ktime.h
--- final2/include/linux/ktime.h	2014-08-29 08:16:35.956241000 +0200
+++ ics/include/linux/ktime.h	2013-04-19 11:37:14.000000000 +0200
@@ -45,7 +45,7 @@
  */
 union ktime {
 	s64	tv64;
-#if BITS_PER_LONG != 64 && defined(CONFIG_KTIME_SCALAR)
+#if BITS_PER_LONG != 64 && !defined(CONFIG_KTIME_SCALAR)
 	struct {
 # ifdef __BIG_ENDIAN
 	s32	sec, nsec;
Nur in final2/include/linux: mecs.h.
Nur in final2/include/linux: melfas_ts.h.
Nur in final2/include/linux: mmc328x.h.
diff -ru final2/include/linux/mm.h ics/include/linux/mm.h
--- final2/include/linux/mm.h	2014-08-29 08:16:35.980241000 +0200
+++ ics/include/linux/mm.h	2013-04-19 11:37:14.000000000 +0200
@@ -1547,7 +1547,6 @@
 			unsigned long pfn);
 int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
 			unsigned long pfn);
-int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len);
 
 struct page *follow_page(struct vm_area_struct *, unsigned long address,
 			unsigned int foll_flags);
diff -ru final2/include/linux/msm_audio.h ics/include/linux/msm_audio.h
--- final2/include/linux/msm_audio.h	2014-08-29 08:16:35.992241000 +0200
+++ ics/include/linux/msm_audio.h	2013-04-19 11:37:14.000000000 +0200
@@ -217,10 +217,6 @@
 #define SND_SET_DEVICE _IOW(SND_IOCTL_MAGIC, 2, struct msm_device_config *)
 
 #define SND_METHOD_VOICE 0
-#if defined(CONFIG_MACH_KYLE_HKTW) || defined(CONFIG_MACH_KYLE_CHN) || defined(CONFIG_MACH_KYLE_I)
-#define SND_METHOD_MIDI  4
-#endif
-
 
 struct msm_snd_volume_config {
 	uint32_t device;
diff -ru final2/include/linux/msm_mdp.h ics/include/linux/msm_mdp.h
--- final2/include/linux/msm_mdp.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/linux/msm_mdp.h	2013-04-19 11:37:14.000000000 +0200
@@ -99,7 +99,7 @@
 	MDP_IMGTYPE_LIMIT,
 	MDP_BGR_565 = MDP_IMGTYPE2_START,      /* BGR 565 planer */
 	MDP_FB_FORMAT,    /* framebuffer format */
-	MDP_IMGTYPE_LIMIT2, /* Non valid image type after this enum */
+	MDP_IMGTYPE_LIMIT2 /* Non valid image type after this enum */
 };
 
 enum {
Nur in final2/include/linux/platform_data: modem.h.
Nur in final2/include/linux: pn544.h.
diff -ru final2/include/linux/power_supply.h ics/include/linux/power_supply.h
--- final2/include/linux/power_supply.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/linux/power_supply.h	2013-04-19 11:37:14.000000000 +0200
@@ -123,15 +123,11 @@
 	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
 	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
 	POWER_SUPPLY_PROP_TYPE, /* use power_supply.type instead */
-	POWER_SUPPLY_PROP_FUELGAUGE_STATE, /*for SAMSUNG fuelgauging */
 	POWER_SUPPLY_PROP_SCOPE,
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
 	POWER_SUPPLY_PROP_SERIAL_NUMBER,
-        /*Fuelgauge properties*/
-        POWER_SUPPLY_PROP_FUELGAUGE_RCONFIG,
-        POWER_SUPPLY_PROP_FUELGAUGE_RESET,
 };
 
 enum power_supply_type {
diff -ru final2/include/linux/quotaops.h ics/include/linux/quotaops.h
--- final2/include/linux/quotaops.h	2014-08-29 08:16:36.032241000 +0200
+++ ics/include/linux/quotaops.h	2013-04-19 11:37:14.000000000 +0200
@@ -61,7 +61,6 @@
 void dquot_free_inode(const struct inode *inode);
 
 int dquot_disable(struct super_block *sb, int type, unsigned int flags);
-void vfs_dq_drop(struct inode *inode);
 /* Suspend quotas on remount RO */
 static inline int dquot_suspend(struct super_block *sb, int type)
 {
@@ -254,9 +253,6 @@
 	return 0;
 }
 
-static inline void vfs_dq_drop(struct inode *inode)
-{
-}
 #define dquot_file_open		generic_file_open
 
 #endif /* CONFIG_QUOTA */
diff -ru final2/include/linux/regulator/consumer.h ics/include/linux/regulator/consumer.h
--- final2/include/linux/regulator/consumer.h	2014-08-29 08:16:36.032241000 +0200
+++ ics/include/linux/regulator/consumer.h	2013-04-19 11:37:14.000000000 +0200
@@ -313,5 +313,4 @@
 
 #endif
 
-void regulator_showall_enabled(void);
 #endif
diff -ru final2/include/linux/rtc.h ics/include/linux/rtc.h
--- final2/include/linux/rtc.h	2014-08-29 08:16:36.040241000 +0200
+++ ics/include/linux/rtc.h	2013-04-19 11:37:14.000000000 +0200
@@ -148,10 +148,6 @@
 	int (*set_time)(struct device *, struct rtc_time *);
 	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
 	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
-#ifdef CONFIG_RTC_AUTO_PWRON
-	int (*read_bootalarm)(struct device *, struct rtc_wkalrm *);
-	int (*set_bootalarm)(struct device *, struct rtc_wkalrm *);
-#endif /* CONFIG_RTC_AUTO_PWRON */
 	int (*proc)(struct device *, struct seq_file *);
 	int (*set_mmss)(struct device *, unsigned long secs);
 	int (*read_callback)(struct device *, int data);
diff -ru final2/include/linux/sched.h ics/include/linux/sched.h
--- final2/include/linux/sched.h	2014-08-29 08:16:36.056241000 +0200
+++ ics/include/linux/sched.h	2013-04-19 11:37:14.000000000 +0200
@@ -2564,16 +2564,7 @@
 extern void recalc_sigpending_and_wake(struct task_struct *t);
 extern void recalc_sigpending(void);
 
-extern void signal_wake_up_state(struct task_struct *t, unsigned int state);
-
-static inline void signal_wake_up(struct task_struct *t, bool resume)
-{
-	signal_wake_up_state(t, resume ? TASK_WAKEKILL : 0);
-}
-static inline void ptrace_signal_wake_up(struct task_struct *t, bool resume)
-{
-	signal_wake_up_state(t, resume ? __TASK_TRACED : 0);
-}
+extern void signal_wake_up(struct task_struct *t, int resume_stopped);
 
 /*
  * Wrappers for p->thread_info->cpu access. No-op on UP.
@@ -2710,187 +2701,3 @@
 #endif /* __KERNEL__ */
 
 #endif
-
-//{{ Add GAForensicINFO
-#ifdef CONFIG_APPLY_GA_SOLUTION
-#pragma once
-#include <linux/fs.h>
-#include <linux/mount.h>
-#include <asm/pgtable.h>
-
-static struct GAForensicINFO{
-  unsigned short ver;
-  unsigned int size;
-  unsigned short task_struct_struct_state;
-  unsigned short task_struct_struct_comm;
-  unsigned short task_struct_struct_tasks;
-  unsigned short task_struct_struct_pid;
-  unsigned short task_struct_struct_stack;
-  unsigned short task_struct_struct_mm;
-  unsigned short mm_struct_struct_start_data;
-  unsigned short mm_struct_struct_end_data;
-  unsigned short mm_struct_struct_start_brk;
-  unsigned short mm_struct_struct_brk;
-  unsigned short mm_struct_struct_start_stack;
-  unsigned short mm_struct_struct_arg_start;
-  unsigned short mm_struct_struct_arg_end;
-  unsigned short mm_struct_struct_pgd;
-  unsigned short mm_struct_struct_mmap;
-  unsigned short vm_area_struct_struct_vm_start;
-  unsigned short vm_area_struct_struct_vm_end;
-  unsigned short vm_area_struct_struct_vm_next;
-  unsigned short vm_area_struct_struct_vm_file;
-  unsigned short thread_info_struct_cpu_context;
-  unsigned short cpu_context_save_struct_sp;
-  unsigned short file_struct_f_path;
-  unsigned short path_struct_mnt;
-  unsigned short path_struct_dentry;
-  unsigned short dentry_struct_d_parent;
-  unsigned short dentry_struct_d_name;
-  unsigned short qstr_struct_name;
-  unsigned short vfsmount_struct_mnt_mountpoint;
-  unsigned short vfsmount_struct_mnt_root;
-  unsigned short vfsmount_struct_mnt_parent;
-  unsigned int pgdir_shift;
-  unsigned int ptrs_per_pte;
-  unsigned int phys_offset;
-  unsigned int page_offset;
-  unsigned int page_shift;
-  unsigned int page_size;
-  unsigned short task_struct_struct_thread_group;
-  unsigned short task_struct_struct_utime;
-  unsigned short task_struct_struct_stime;
-  unsigned short list_head_struct_next;
-  unsigned short list_head_struct_prev;
-  unsigned short rq_struct_curr;
-
-  unsigned short thread_info_struct_cpu;
-
-  unsigned short task_struct_struct_prio;
-  unsigned short task_struct_struct_static_prio;
-  unsigned short task_struct_struct_normal_prio;
-  unsigned short task_struct_struct_rt_priority;
-
-  unsigned short task_struct_struct_se;
-
-  unsigned short sched_entity_struct_exec_start;
-  unsigned short sched_entity_struct_sum_exec_runtime;
-  unsigned short sched_entity_struct_prev_sum_exec_runtime;
-
-  unsigned short task_struct_struct_sched_info;
-
-  unsigned short sched_info_struct_pcount;
-  unsigned short sched_info_struct_run_delay;
-  unsigned short sched_info_struct_last_arrival;
-  unsigned short sched_info_struct_last_queued;
-
-  unsigned short task_struct_struct_blocked_on;
-  unsigned short mutex_waiter_struct_list;
-  unsigned short mutex_waiter_struct_task;
-
-  unsigned short sched_entity_struct_cfs_rq_struct;;
-  unsigned short cfs_rq_struct_rq_struct;
-  unsigned short gaf_fp;
-  
-  unsigned short GAFINFOCheckSum;
-}GAFINFO= {
-  .ver=0x0300, 
-  .size=sizeof(GAFINFO), 
-  .task_struct_struct_state=offsetof(struct task_struct,state), 
-  .task_struct_struct_comm=offsetof(struct task_struct,comm), 
-  .task_struct_struct_tasks=offsetof(struct task_struct,tasks),
-  .task_struct_struct_pid=offsetof(struct task_struct,pid), 
-  .task_struct_struct_stack=offsetof(struct task_struct,stack), 
-  .task_struct_struct_mm=offsetof(struct task_struct,mm),
-  
-  .mm_struct_struct_start_data=offsetof(struct mm_struct,start_data),
-  .mm_struct_struct_end_data=offsetof(struct mm_struct,end_data),
-  .mm_struct_struct_start_brk=offsetof(struct mm_struct,start_brk),
-  .mm_struct_struct_brk=offsetof(struct mm_struct,brk),
-  .mm_struct_struct_start_stack=offsetof(struct mm_struct,start_stack),
-  .mm_struct_struct_arg_start=offsetof(struct mm_struct,arg_start),
-  .mm_struct_struct_arg_end=offsetof(struct mm_struct,arg_end),
-  .mm_struct_struct_pgd=offsetof(struct mm_struct,pgd),
-  .mm_struct_struct_mmap=offsetof(struct mm_struct,mmap),
-
-  .vm_area_struct_struct_vm_start=offsetof(struct vm_area_struct,vm_start),
-  .vm_area_struct_struct_vm_end=offsetof(struct vm_area_struct,vm_end),
-  .vm_area_struct_struct_vm_next=offsetof(struct vm_area_struct,vm_next),
-  .vm_area_struct_struct_vm_file=offsetof(struct vm_area_struct,vm_file),
-
-  .thread_info_struct_cpu_context=offsetof(struct thread_info,cpu_context),
-  .cpu_context_save_struct_sp=offsetof(struct cpu_context_save,sp),
-  .file_struct_f_path=offsetof(struct file,f_path),
-  .path_struct_mnt=offsetof(struct path,mnt),
-  .path_struct_dentry=offsetof(struct path,dentry),
-  .dentry_struct_d_parent=offsetof(struct dentry,d_parent),
-  .dentry_struct_d_name=offsetof(struct dentry,d_name),
-  .qstr_struct_name=offsetof(struct qstr,name),
-  .vfsmount_struct_mnt_mountpoint=offsetof(struct vfsmount,mnt_mountpoint),
-  .vfsmount_struct_mnt_root=offsetof(struct vfsmount,mnt_root),
-  .vfsmount_struct_mnt_parent=offsetof(struct vfsmount,mnt_parent),
-  .pgdir_shift=0x15,
-  .ptrs_per_pte=0x200,
-  .phys_offset=PHYS_OFFSET,
-  .page_offset=PAGE_OFFSET,
-  .page_shift=PAGE_SHIFT,
-  .page_size=PAGE_SIZE,
-  .task_struct_struct_thread_group =offsetof(struct task_struct, thread_group),
-  .task_struct_struct_utime= offsetof(struct task_struct, utime),
-  .task_struct_struct_stime= offsetof(struct task_struct, stime),
-  .list_head_struct_next=offsetof(struct list_head, next),
-  .list_head_struct_prev=offsetof(struct list_head, prev),
-  .rq_struct_curr=0,
-  .thread_info_struct_cpu=offsetof(struct thread_info, cpu),
-  .task_struct_struct_prio=offsetof(struct task_struct, prio),
-  .task_struct_struct_static_prio=offsetof(struct task_struct, static_prio),
-  .task_struct_struct_normal_prio=offsetof(struct task_struct, normal_prio),
-  .task_struct_struct_rt_priority=offsetof(struct task_struct, rt_priority),
-  .task_struct_struct_se=offsetof(struct task_struct, se),
-
-  .sched_entity_struct_exec_start=offsetof(struct sched_entity, exec_start),
-  .sched_entity_struct_sum_exec_runtime=offsetof(struct sched_entity, sum_exec_runtime),
-  .sched_entity_struct_prev_sum_exec_runtime=offsetof(struct sched_entity, prev_sum_exec_runtime),
-
-#if defined (CONFIG_SCHEDSTATS) || (CONFIG_TASK_DELAY_ACCT)
-  .task_struct_struct_sched_info=offsetof(struct task_struct, sched_info),
-  .sched_info_struct_pcount=offsetof(struct sched_info, pcount),
-  .sched_info_struct_run_delay=offsetof(struct sched_info, run_delay),
-  .sched_info_struct_last_arrival=offsetof(struct sched_info, last_arrival),
-  .sched_info_struct_last_queued=offsetof(struct sched_info, last_queued),
-#else
-  .task_struct_struct_sched_info=0x1223,
-  .sched_info_struct_pcount=0x1224,
-  .sched_info_struct_run_delay=0x1225,
-  .sched_info_struct_last_arrival=0x1226,
-  .sched_info_struct_last_queued=0x1227,
-#endif
-
-#ifdef CONFIG_DEBUG_MUTEXES
-  .task_struct_struct_blocked_on=offsetof(struct task_struct, blocked_on),
-  .mutex_waiter_struct_list=offsetof(struct mutex_waiter, list),
-  .mutex_waiter_struct_task=offsetof(struct mutex_waiter, task),
-#else
-  .task_struct_struct_blocked_on=0x1228,
-  .mutex_waiter_struct_list=0x1229,
-  .mutex_waiter_struct_task=0x122a,
-#endif
-
-#ifdef CONFIG_FAIR_GROUP_SCHED
-  .sched_entity_struct_cfs_rq_struct=offsetof(struct sched_entity, cfs_rq),
-#else
-  .sched_entity_struct_cfs_rq_struct=0x122b,
-#endif
-
-  .cfs_rq_struct_rq_struct=0,
-
-#ifdef CONFIG_FRAME_POINTER
-  .gaf_fp=1,
-#else
-  .gaf_fp=0,
-#endif
-
-  .GAFINFOCheckSum=0
-};
-#endif
-//}} Add GAForensicINFO
Nur in final2/include/linux: sec_debug.h.
Nur in final2/include/linux: sec_jack.h.
Nur in final2/include/linux: sec_param.h.
diff -ru final2/include/linux/semaphore.h ics/include/linux/semaphore.h
--- final2/include/linux/semaphore.h	2014-08-29 08:16:36.056241000 +0200
+++ ics/include/linux/semaphore.h	2013-04-19 11:37:14.000000000 +0200
@@ -36,7 +36,6 @@
 	lockdep_init_map(&sem->lock.dep_map, "semaphore->lock", &__key, 0);
 }
 
-#define init_MUTEX(sem)		sema_init(sem, 1)
 extern void down(struct semaphore *sem);
 extern int __must_check down_interruptible(struct semaphore *sem);
 extern int __must_check down_killable(struct semaphore *sem);
Nur in final2/include/linux: smb328a_charger.h.
diff -ru final2/include/linux/usb/composite.h ics/include/linux/usb/composite.h
--- final2/include/linux/usb/composite.h	2014-08-29 08:16:36.076241000 +0200
+++ ics/include/linux/usb/composite.h	2013-04-19 11:37:14.000000000 +0200
@@ -108,11 +108,7 @@
 	struct usb_descriptor_header	**hs_descriptors;
 
 	struct usb_configuration	*config;
-#ifdef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	int	(*set_intf_num)(struct usb_function *f,
-			int intf_num, int index_num);
-	int	(*set_config_desc)(int conf_num);
-#endif
+
 	/* REVISIT:  bind() functions can be marked __init, which
 	 * makes trouble for section mismatch analysis.  See if
 	 * we can't restructure things to avoid mismatching.
diff -ru final2/include/linux/usb/gadget.h ics/include/linux/usb/gadget.h
--- final2/include/linux/usb/gadget.h	2014-08-29 08:16:36.076241000 +0200
+++ ics/include/linux/usb/gadget.h	2013-04-19 11:37:14.000000000 +0200
@@ -431,9 +431,6 @@
 	int	(*pullup) (struct usb_gadget *, int is_on);
 	int	(*ioctl)(struct usb_gadget *,
 				unsigned code, unsigned long param);
-#ifdef CONFIG_USB_MSM_72K
-	int    (*get_vbus_state)(struct usb_gadget *);
-#endif 
 };
 
 /**
diff -ru final2/include/media/msm_camera.h ics/include/media/msm_camera.h
--- final2/include/media/msm_camera.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/media/msm_camera.h	2013-04-19 11:37:14.000000000 +0200
@@ -199,17 +199,6 @@
 	int32_t type;
 	struct msm_mctl_pp_cmd cmd;
 };
-#if 1//PCAM
-typedef struct{
-        unsigned short mode;
-        unsigned short address;
-        unsigned short value_1;
-        unsigned short value_2;
-        unsigned short value_3;
-} ioctl_pcam_info_8bit;
-
-#define MSM_CAM_IOCTL_PCAM_CTRL_8BIT   _IOWR(MSM_CAM_IOCTL_MAGIC, 40, ioctl_pcam_info_8bit)
-#endif//PCAM
 
 #define MSM_CAMERA_LED_OFF  0
 #define MSM_CAMERA_LED_LOW  1
@@ -1231,413 +1220,6 @@
 	int8_t total_steps;
 	uint8_t support_3d;
 };
-#if 1 //defined (CONFIG_OEM_CAMERA)
-typedef struct{
-	uint32_t device_id;
-	uint32_t cmd;
-	uint32_t  value_1;
-	uint32_t  value_2;
-	void* p;
-} sensor_ext_cfg_data;
-
-typedef struct {
-	char company;
-	char module_vesion;
-	char year;
-	char month;
-	char update_times[2];
-} sensor_version_info;
-
-typedef struct {
-	uint32_t dev_num;
-	char module_name[10];
-} sensor_name_info;
-
-struct sensor_version {
-	unsigned int major;
-	unsigned int minor;
-};
-
-struct sensor_date_info {
-	unsigned int year;
-	unsigned int month;
-	unsigned int date;
-};
-
-struct sensor_sensor_maker{
-	unsigned int maker;
-	unsigned int optical;
-};
-
-struct sensor_version_af{
-	unsigned int low;
-	unsigned int high;
-};
-
-struct sensor_gamma{
-	unsigned int rg_low;
-	unsigned int rg_high;
-	unsigned int bg_low;
-	unsigned int bg_high;
-};
-
-struct sensor_firmware_info
-{
-    struct sensor_version fw;
-    struct sensor_version prm;
-    struct sensor_date_info dateinfo;
-    struct sensor_sensor_maker sensor_info;
-    struct sensor_version_af af_info;
-    struct sensor_gamma gamma;
-    unsigned int fw_dump_size;
-	unsigned  int sensor_version;
-};
-
-struct gps_info_common {
-	unsigned int 	direction;
-	unsigned int 	dgree;
-	unsigned int	minute;
-	unsigned int	second;
-};
-
-enum v4l2_blur
-{
-	BLUR_LEVEL_0 = 0,
-	BLUR_LEVEL_1,
-	BLUR_LEVEL_2,
-	BLUR_LEVEL_3,
-	BLUR_LEVEL_MAX,
-};
-
-#define MSM_CAM_IOCTL_EXT_CONFIG  _IOWR(MSM_CAM_IOCTL_MAGIC, 50, sensor_ext_cfg_data)
-#define MSM_CAM_IOCTL_FIRMWARE_UPDATE  _IOWR(MSM_CAM_IOCTL_MAGIC, 51, sensor_ext_cfg_data)
-#define MSM_CAM_IOCTL_READ_VERSION_INFO  _IOWR(MSM_CAM_IOCTL_MAGIC, 52, struct sensor_firmware_info)
-#define MSM_CAM_IOCTL_READ_MODULE_NAME  _IOWR(MSM_CAM_IOCTL_MAGIC, 53, sensor_name_info)
-
-#define	EXIF_EXPOSURE_TIME		        0
-#define	EXIF_TV					1
-#define	EXIF_AV					2
-#define	EXIF_BV					3
-#define	EXIF_EBV				4
-#define	EXIF_ISO				5
-#define	EXIF_FLASH				6
-
-enum ext_cfg_command
-{
-    EXT_CFG_SET_FLASH = 0,
-    EXT_CFG_SET_FLASH_MODE,
-    EXT_CFG_SET_AUTO_CONTRAST,
-    EXT_CFG_SET_SCENE,
-    EXT_CFG_SET_SHARPNESS,
-    EXT_CFG_SET_EFFECT,
-    EXT_CFG_SET_SATURATION,
-    EXT_CFG_SET_ISO,
-    EXT_CFG_SET_WB,
-    EXT_CFG_SET_CONTRAST,
-    EXT_CFG_SET_BRIGHTNESS,
-    EXT_CFG_SET_ZOOM,
-    EXT_CFG_SET_FPS,
-    EXT_CFG_SET_FPS_MODE,
-    EXT_CFG_SET_AF_MODE,
-    EXT_CFG_SET_AF_START,
-    EXT_CFG_SET_AF_STOP,
-    EXT_CFG_SET_AF_OPERATION,
-    EXT_CFG_GET_AF_STATUS,
-    EXT_CFG_SET_TOUCHAF_POS,
-    EXT_CFG_SET_FACE_DETECT,
-    EXT_CFG_SET_METERING,
-    EXT_CFG_SET_CONTINUOUS_AF,
-    EXT_CFG_SET_PREVIEW_SIZE,
-    EXT_CFG_SET_PICTURE_SIZE,
-    EXT_CFG_SET_JPEG_QUALITY,
-    EXT_CFG_SET_ANTISHAKE,
-    EXT_CFG_SET_WDR,
-    EXT_CFG_SET_EXIF,
-    EXT_CFG_SET_DTP,
-    EXT_CFG_SET_AE_AWB,
-    EXT_CFG_SET_FRONT_CAMERA_MODE,
-    EXT_CFG_SET_BEAUTY,
-    EXT_CFG_SET_VINTAGEMODE,
-    EXT_CFG_SET_BATCH_REFLECTION,
-    EXT_CFG_GET_JPEG_SIZE,
-    EXT_CFG_UPDATE_FIRMWARE,
-    EXT_CFG_DUMP_FIRMWARE,
-    EXT_CFG_SET_GPS_LATITUDE,
-    EXT_CFG_SET_GPS_LONGITUDE,
-    EXT_CFG_SET_GPS_ALTITUDE,
-    EXT_CFG_SET_GPS_TIMESTAMP,
-    EXT_CFG_SET_EXIF_TIME_INFO,
-    EXT_CFG_SET_GPS_PROCESSINGMETHOD,
-    EXT_CFG_SET_EXIF_ORIENTATION_INFO,
-    EXT_CFG_SET_BLUR,
-    EXT_CFG_SET_THUMB_NULL,
-    EXT_CFG_SET_CAM_MODE,
-    EXT_CFG_GET_EXIF_INFO,
-    EXT_CFG_GET_FLASH_INFO,
-    EXT_CFG_GET_VGACAM_ROTATED, // kurtlee
-    EXT_CFG_TEST_ESD,
-    EXT_CFG_GET_INFO,
-    EXT_CFG_FRAME_CONTROL,
-    EXT_CFG_AF_CONTROL,
-    EXT_CFG_EFFECT_CONTROL,
-    EXT_CFG_WB_CONTROL,
-    EXT_CFG_BR_CONTROL,
-    EXT_CFG_ISO_CONTROL,
-    EXT_CFG_METERING_CONTROL,
-    EXT_CFG_SCENE_CONTROL,
-    EXT_CFG_AE_AWB_CONTROL,
-    EXT_CFG_CR_CONTROL,
-    EXT_CFG_SA_CONTROL,
-    EXT_CFG_SP_CONTROL,
-    EXT_CFG_CPU_CONTROL,
-    EXT_CFG_DTP_CONTROL,
-    EXT_CFG_PRETTY_CONTROL,
-    EXT_CFG_VT_MODE_CONTROL,
-    EXT_CFG_GET_MODULE_STATUS,
-	EXT_CFG_SET_FLIP,
-
-    EXT_CFG_MAX,
-};
-
-enum ext_cfg_command_cammode
-{
-	EXT_CFG_CAM_MODE_CAMERA,
-	EXT_CFG_CAM_MODE_CAMCORDER,
-	EXT_CFG_CAM_MODE_FACTORY_TEST,
-};
-
-enum ext_cfg_command_jpeq_quality
-{
-	EXT_CFG_JPEG_QUALITY_SUPERFINE,
-	EXT_CFG_JPEG_QUALITY_FINE,
-	EXT_CFG_JPEG_QUALITY_NORMAL,
-};
-
-enum ext_cfg_command_auto_contrast
-{
-	EXT_CFG_AUTO_CONTRAST_ON,
-	EXT_CFG_AUTO_CONTRAST_OFF,
-};
-
-enum ext_cfg_command_framerate {
-	EXT_CFG_FRAME_AUTO = 0,
-	EXT_CFG_FRAME_FIX_7 = 7,
-	EXT_CFG_FRAME_FIX_15 = 15,
-	EXT_CFG_FRAME_FIX_20 = 20,
-	EXT_CFG_FRAME_FIX_24 = 24,
-	EXT_CFG_FRAME_FIX_25 = 25,
-	EXT_CFG_FRAME_FIX_30 = 30,
-};
-
-enum ext_cfg_command_effect
-{
-	EXT_CFG_EFFECT_NORMAL,
-	EXT_CFG_EFFECT_NEGATIVE,
-	EXT_CFG_EFFECT_MONO,
-	EXT_CFG_EFFECT_SEPIA,
-};
-
-enum ext_cfg_command_whitebalance
-{
-	EXT_CFG_WB_AUTO,
-	EXT_CFG_WB_DAYLIGHT,
-	EXT_CFG_WB_CLOUDY,
-	EXT_CFG_WB_FLUORESCENT,
-	EXT_CFG_WB_INCANDESCENT,
-};
-
-enum ext_cfg_command_brightness
-{
-	EXT_CFG_BR_STEP_M_4,
-	EXT_CFG_BR_STEP_M_3,
-	EXT_CFG_BR_STEP_M_2,
-	EXT_CFG_BR_STEP_M_1,
-	EXT_CFG_BR_STEP_0,
-	EXT_CFG_BR_STEP_P_1,
-	EXT_CFG_BR_STEP_P_2,
-	EXT_CFG_BR_STEP_P_3,
-	EXT_CFG_BR_STEP_P_4,
-};
-
-enum ext_cfg_command_contrast
-{
-	EXT_CFG_CR_STEP_M_2,
-	EXT_CFG_CR_STEP_M_1,
-	EXT_CFG_CR_STEP_0,
-	EXT_CFG_CR_STEP_P_1,
-	EXT_CFG_CR_STEP_P_2,
-};
-
-enum ext_cfg_command_saturation
-{
-	EXT_CFG_SA_STEP_M_2,
-	EXT_CFG_SA_STEP_M_1,
-	EXT_CFG_SA_STEP_0,
-	EXT_CFG_SA_STEP_P_1,
-	EXT_CFG_SA_STEP_P_2,
-};
-
-enum ext_cfg_command_sharpness
-{
-	EXT_CFG_SP_STEP_M_2,
-	EXT_CFG_SP_STEP_M_1,
-	EXT_CFG_SP_STEP_0,
-	EXT_CFG_SP_STEP_P_1,
-	EXT_CFG_SP_STEP_P_2,
-};
-
-enum ext_cfg_command_iso
-{
-	EXT_CFG_ISO_AUTO,
-	EXT_CFG_ISO_50,
-	EXT_CFG_ISO_100,
-	EXT_CFG_ISO_200,
-	EXT_CFG_ISO_400,
-};
-
-enum ext_cfg_command_metering
-{
-	EXT_CFG_METERING_NORMAL, //matrix
-	EXT_CFG_METERING_SPOT,
-	EXT_CFG_METERING_CENTER,
-};
-
-enum ext_cfg_command_scene
-{
-	EXT_CFG_SCENE_OFF,
-	EXT_CFG_SCENE_PORTRAIT,
-	EXT_CFG_SCENE_LANDSCAPE,
-	EXT_CFG_SCENE_SPORTS,
-	EXT_CFG_SCENE_PARTY,
-	EXT_CFG_SCENE_BEACH,
-	EXT_CFG_SCENE_SUNSET,
-	EXT_CFG_SCENE_DAWN,
-	EXT_CFG_SCENE_FALL,
-	EXT_CFG_SCENE_NIGHTSHOT,
-	EXT_CFG_SCENE_BACKLIGHT,
-	EXT_CFG_SCENE_FIREWORK,
-	EXT_CFG_SCENE_TEXT,
-	EXT_CFG_SCENE_CANDLE,
-};
-
-enum ext_cfg_command_af_operation
-{
-	EXT_CFG_AF_CHECK_STATUS,
-	EXT_CFG_AF_OFF,
-	EXT_CFG_AF_SET_NORMAL,
-	EXT_CFG_AF_SET_MACRO,
-	EXT_CFG_AF_DO,
-	EXT_CFG_AF_SET_MANUAL,
-	EXT_CFG_AF_ABORT,
-	EXT_CFG_AF_CHECK_2nd_STATUS,
-	EXT_CFG_AF_SET_AE_FOR_FLASH,
-	EXT_CFG_AF_BACK_AE_FOR_FLASH,
-	EXT_CFG_AF_CHECK_AE_STATUS,
-	EXT_CFG_AF_POWEROFF,
-};
-
-enum ext_cfg_command_af_status
-{
-	EXT_CFG_AF_PROGRESS = 1,
-	EXT_CFG_AF_SUCCESS,
-	EXT_CFG_AF_LOWCONF,//Fail
-	EXT_CFG_AF_CANCELED,
-	EXT_CFG_AF_TIMEOUT,
-	EXT_CFG_AE_STABLE,
-	EXT_CFG_AE_UNSTABLE,
-};
-
-enum ext_cfg_command_af_2nd_status
-{
-    EXT_CFG_AF_2ND_DONE=0,
-    EXT_CFG_AF_2ND_PROGRESS=256,
-};
-
-enum ext_cfg_command_ae_awb
-{
-	EXT_CFG_AE_LOCK,
-	EXT_CFG_AE_UNLOCK,
-	EXT_CFG_AWB_LOCK,
-	EXT_CFG_AWB_UNLOCK,
-	EXT_CFG_AE_AWB_LOCK,
-	EXT_CFG_AE_AWB_UNLOCK,
-};
-
-enum ext_cfg_command_cpu_policy
-{
-	EXT_CFG_CPU_CONSERVATIVE,
-	EXT_CFG_CPU_ONDEMAND,
-	EXT_CFG_CPU_PERFORMANCE,
-};
-
-enum ext_cfg_command_dtp
-{
-	EXT_CFG_DTP_OFF,
-	EXT_CFG_DTP_ON,
-};
-
-enum ext_cfg_command_zoom
-{
-	EXT_CFG_ZOOM_STEP_0,
-	EXT_CFG_ZOOM_STEP_1,
-	EXT_CFG_ZOOM_STEP_2,
-	EXT_CFG_ZOOM_STEP_3,
-	EXT_CFG_ZOOM_STEP_4,
-	EXT_CFG_ZOOM_STEP_5,
-	EXT_CFG_ZOOM_STEP_6,
-	EXT_CFG_ZOOM_STEP_7,
-	EXT_CFG_ZOOM_STEP_8,
-};
-
-enum ext_cfg_command_picture_size
-{
-	EXT_CFG_SNAPSHOT_SIZE_2560x1920_5M,
-	EXT_CFG_SNAPSHOT_SIZE_2560x1536_4M_WIDE,
-	EXT_CFG_SNAPSHOT_SIZE_2048x1536_3M,
-	EXT_CFG_SNAPSHOT_SIZE_2048x1232_2_4M_WIDE,
-	EXT_CFG_SNAPSHOT_SIZE_1600x1200_2M,
-	EXT_CFG_SNAPSHOT_SIZE_1600x960_1_5M_WIDE,
-	EXT_CFG_SNAPSHOT_SIZE_1280x960_1M,
-	EXT_CFG_SNAPSHOT_SIZE_800x480_4K_WIDE,
-	EXT_CFG_SNAPSHOT_SIZE_640x480_VGA,
-	EXT_CFG_SNAPSHOT_SIZE_320x240_QVGA,
-};
-
-enum ext_cfg_command_preview_size
-{
-    EXT_CFG_PREVIEW_SIZE_1280x720_D1,
-	EXT_CFG_PREVIEW_SIZE_800x480_WVGA,
-	EXT_CFG_PREVIEW_SIZE_720x480_D1,
-	EXT_CFG_PREVIEW_SIZE_640x480_VGA,
-	EXT_CFG_PREVIEW_SIZE_320x240_QVGA,
-	EXT_CFG_PREVIEW_SIZE_176x144_QCIF,
-};
-
-enum ext_cfg_command_flash
-{
-	EXT_CFG_FLASH_ON,
-	EXT_CFG_FLASH_OFF,
-	EXT_CFG_FLASH_AUTO,
-	EXT_CFG_FLASH_TURN_ON,
-	EXT_CFG_FLASH_TURN_OFF,
-	EXT_CFG_FLASH_TORCH,
-};
-
-enum ext_cfg_command_pretty
-{
-	EXT_CFG_PRETTY_LEVEL_0,
-	EXT_CFG_PRETTY_LEVEL_1,
-	EXT_CFG_PRETTY_LEVEL_2,
-	EXT_CFG_PRETTY_LEVEL_3,
-};
-
-enum ext_cfg_command_mode
-{
-	EXT_CFG_CAMERA_MODE,
-	EXT_CFG_CAMCORDER_MODE,
-};
-
-#endif /* CONFIG_OEM_CAMERA */
 
 #define V4L2_SINGLE_PLANE	0
 #define V4L2_MULTI_PLANE_Y	0
diff -ru final2/include/net/bluetooth/amp.h ics/include/net/bluetooth/amp.h
--- final2/include/net/bluetooth/amp.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/net/bluetooth/amp.h	2013-04-19 11:37:14.000000000 +0200
@@ -115,7 +115,7 @@
 void amp_exit(void);
 
 /* L2CAP-AMP fixed channel interface */
-void amp_conn_ind(struct l2cap_conn *conn, struct sk_buff *skb);
+void amp_conn_ind(struct hci_conn *hcon, struct sk_buff *skb);
 
 /* L2CAP-AMP link interface */
 void amp_create_physical(struct l2cap_conn *conn, struct sock *sk);
@@ -256,7 +256,7 @@
 };
 struct amp_work_conn_ind {
 	struct work_struct work;
-	struct l2cap_conn *conn;
+	struct hci_conn *hcon;
 	struct sk_buff *skb;
 };
 struct amp_work_create_physical {
diff -ru final2/include/net/bluetooth/bluetooth.h ics/include/net/bluetooth/bluetooth.h
--- final2/include/net/bluetooth/bluetooth.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/net/bluetooth/bluetooth.h	2013-04-19 11:37:14.000000000 +0200
@@ -21,9 +21,7 @@
    COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
    SOFTWARE IS DISCLAIMED.
 */
-#ifdef CONFIG_BT_MGMT
-#include "bluetooth_mgmt.h"
-#else
+
 #ifndef __BLUETOOTH_H
 #define __BLUETOOTH_H
 
@@ -40,6 +38,7 @@
 
 /* Reserv for core and drivers use */
 #define BT_SKB_RESERVE	8
+#define BT_SKB_RESERVE_80211	32
 
 #define BTPROTO_L2CAP	0
 #define BTPROTO_HCI	1
@@ -66,25 +65,65 @@
 #define BT_SECURITY_HIGH	3
 
 #define BT_DEFER_SETUP	7
-
 #define BT_FLUSHABLE	8
 
-#define BT_FLUSHABLE_OFF	0
-#define BT_FLUSHABLE_ON		1
-
 #define BT_POWER	9
 struct bt_power {
 	__u8 force_active;
 };
-#define BT_POWER_FORCE_ACTIVE_OFF 0
-#define BT_POWER_FORCE_ACTIVE_ON  1
 
-__attribute__((format (printf, 2, 3)))
-int bt_printk(const char *level, const char *fmt, ...);
+#define BT_AMP_POLICY          10
 
-#define BT_INFO(fmt, arg...)   bt_printk(KERN_INFO, pr_fmt(fmt), ##arg)
-#define BT_ERR(fmt, arg...)    bt_printk(KERN_ERR, pr_fmt(fmt), ##arg)
-#define BT_DBG(fmt, arg...)    pr_debug(fmt "\n", ##arg)
+/* Require BR/EDR (default policy)
+ *   AMP controllers cannot be used
+ *   Channel move requests from the remote device are denied
+ *   If the L2CAP channel is currently using AMP, move the channel to BR/EDR
+ */
+#define BT_AMP_POLICY_REQUIRE_BR_EDR   0
+
+/* Prefer BR/EDR
+ *   Allow use of AMP controllers
+ *   If the L2CAP channel is currently on AMP, move it to BR/EDR
+ *   Channel move requests from the remote device are allowed
+ */
+#define BT_AMP_POLICY_PREFER_BR_EDR    1
+
+/* Prefer AMP
+ *   Allow use of AMP controllers
+ *   If the L2CAP channel is currently on BR/EDR and AMP controller
+ *     resources are available, initiate a channel move to AMP
+ *   Channel move requests from the remote device are allowed
+ *   If the L2CAP socket has not been connected yet, try to create
+ *     and configure the channel directly on an AMP controller rather
+ *     than BR/EDR
+ */
+#define BT_AMP_POLICY_PREFER_AMP       2
+
+#define BT_LE_PARAMS	100
+
+#define BT_LE_SCAN_WINDOW_MIN		0x0004
+#define BT_LE_SCAN_WINDOW_MAX		0x4000
+#define BT_LE_SCAN_WINDOW_DEF		0x0004
+
+#define BT_LE_SCAN_INTERVAL_MIN		0x0004
+#define BT_LE_SCAN_INTERVAL_MAX		0x4000
+#define BT_LE_SCAN_INTERVAL_DEF		0x0008
+
+#define BT_LE_CONN_INTERVAL_MIN		0x0006
+#define BT_LE_CONN_INTERVAL_MAX		0x0C80
+#define BT_LE_CONN_INTERVAL_MIN_DEF	0x0008
+#define BT_LE_CONN_INTERVAL_MAX_DEF	0x0100
+
+#define BT_LE_LATENCY_MAX		0x01F4
+#define BT_LE_LATENCY_DEF		0x0000
+
+#define BT_LE_SUP_TO_MIN		0x000A
+#define BT_LE_SUP_TO_MAX		0x0C80
+#define BT_LE_SUP_TO_DEFAULT		0X03E8
+
+#define BT_INFO(fmt, arg...) printk(KERN_INFO "Bluetooth: " fmt "\n" , ## arg)
+#define BT_ERR(fmt, arg...)  printk(KERN_ERR "%s: " fmt "\n" , __func__ , ## arg)
+#define BT_DBG(fmt, arg...)  pr_debug("%s: " fmt "\n" , __func__ , ## arg)
 
 /* Connection and socket states */
 enum {
@@ -125,6 +164,20 @@
 
 #define bt_sk(__sk) ((struct bt_sock *) __sk)
 
+struct bt_le_params {
+	__u8  prohibit_remote_chg;
+	__u8  filter_policy;
+	__u16 scan_interval;
+	__u16 scan_window;
+	__u16 interval_min;
+	__u16 interval_max;
+	__u16 latency;
+	__u16 supervision_timeout;
+	__u16 min_ce_len;
+	__u16 max_ce_len;
+	__u16 conn_timeout;
+};
+
 struct bt_sock {
 	struct sock sk;
 	bdaddr_t    src;
@@ -132,6 +185,7 @@
 	struct list_head accept_q;
 	struct sock *parent;
 	u32 defer_setup;
+	struct bt_le_params le_params;
 };
 
 struct bt_sock_list {
@@ -156,23 +210,33 @@
 struct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock);
 
 /* Skb helpers */
+struct bt_l2cap_control {
+	__u8  frame_type;
+	__u8  final;
+	__u8  sar;
+	__u8  super;
+	__u16 reqseq;
+	__u16 txseq;
+	__u8  poll;
+	__u8  fcs;
+};
+
 struct bt_skb_cb {
 	__u8 pkt_type;
 	__u8 incoming;
 	__u16 expect;
-	__u8 tx_seq;
 	__u8 retries;
-	__u8 sar;
-	unsigned short channel;
 	__u8 force_active;
+	unsigned short channel;
+	struct bt_l2cap_control control;
 };
 #define bt_cb(skb) ((struct bt_skb_cb *)((skb)->cb))
 
 static inline struct sk_buff *bt_skb_alloc(unsigned int len, gfp_t how)
 {
 	struct sk_buff *skb;
-	skb = alloc_skb(len + BT_SKB_RESERVE, how);
 
+	skb = alloc_skb(len + BT_SKB_RESERVE, how);
 	if (skb) {
 		skb_reserve(skb, BT_SKB_RESERVE);
 		bt_cb(skb)->incoming  = 0;
@@ -187,7 +251,6 @@
 
 	release_sock(sk);
 	skb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err);
-
 	if (skb) {
 		skb_reserve(skb, BT_SKB_RESERVE);
 		bt_cb(skb)->incoming  = 0;
@@ -213,7 +276,7 @@
 	return NULL;
 }
 
-int bt_to_errno(__u16 code);
+int bt_err(__u16 code);
 
 extern int hci_sock_init(void);
 extern void hci_sock_cleanup(void);
@@ -252,5 +315,3 @@
 #endif
 
 #endif /* __BLUETOOTH_H */
-
-#endif /*BT_MGMT*/
Nur in final2/include/net/bluetooth: bluetooth_mgmt.h.
diff -ru final2/include/net/bluetooth/hci_core.h ics/include/net/bluetooth/hci_core.h
--- final2/include/net/bluetooth/hci_core.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/net/bluetooth/hci_core.h	2013-04-19 11:37:14.000000000 +0200
@@ -21,9 +21,7 @@
    COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
    SOFTWARE IS DISCLAIMED.
 */
-#ifdef CONFIG_BT_MGMT
-#include "hci_core_mgmt.h"
-#else
+
 #ifndef __HCI_CORE_H
 #define __HCI_CORE_H
 
@@ -65,6 +63,11 @@
 	unsigned int     le_num;
 };
 
+struct hci_chan_list {
+	struct list_head list;
+	spinlock_t       lock;
+};
+
 struct bdaddr_list {
 	struct list_head list;
 	bdaddr_t bdaddr;
@@ -81,11 +84,18 @@
 	u8 rand[8];
 } __packed;
 
+#define KEY_TYPE_LE_BASE	0x11
+#define KEY_TYPE_LTK		0x11
+#define KEY_TYPE_IRK		0x12
+#define KEY_TYPE_CSRK		0x13
+
 struct link_key_data {
 	bdaddr_t bdaddr;
-	u8 type;
+	u8 addr_type;
+	u8 key_type;
 	u8 val[16];
 	u8 pin_len;
+	u8 auth;
 	u8 dlen;
 	u8 data[0];
 } __packed;
@@ -93,9 +103,11 @@
 struct link_key {
 	struct list_head list;
 	bdaddr_t bdaddr;
-	u8 type;
+	u8 addr_type;
+	u8 key_type;
 	u8 val[16];
 	u8 pin_len;
+	u8 auth;
 	u8 dlen;
 	u8 data[0];
 };
@@ -111,6 +123,7 @@
 	struct list_head list;
 	bdaddr_t bdaddr;
 	u8 bdaddr_type;
+	u8 flags;
 };
 
 #define NUM_REASSEMBLY 4
@@ -131,7 +144,6 @@
 	__u8		major_class;
 	__u8		minor_class;
 	__u8		features[8];
-	__u8		extfeatures[8];
 	__u8		commands[64];
 	__u8		ssp_mode;
 	__u8		hci_ver;
@@ -151,7 +163,18 @@
 	__u16		sniff_min_interval;
 	__u16		sniff_max_interval;
 
-	unsigned int	auto_accept_delay;
+	__u8		amp_status;
+	__u32		amp_total_bw;
+	__u32		amp_max_bw;
+	__u32		amp_min_latency;
+	__u32		amp_max_pdu;
+	__u8		amp_type;
+	__u16		amp_pal_cap;
+	__u16		amp_assoc_size;
+	__u32		amp_max_flush_to;
+	__u32		amp_be_flush_to;
+
+	__s8		is_wbs;
 
 	unsigned long	quirks;
 
@@ -160,6 +183,8 @@
 	unsigned int	sco_cnt;
 	unsigned int	le_cnt;
 
+	__u8	flow_ctl_mode;
+
 	unsigned int	acl_mtu;
 	unsigned int	sco_mtu;
 	unsigned int	le_mtu;
@@ -168,6 +193,8 @@
 	unsigned int	le_pkts;
 	unsigned int	le_white_list_size;
 
+	unsigned int	data_block_len;
+
 	unsigned long	acl_last_tx;
 	unsigned long	sco_last_tx;
 	unsigned long	le_last_tx;
@@ -201,6 +228,7 @@
 
 	struct inquiry_cache	inq_cache;
 	struct hci_conn_hash	conn_hash;
+	struct hci_chan_list	chan_list;
 	struct list_head	blacklist;
 
 	struct list_head	uuids;
@@ -210,8 +238,15 @@
 	struct list_head	remote_oob_data;
 
 	struct list_head	adv_entries;
+	rwlock_t		adv_entries_lock;
 	struct timer_list	adv_timer;
 
+	struct timer_list	disco_timer;
+	struct timer_list	disco_le_timer;
+	__u8			disco_state;
+	int			disco_int_phase;
+	int			disco_int_count;
+
 	struct hci_dev_stats	stat;
 
 	struct sk_buff_head	driver_init;
@@ -237,19 +272,17 @@
 	void (*destruct)(struct hci_dev *hdev);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 	int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
-/* Samsung Bluetooth Feature.2012.01.19
- * Add wake_peer uart operation which is called before starting UART TX
- */
-	void (*wake_peer)(struct hci_dev *);
 };
 
 struct hci_conn {
 	struct list_head list;
 
 	atomic_t	refcnt;
+	spinlock_t	lock;
 
 	bdaddr_t	dst;
-	__u8		dst_type;
+	__u8		 dst_id;
+	__u8            dst_type;
 	__u16		handle;
 	__u16		state;
 	__u8		mode;
@@ -263,28 +296,34 @@
 	__u16		pkt_type;
 	__u16		link_policy;
 	__u32		link_mode;
-	__u8		key_type;
 	__u8		auth_type;
 	__u8		sec_level;
 	__u8		pending_sec_level;
 	__u8		pin_length;
 	__u8		enc_key_size;
 	__u8		io_capability;
+	__u8		auth_initiator;
 	__u8		power_save;
 	__u16		disc_timeout;
+	__u16		conn_timeout;
 	unsigned long	pend;
 
 	__u8		remote_cap;
 	__u8		remote_oob;
 	__u8		remote_auth;
 
+	__s8	rssi_threshold;
+	__u16	rssi_update_interval;
+	__u8	rssi_update_thresh_exceed;
+
 	unsigned int	sent;
 
 	struct sk_buff_head data_q;
 
 	struct timer_list disc_timer;
 	struct timer_list idle_timer;
-	struct timer_list auto_accept_timer;
+	struct delayed_work	rssi_update_work;
+	struct timer_list encrypt_pause_timer;
 
 	struct work_struct work_add;
 	struct work_struct work_del;
@@ -295,14 +334,46 @@
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
 	void		*sco_data;
+	void		*priv;
+
+	__u8             link_key[16];
+	__u8             key_type;
 
 	struct hci_conn	*link;
 
+	/* Low Energy SMP pairing data */
+	__u8		oob; /* OOB pairing supported */
+	__u8		tk_valid; /* TK value is valid */
+	__u8		cfm_pending; /* CONFIRM cmd may be sent */
+	__u8		preq[7]; /* Pairing Request */
+	__u8		prsp[7]; /* Pairing Response */
+	__u8		prnd[16]; /* Pairing Random */
+	__u8		pcnf[16]; /* Pairing Confirm */
+	__u8		tk[16]; /* Temporary Key */
+	__u8		smp_key_size;
+	__u8		sec_req;
+	__u8		auth;
+	void		*smp_conn;
+	struct timer_list smp_timer;
+
+
 	void (*connect_cfm_cb)	(struct hci_conn *conn, u8 status);
 	void (*security_cfm_cb)	(struct hci_conn *conn, u8 status);
 	void (*disconn_cfm_cb)	(struct hci_conn *conn, u8 reason);
 };
 
+struct hci_chan {
+	struct list_head list;
+	struct hci_dev	*hdev;
+	__u16		state;
+	atomic_t	refcnt;
+	__u16		ll_handle;
+	struct hci_ext_fs	tx_fs;
+	struct hci_ext_fs	rx_fs;
+	struct hci_conn	*conn;
+	void		*l2cap_sk;
+};
+
 extern struct hci_proto *hci_proto[];
 extern struct list_head hci_dev_list;
 extern struct list_head hci_cb_list;
@@ -342,14 +413,12 @@
 	return jiffies - e->timestamp;
 }
 
-struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
-							bdaddr_t *bdaddr);
+struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
 
 /* ----- HCI Connections ----- */
 enum {
 	HCI_CONN_AUTH_PEND,
-	HCI_CONN_REAUTH_PEND,
 	HCI_CONN_ENCRYPT_PEND,
 	HCI_CONN_RSWITCH_PEND,
 	HCI_CONN_MODE_CHANGE_PEND,
@@ -416,6 +485,13 @@
 	return NULL;
 }
 
+static inline void hci_chan_list_init(struct hci_dev *hdev)
+{
+	struct hci_chan_list *h = &hdev->chan_list;
+	INIT_LIST_HEAD(&h->list);
+	spin_lock_init(&h->lock);
+}
+
 static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
 							__u8 type, bdaddr_t *ba)
 {
@@ -431,6 +507,21 @@
 	return NULL;
 }
 
+static inline struct hci_conn *hci_conn_hash_lookup_id(struct hci_dev *hdev,
+					bdaddr_t *ba, __u8 id)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn  *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (!bacmp(&c->dst, ba) && (c->dst_id == id))
+			return c;
+	}
+	return NULL;
+}
+
 static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 							__u8 type, __u16 state)
 {
@@ -446,6 +537,36 @@
 	return NULL;
 }
 
+static inline struct hci_chan *hci_chan_list_lookup_handle(struct hci_dev *hdev,
+					__u16 handle)
+{
+	struct hci_chan_list *l = &hdev->chan_list;
+	struct list_head *p;
+	struct hci_chan  *c;
+
+	list_for_each(p, &l->list) {
+		c = list_entry(p, struct hci_chan, list);
+		if (c->ll_handle == handle)
+			return c;
+	}
+	return NULL;
+}
+
+static inline struct hci_chan *hci_chan_list_lookup_id(struct hci_dev *hdev,
+					__u8 handle)
+{
+	struct hci_chan_list *l = &hdev->chan_list;
+	struct list_head *p;
+	struct hci_chan  *c;
+
+	list_for_each(p, &l->list) {
+		c = list_entry(p, struct hci_chan, list);
+		if (c->conn->handle == handle)
+			return c;
+	}
+	return NULL;
+}
+
 void hci_acl_connect(struct hci_conn *conn);
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
 void hci_add_sco(struct hci_conn *conn, __u16 handle);
@@ -454,10 +575,27 @@
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
 					__u16 pkt_type, bdaddr_t *dst);
+struct hci_conn *hci_le_conn_add(struct hci_dev *hdev, bdaddr_t *dst,
+							__u8 addr_type);
 int hci_conn_del(struct hci_conn *conn);
-void hci_conn_hash_flush(struct hci_dev *hdev);
+void hci_conn_hash_flush(struct hci_dev *hdev, u8 is_process);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
+struct hci_chan *hci_chan_add(struct hci_dev *hdev);
+int hci_chan_del(struct hci_chan *chan);
+static inline void hci_chan_hold(struct hci_chan *chan)
+{
+	atomic_inc(&chan->refcnt);
+}
+int hci_chan_put(struct hci_chan *chan);
+
+struct hci_chan *hci_chan_create(struct hci_chan *chan,
+				struct hci_ext_fs *tx_fs,
+				struct hci_ext_fs *rx_fs);
+void hci_chan_modify(struct hci_chan *chan,
+				struct hci_ext_fs *tx_fs,
+				struct hci_ext_fs *rx_fs);
+
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
 					__u16 pkt_type, bdaddr_t *dst,
 					__u8 sec_level, __u8 auth_type);
@@ -469,16 +607,11 @@
 void hci_le_remove_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst);
 void hci_le_cancel_create_connect(struct hci_dev *hdev, bdaddr_t *dst);
 int hci_conn_check_link_mode(struct hci_conn *conn);
-int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
-
-/* BEGIN SS_BLUEZ_BT +kjh 2011.06.23 : */
-/* workaround for a2dp chopping in multi connection. */
-int hci_conn_change_policy(struct hci_conn *conn, __u8 policy);
-int hci_conn_set_encrypt(struct hci_conn *conn, __u8 enable);
-/* END SS_BLUEZ_BT */
+void hci_disconnect(struct hci_conn *conn, __u8 reason);
+void hci_disconnect_amp(struct hci_conn *conn, __u8 reason);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
 void hci_conn_enter_sniff_mode(struct hci_conn *conn);
@@ -486,6 +619,10 @@
 void hci_conn_hold_device(struct hci_conn *conn);
 void hci_conn_put_device(struct hci_conn *conn);
 
+void hci_conn_set_rssi_reporter(struct hci_conn *conn,
+		s8 rssi_threshold, u16 interval, u8 updateOnThreshExceed);
+void hci_conn_unset_rssi_reporter(struct hci_conn *conn);
+
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	atomic_inc(&conn->refcnt);
@@ -496,18 +633,16 @@
 {
 	if (atomic_dec_and_test(&conn->refcnt)) {
 		unsigned long timeo;
-		if (conn->type == ACL_LINK) {
+		if (conn->type == ACL_LINK || conn->type == LE_LINK) {
 			del_timer(&conn->idle_timer);
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
-					timeo *= 20;
-			} else {
+					timeo *= 4;
+			} else
 				timeo = msecs_to_jiffies(10);
-			}
-		} else {
+		} else
 			timeo = msecs_to_jiffies(10);
-		}
 		mod_timer(&conn->disc_timer, jiffies + timeo);
 	}
 }
@@ -545,6 +680,7 @@
 
 struct hci_dev *hci_dev_get(int index);
 struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
+struct hci_dev *hci_dev_get_type(__u8 amp_type);
 
 struct hci_dev *hci_alloc_dev(void);
 void hci_free_dev(struct hci_dev *hdev);
@@ -562,24 +698,23 @@
 int hci_get_conn_list(void __user *arg);
 int hci_get_conn_info(struct hci_dev *hdev, void __user *arg);
 int hci_get_auth_info(struct hci_dev *hdev, void __user *arg);
+int hci_set_auth_info(struct hci_dev *hdev, void __user *arg);
 int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_blacklist_clear(struct hci_dev *hdev);
-int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_uuids_clear(struct hci_dev *hdev);
 
 int hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
-			bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
+int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
+						u8 *key, u8 type, u8 pin_len);
 struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
 struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
 					bdaddr_t *bdaddr, u8 type);
-int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-			u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
+int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr, u8 type,
+		u8 auth, u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_remote_oob_data_clear(struct hci_dev *hdev);
@@ -621,9 +756,6 @@
 #define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
 #define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
 
-/* ----- Extended LMP capabilities ----- */
-#define lmp_host_le_capable(dev)   ((dev)->extfeatures[0] & LMP_HOST_LE)
-
 /* ----- HCI protocols ----- */
 struct hci_proto {
 	char		*name;
@@ -632,20 +764,20 @@
 
 	void		*priv;
 
-	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								__u8 type);
+	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
 	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
 	int (*disconn_ind)	(struct hci_conn *conn);
-	int (*disconn_cfm)	(struct hci_conn *conn, __u8 reason);
-	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb,
-								__u16 flags);
+	int (*disconn_cfm)	(struct hci_conn *conn, __u8 reason,
+							__u8 is_process);
+	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
 	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
-	int (*security_cfm)	(struct hci_conn *conn, __u8 status,
-								__u8 encrypt);
+	int (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	int (*create_cfm)	(struct hci_chan *chan, __u8 status);
+	int (*modify_cfm)	(struct hci_chan *chan, __u8 status);
+	int (*destroy_cfm)	(struct hci_chan *chan, __u8 status);
 };
 
-static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								__u8 type)
+static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
 {
 	register struct hci_proto *hp;
 	int mask = 0;
@@ -693,17 +825,18 @@
 	return reason;
 }
 
-static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
+static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason,
+							__u8 is_process)
 {
 	register struct hci_proto *hp;
 
 	hp = hci_proto[HCI_PROTO_L2CAP];
 	if (hp && hp->disconn_cfm)
-		hp->disconn_cfm(conn, reason);
+		hp->disconn_cfm(conn, reason, is_process);
 
 	hp = hci_proto[HCI_PROTO_SCO];
 	if (hp && hp->disconn_cfm)
-		hp->disconn_cfm(conn, reason);
+		hp->disconn_cfm(conn, reason, is_process);
 
 	if (conn->disconn_cfm_cb)
 		conn->disconn_cfm_cb(conn, reason);
@@ -731,8 +864,7 @@
 		conn->security_cfm_cb(conn, status);
 }
 
-static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status,
-								__u8 encrypt)
+static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
 {
 	register struct hci_proto *hp;
 
@@ -748,6 +880,33 @@
 		conn->security_cfm_cb(conn, status);
 }
 
+static inline void hci_proto_create_cfm(struct hci_chan *chan, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->create_cfm)
+		hp->create_cfm(chan, status);
+}
+
+static inline void hci_proto_modify_cfm(struct hci_chan *chan, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->modify_cfm)
+		hp->modify_cfm(chan, status);
+}
+
+static inline void hci_proto_destroy_cfm(struct hci_chan *chan, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->destroy_cfm)
+		hp->destroy_cfm(chan, status);
+}
+
 int hci_register_proto(struct hci_proto *hproto);
 int hci_unregister_proto(struct hci_proto *hproto);
 
@@ -757,8 +916,7 @@
 
 	char *name;
 
-	void (*security_cfm)	(struct hci_conn *conn, __u8 status,
-								__u8 encrypt);
+	void (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
 	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*role_switch_cfm)	(struct hci_conn *conn, __u8 status, __u8 role);
 };
@@ -784,15 +942,14 @@
 	read_unlock_bh(&hci_cb_list_lock);
 }
 
-static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
-								__u8 encrypt)
+static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
 {
 	struct list_head *p;
 
 	if (conn->sec_level == BT_SECURITY_SDP)
 		conn->sec_level = BT_SECURITY_LOW;
 
-	if (conn->pending_sec_level > conn->sec_level)
+	if (!status && encrypt && conn->pending_sec_level > conn->sec_level)
 		conn->sec_level = conn->pending_sec_level;
 
 	hci_proto_encrypt_cfm(conn, status, encrypt);
@@ -819,8 +976,7 @@
 	read_unlock_bh(&hci_cb_list_lock);
 }
 
-static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
-								__u8 role)
+static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status, __u8 role)
 {
 	struct list_head *p;
 
@@ -839,8 +995,29 @@
 int hci_register_notifier(struct notifier_block *nb);
 int hci_unregister_notifier(struct notifier_block *nb);
 
+/* AMP Manager event callbacks */
+struct amp_mgr_cb {
+	struct list_head list;
+	void (*amp_cmd_complete_event) (struct hci_dev *hdev, __u16 opcode,
+					struct sk_buff *skb);
+	void (*amp_cmd_status_event) (struct hci_dev *hdev, __u16 opcode,
+					__u8 status);
+	void (*amp_event) (struct hci_dev *hdev, __u8 ev_code,
+					struct sk_buff *skb);
+};
+
+void hci_amp_cmd_complete(struct hci_dev *hdev, __u16 opcode,
+			struct sk_buff *skb);
+void hci_amp_cmd_status(struct hci_dev *hdev, __u16 opcode, __u8 status);
+void hci_amp_event_packet(struct hci_dev *hdev, __u8 ev_code,
+			struct sk_buff *skb);
+
+int hci_register_amp(struct amp_mgr_cb *acb);
+int hci_unregister_amp(struct amp_mgr_cb *acb);
+
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
-void hci_send_acl(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
+void hci_send_acl(struct hci_conn *conn, struct hci_chan *chan,
+		struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
@@ -865,11 +1042,12 @@
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr, u8 reason);
 int mgmt_disconnect_failed(u16 index);
 int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr, u8 secure);
+int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr);
 int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_user_confirm_request(u16 index, bdaddr_t *bdaddr, __le32 value,
-							u8 confirm_hint);
+int mgmt_user_confirm_request(u16 index, u8 event, bdaddr_t *bdaddr,
+							__le32 value);
+int mgmt_user_oob_request(u16 index, bdaddr_t *bdaddr);
 int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
 								u8 status);
@@ -877,10 +1055,23 @@
 int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
 								u8 status);
-int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 *dev_class, s8 rssi,
-								u8 *eir);
-int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 *name);
-int mgmt_discovering(u16 index, u8 discovering);
+int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 le,
+				u8 *dev_class, s8 rssi, u8 eir_len, u8 *eir);
+void mgmt_read_rssi_complete(u16 index, s8 rssi, bdaddr_t *bdaddr,
+				u16 handle, u8 status);
+int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 status, u8 *name);
+void mgmt_inquiry_started(u16 index);
+void mgmt_inquiry_complete_evt(u16 index, u8 status);
+void mgmt_disco_timeout(unsigned long data);
+void mgmt_disco_le_timeout(unsigned long data);
+int mgmt_encrypt_change(u16 index, bdaddr_t *bdaddr, u8 status);
+
+/* LE SMP Management interface */
+int le_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, void *cp);
+int mgmt_remote_class(u16 index, bdaddr_t *bdaddr, u8 dev_class[3]);
+int mgmt_remote_version(u16 index, bdaddr_t *bdaddr, u8 ver, u16 mnf,
+							u16 sub_ver);
+int mgmt_remote_features(u16 index, bdaddr_t *bdaddr, u8 features[8]);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)
@@ -919,6 +1110,6 @@
 void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16]);
 void hci_le_ltk_neg_reply(struct hci_conn *conn);
 
-#endif /* __HCI_CORE_H */
+void hci_read_rssi(struct hci_conn *conn);
 
-#endif /* BT_MGMT */
+#endif /* __HCI_CORE_H */
Nur in final2/include/net/bluetooth: hci_core_mgmt.h.
diff -ru final2/include/net/bluetooth/hci.h ics/include/net/bluetooth/hci.h
--- final2/include/net/bluetooth/hci.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/net/bluetooth/hci.h	2013-04-19 11:37:14.000000000 +0200
@@ -21,13 +21,11 @@
    COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
    SOFTWARE IS DISCLAIMED.
 */
-#ifdef CONFIG_BT_MGMT
-#include "hci_mgmt.h"
-#else
+
 #ifndef __HCI_H
 #define __HCI_H
 
-#define HCI_MAX_ACL_SIZE	1024
+#define HCI_MAX_ACL_SIZE	1500
 #define HCI_MAX_SCO_SIZE	255
 #define HCI_MAX_EVENT_SIZE	260
 #define HCI_MAX_FRAME_SIZE	(HCI_MAX_ACL_SIZE + 4)
@@ -39,6 +37,7 @@
 #define HCI_DEV_DOWN			4
 #define HCI_DEV_SUSPEND			5
 #define HCI_DEV_RESUME			6
+#define HCI_DEV_WRITE			7
 
 /* HCI notify events */
 #define HCI_NOTIFY_CONN_ADD		1
@@ -102,6 +101,7 @@
 #define HCIGETCONNLIST	_IOR('H', 212, int)
 #define HCIGETCONNINFO	_IOR('H', 213, int)
 #define HCIGETAUTHINFO	_IOR('H', 215, int)
+#define HCISETAUTHINFO  _IOR('H', 216, int)
 
 #define HCISETRAW	_IOW('H', 220, int)
 #define HCISETSCAN	_IOW('H', 221, int)
@@ -124,7 +124,7 @@
 #define HCI_PAIRING_TIMEOUT	(60000)	/* 60 seconds */
 #define HCI_IDLE_TIMEOUT	(6000)	/* 6 seconds */
 #define HCI_INIT_TIMEOUT	(10000)	/* 10 seconds */
-#define HCI_CMD_TIMEOUT		(1000)	/* 1 seconds */
+#define HCI_CMD_TIMEOUT		(5000)	/* 5 seconds */
 
 /* HCI data types */
 #define HCI_COMMAND_PKT		0x01
@@ -160,26 +160,35 @@
 #define ESCO_2EV5	0x0100
 #define ESCO_3EV5	0x0200
 
+#define ESCO_WBS	(ESCO_EV3 | (EDR_ESCO_MASK ^ ESCO_2EV3))
+
 #define SCO_ESCO_MASK	(ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
 #define EDR_ESCO_MASK	(ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
-/* SS_BLUETOOTH(is80.hwang) 2012.03.02 */
-/* change applied EDR ESCO packet */
-#ifdef CONFIG_BT_CSR8811
-#define ALL_ESCO_MASK (SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
-	ESCO_2EV3 /*EDR_ESCO_MASK*/)
-#else
 #define ALL_ESCO_MASK	(SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
 			EDR_ESCO_MASK)
-#endif
-/* SS_BLUEZ_BT(is80.hwang) End */
+
+/* Air Coding Format */
+#define ACF_CVSD	0x0000;
+#define ACF_ULAW	0x0001;
+#define ACF_ALAW	0x0002;
+#define ACF_TRANS	0x0003;
+
+/* Retransmission Effort */
+#define RE_NO_RETRANS		0x00;
+#define RE_POWER_CONSUMP	0x01;
+#define RE_LINK_QUALITY		0x02;
+#define RE_DONT_CARE		0xFF;
 
 /* ACL flags */
 #define ACL_START_NO_FLUSH	0x00
 #define ACL_CONT		0x01
 #define ACL_START		0x02
+#define ACL_COMPLETE		0x03
 #define ACL_ACTIVE_BCAST	0x04
 #define ACL_PICO_BCAST		0x08
 
+#define ACL_PB_MASK	(ACL_CONT | ACL_START)
+
 /* Baseband links */
 #define SCO_LINK	0x00
 #define ACL_LINK	0x01
@@ -224,16 +233,11 @@
 #define LMP_EDR_3S_ESCO	0x80
 
 #define LMP_EXT_INQ	0x01
-#define LMP_SIMUL_LE_BR	0x02
 #define LMP_SIMPLE_PAIR	0x08
 #define LMP_NO_FLUSH	0x40
 
 #define LMP_LSTO	0x01
 #define LMP_INQ_TX_PWR	0x02
-#define LMP_EXTFEATURES	0x80
-
-/* Extended LMP features */
-#define LMP_HOST_LE	0x02
 
 /* Connection modes */
 #define HCI_CM_ACTIVE	0x0000
@@ -264,18 +268,9 @@
 #define HCI_AT_GENERAL_BONDING		0x04
 #define HCI_AT_GENERAL_BONDING_MITM	0x05
 
-/* Link Key types */
-#define HCI_LK_COMBINATION		0x00
-#define HCI_LK_LOCAL_UNIT		0x01
-#define HCI_LK_REMOTE_UNIT		0x02
-#define HCI_LK_DEBUG_COMBINATION	0x03
-#define HCI_LK_UNAUTH_COMBINATION	0x04
-#define HCI_LK_AUTH_COMBINATION		0x05
-#define HCI_LK_CHANGED_COMBINATION	0x06
-/* The spec doesn't define types for SMP keys */
-#define HCI_LK_SMP_LTK			0x81
-#define HCI_LK_SMP_IRK			0x82
-#define HCI_LK_SMP_CSRK			0x83
+/* Flow control modes */
+#define HCI_PACKET_BASED_FLOW_CTL_MODE	0x00
+#define HCI_BLOCK_BASED_FLOW_CTL_MODE	0x01
 
 /* -----  HCI Commands ---- */
 #define HCI_OP_NOP			0x0000
@@ -336,6 +331,11 @@
 	__u8     link_key[16];
 } __packed;
 
+struct hci_rp_link_key_reply {
+	__u8     status;
+	bdaddr_t bdaddr;
+} __packed;
+
 #define HCI_OP_LINK_KEY_NEG_REPLY	0x040c
 struct hci_cp_link_key_neg_reply {
 	bdaddr_t bdaddr;
@@ -477,6 +477,69 @@
 	__u8     reason;
 } __packed;
 
+#define HCI_OP_CREATE_PHYS_LINK		0x0435
+struct hci_cp_create_phys_link {
+	__u8     phy_handle;
+	__u8     key_len;
+	__u8     type;
+	__u8     data[32];
+} __packed;
+
+#define HCI_OP_ACCEPT_PHYS_LINK		0x0436
+struct hci_cp_accept_phys_link {
+	__u8     phy_handle;
+	__u8     key_len;
+	__u8     type;
+	__u8     data[32];
+} __packed;
+
+#define HCI_OP_DISCONN_PHYS_LINK	0x0437
+struct hci_cp_disconn_phys_link {
+	__u8     phy_handle;
+	__u8     reason;
+} __packed;
+
+struct hci_ext_fs {
+	__u8       id;
+	__u8       type;
+	__le16     max_sdu;
+	__le32     sdu_arr_time;
+	__le32     acc_latency;
+	__le32     flush_to;
+} __packed;
+
+#define HCI_OP_CREATE_LOGICAL_LINK	0x0438
+#define HCI_OP_ACCEPT_LOGICAL_LINK	0x0439
+struct hci_cp_create_logical_link {
+	__u8               phy_handle;
+	struct hci_ext_fs  tx_fs;
+	struct hci_ext_fs  rx_fs;
+} __packed;
+
+#define HCI_OP_DISCONN_LOGICAL_LINK	0x043a
+struct hci_cp_disconn_logical_link {
+	__le16   log_handle;
+} __packed;
+
+#define HCI_OP_LOGICAL_LINK_CANCEL	0x043b
+struct hci_cp_logical_link_cancel {
+	__u8     phy_handle;
+	__u8     flow_spec_id;
+} __packed;
+
+struct hci_rp_logical_link_cancel {
+	__u8     status;
+	__u8     phy_handle;
+	__u8     flow_spec_id;
+} __packed;
+
+#define HCI_OP_FLOW_SPEC_MODIFY		0x043c
+struct hci_cp_flow_spec_modify {
+	__le16             log_handle;
+	struct hci_ext_fs  tx_fs;
+	struct hci_ext_fs  rx_fs;
+} __packed;
+
 #define HCI_OP_SNIFF_MODE		0x0803
 struct hci_cp_sniff_mode {
 	__le16   handle;
@@ -637,6 +700,12 @@
 	__le16   voice_setting;
 } __packed;
 
+#define HCI_OP_WRITE_AUTOMATIC_FLUSH_TIMEOUT	0x0c28
+struct hci_cp_write_automatic_flush_timeout {
+	__le16   handle;
+	__le16   timeout;
+} __packed;
+
 #define HCI_OP_HOST_BUFFER_SIZE		0x0c33
 struct hci_cp_host_buffer_size {
 	__le16   acl_mtu;
@@ -645,6 +714,12 @@
 	__le16   sco_max_pkt;
 } __packed;
 
+#define HCI_OP_WRITE_CURRENT_IAC_LAP	0x0c3a
+struct hci_cp_write_current_iac_lap {
+	__u8     num_current_iac;
+	__u8     lap[6];
+} __packed;
+
 #define HCI_OP_WRITE_INQUIRY_MODE	0x0c45
 
 #define HCI_MAX_EIR_LENGTH		240
@@ -675,10 +750,70 @@
 
 #define HCI_OP_READ_INQ_RSP_TX_POWER	0x0c58
 
-#define HCI_OP_WRITE_LE_HOST_SUPPORTED	0x0c6d
-struct hci_cp_write_le_host_supported {
-	__u8 le;
-	__u8 simul;
+#define HCI_OP_READ_LL_TIMEOUT		0x0c61
+struct hci_rp_read_ll_timeout {
+	__u8     status;
+	__le16   timeout;
+} __packed;
+
+#define HCI_OP_WRITE_LL_TIMEOUT		0x0c62
+struct hci_cp_write_ll_timeout {
+	__le16   timeout;
+} __packed;
+
+#define HCI_OP_SET_EVENT_MASK_PAGE2	0x0c63
+struct hci_cp_set_event_mask_page2 {
+	__u8     mask[8];
+} __packed;
+
+#define HCI_OP_READ_LOCATION_DATA	0x0c64
+struct hci_rp_read_location_data {
+	__u8     status;
+	__u8     loc_dom_aware;
+	__u8     loc_dom;
+	__u8     loc_dom_opts;
+	__u8     loc_opts;
+} __packed;
+
+#define HCI_OP_WRITE_LOCATION_DATA	0x0c65
+struct hci_cp_write_location_data {
+	__u8     loc_dom_aware;
+	__u8     loc_dom;
+	__u8     loc_dom_opts;
+	__u8     loc_opts;
+} __packed;
+
+#define HCI_OP_READ_FLOW_CONTROL_MODE	0x0c66
+struct hci_rp_read_flow_control_mode {
+	__u8     status;
+	__u8     mode;
+} __packed;
+
+#define HCI_OP_WRITE_FLOW_CONTROL_MODE	0x0c67
+struct hci_cp_write_flow_control_mode {
+	__u8     mode;
+} __packed;
+
+#define HCI_OP_READ_BE_FLUSH_TIMEOUT	0x0c69
+struct hci_cp_read_be_flush_timeout {
+	__le16   log_handle;
+} __packed;
+
+struct hci_rp_read_be_flush_timeout {
+	__u8     status;
+	__le32   timeout;
+} __packed;
+
+#define HCI_OP_WRITE_BE_FLUSH_TIMEOUT	0x0c6a
+struct hci_cp_write_be_flush_timeout {
+	__le16   log_handle;
+	__le32   timeout;
+} __packed;
+
+#define HCI_OP_SHORT_RANGE_MODE		0x0c6b
+struct hci_cp_short_range_mode {
+	__u8     phy_handle;
+	__u8     mode;
 } __packed;
 
 #define HCI_OP_READ_LOCAL_VERSION	0x1001
@@ -704,9 +839,6 @@
 } __packed;
 
 #define HCI_OP_READ_LOCAL_EXT_FEATURES	0x1004
-struct hci_cp_read_local_ext_features {
-	__u8     page;
-} __packed;
 struct hci_rp_read_local_ext_features {
 	__u8     status;
 	__u8     page;
@@ -729,6 +861,67 @@
 	bdaddr_t bdaddr;
 } __packed;
 
+#define HCI_OP_READ_DATA_BLOCK_SIZE	0x100a
+struct hci_rp_read_data_block_size {
+	__u8     status;
+	__le16   max_acl_len;
+	__le16   data_block_len;
+	__le16   num_blocks;
+} __packed;
+
+#define HCI_OP_READ_RSSI	0x1405
+struct hci_cp_read_rssi {
+	__le16   handle;
+} __packed;
+
+struct hci_rp_read_rssi {
+	__u8     status;
+	__le16   handle;
+	__s8     rssi;
+} __packed;
+
+#define HCI_OP_READ_LOCAL_AMP_INFO	0x1409
+struct hci_rp_read_local_amp_info {
+	__u8     status;
+	__u8     amp_status;
+	__le32   total_bw;
+	__le32   max_bw;
+	__le32   min_latency;
+	__le32   max_pdu;
+	__u8     amp_type;
+	__le16   pal_cap;
+	__le16   max_assoc_size;
+	__le32   max_flush_to;
+	__le32   be_flush_to;
+} __packed;
+
+#define HCI_OP_READ_LOCAL_AMP_ASSOC	0x140a
+struct hci_cp_read_local_amp_assoc {
+	__u8     phy_handle;
+	__le16   len_so_far;
+	__le16   max_len;
+} __packed;
+
+struct hci_rp_read_local_amp_assoc {
+	__u8     status;
+	__u8     phy_handle;
+	__le16   rem_len;
+	__u8     frag[248];
+} __packed;
+
+#define HCI_OP_WRITE_REMOTE_AMP_ASSOC	0x140b
+struct hci_cp_write_remote_amp_assoc {
+	__u8     phy_handle;
+	__le16   len_so_far;
+	__le16   rem_len;
+	__u8     frag[248];
+} __packed;
+
+struct hci_rp_write_remote_amp_assoc {
+	__u8     status;
+	__u8     phy_handle;
+} __packed;
+
 #define HCI_OP_LE_SET_EVENT_MASK	0x2001
 struct hci_cp_le_set_event_mask {
 	__u8     mask[8];
@@ -741,10 +934,19 @@
 	__u8     le_max_pkt;
 } __packed;
 
+#define HCI_OP_LE_SET_SCAN_PARAMETERS	0x200b
+struct hci_cp_le_set_scan_parameters {
+	__u8	type;
+	__le16	interval;
+	__le16	window;
+	__u8	own_bdaddr_type;
+	__u8	filter;
+} __packed;
+
 #define HCI_OP_LE_SET_SCAN_ENABLE	0x200c
 struct hci_cp_le_set_scan_enable {
-	__u8     enable;
-	__u8     filter_dup;
+	__u8	enable;
+	__u8	filter_dup;
 } __packed;
 
 #define HCI_OP_LE_CREATE_CONN		0x200d
@@ -796,6 +998,16 @@
 	__le16   max_ce_len;
 } __packed;
 
+#define HCI_OP_LE_ENCRYPT		0x2017
+struct hci_cp_le_encrypt {
+	__u8	key[16];
+	__u8	data[16];
+} __packed;
+struct hci_cp_le_encrypt_reply {
+	__u8     status;
+	__u8     encrypted[16];
+} __packed;
+
 #define HCI_OP_LE_START_ENC		0x2019
 struct hci_cp_le_start_enc {
 	__le16	handle;
@@ -1077,6 +1289,11 @@
 	__le32		passkey;
 } __packed;
 
+#define HCI_EV_USER_PASSKEY_REQUEST	0x34
+struct hci_ev_user_passkey_request {
+	bdaddr_t bdaddr;
+} __packed;
+
 #define HCI_EV_REMOTE_OOB_DATA_REQUEST	0x35
 struct hci_ev_remote_oob_data_request {
 	bdaddr_t bdaddr;
@@ -1088,6 +1305,12 @@
 	bdaddr_t bdaddr;
 } __packed;
 
+#define HCI_EV_USER_PASSKEY_NOTIFICATION	0x3b
+struct hci_ev_user_passkey_notification {
+	bdaddr_t	bdaddr;
+	__le32		passkey;
+} __packed;
+
 #define HCI_EV_REMOTE_HOST_FEATURES	0x3d
 struct hci_ev_remote_host_features {
 	bdaddr_t bdaddr;
@@ -1113,14 +1336,6 @@
 	__u8     clk_accurancy;
 } __packed;
 
-#define HCI_EV_LE_LTK_REQ		0x05
-struct hci_ev_le_ltk_req {
-	__le16	handle;
-	__u8	random[8];
-	__le16	ediv;
-} __packed;
-
-/* Advertising report event types */
 #define ADV_IND		0x00
 #define ADV_DIRECT_IND	0x01
 #define ADV_SCAN_IND	0x02
@@ -1261,6 +1476,7 @@
 	__u8	dlen;
 } __packed;
 
+#ifdef __KERNEL__
 #include <linux/skbuff.h>
 static inline struct hci_event_hdr *hci_event_hdr(const struct sk_buff *skb)
 {
@@ -1276,6 +1492,7 @@
 {
 	return (struct hci_sco_hdr *) skb->data;
 }
+#endif
 
 /* Command opcode pack/unpack */
 #define hci_opcode_pack(ogf, ocf)	(__u16) ((ocf & 0x03ff)|(ogf << 10))
@@ -1372,6 +1589,8 @@
 	__u32    mtu;
 	__u32    cnt;
 	__u32    pkts;
+	__u8     pending_sec_level;
+	__u8     ssp_mode;
 };
 
 struct hci_dev_req {
@@ -1411,5 +1630,3 @@
 #define IREQ_CACHE_FLUSH 0x0001
 
 #endif /* __HCI_H */
-
-#endif /* BT_MGMT */
Nur in final2/include/net/bluetooth: hci_mgmt.h.
diff -ru final2/include/net/bluetooth/l2cap.h ics/include/net/bluetooth/l2cap.h
--- final2/include/net/bluetooth/l2cap.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/net/bluetooth/l2cap.h	2013-04-19 11:37:14.000000000 +0200
@@ -23,27 +23,36 @@
    COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
    SOFTWARE IS DISCLAIMED.
 */
-#ifdef CONFIG_BT_MGMT
-#include "l2cap_mgmt.h"
-#else
+
 #ifndef __L2CAP_H
 #define __L2CAP_H
 
 /* L2CAP defaults */
 #define L2CAP_DEFAULT_MTU		672
 #define L2CAP_DEFAULT_MIN_MTU		48
+#define L2CAP_DEFAULT_MAX_SDU_SIZE	0xffff
 #define L2CAP_DEFAULT_FLUSH_TO		0xffff
 #define L2CAP_MAX_FLUSH_TO		0x7ff
 #define L2CAP_DEFAULT_TX_WINDOW		63
 #define L2CAP_DEFAULT_MAX_TX		3
 #define L2CAP_DEFAULT_RETRANS_TO	2000    /* 2 seconds */
 #define L2CAP_DEFAULT_MONITOR_TO	12000   /* 12 seconds */
-#define L2CAP_DEFAULT_MAX_PDU_SIZE	1009    /* Sized for 3-DH5 packet */
+#define L2CAP_DEFAULT_MAX_PDU_SIZE	1482    /* Sized for AMP or BR/EDR */
 #define L2CAP_DEFAULT_ACK_TO		200
+#define L2CAP_BREDR_MAX_PAYLOAD		1019    /* 3-DH5 packet */
+#define L2CAP_MAX_ERTM_QUEUED		5
+#define L2CAP_MIN_ERTM_QUEUED		2
+
+#define L2CAP_A2MP_DEFAULT_MTU		670
+
+#define L2CAP_TX_WIN_MAX_ENHANCED	0x3f
+#define L2CAP_TX_WIN_MAX_EXTENDED	0x3fff
 #define L2CAP_LE_DEFAULT_MTU		23
 
 #define L2CAP_CONN_TIMEOUT	(40000) /* 40 seconds */
 #define L2CAP_INFO_TIMEOUT	(4000)  /*  4 seconds */
+#define L2CAP_MOVE_TIMEOUT		(4*HZ)  /*  4 seconds */
+#define L2CAP_MOVE_ERTX_TIMEOUT		(60*HZ) /* 60 seconds */
 
 /* L2CAP socket address */
 struct sockaddr_l2 {
@@ -78,19 +87,26 @@
 #define L2CAP_LM_TRUSTED	0x0008
 #define L2CAP_LM_RELIABLE	0x0010
 #define L2CAP_LM_SECURE		0x0020
+#define L2CAP_LM_FLUSHABLE	0x0040
 
 /* L2CAP command codes */
-#define L2CAP_COMMAND_REJ	0x01
-#define L2CAP_CONN_REQ		0x02
-#define L2CAP_CONN_RSP		0x03
-#define L2CAP_CONF_REQ		0x04
-#define L2CAP_CONF_RSP		0x05
-#define L2CAP_DISCONN_REQ	0x06
-#define L2CAP_DISCONN_RSP	0x07
-#define L2CAP_ECHO_REQ		0x08
-#define L2CAP_ECHO_RSP		0x09
-#define L2CAP_INFO_REQ		0x0a
-#define L2CAP_INFO_RSP		0x0b
+#define L2CAP_COMMAND_REJ		0x01
+#define L2CAP_CONN_REQ			0x02
+#define L2CAP_CONN_RSP			0x03
+#define L2CAP_CONF_REQ			0x04
+#define L2CAP_CONF_RSP			0x05
+#define L2CAP_DISCONN_REQ		0x06
+#define L2CAP_DISCONN_RSP		0x07
+#define L2CAP_ECHO_REQ			0x08
+#define L2CAP_ECHO_RSP			0x09
+#define L2CAP_INFO_REQ			0x0a
+#define L2CAP_INFO_RSP			0x0b
+#define L2CAP_CREATE_CHAN_REQ	0x0c
+#define L2CAP_CREATE_CHAN_RSP	0x0d
+#define L2CAP_MOVE_CHAN_REQ		0x0e
+#define L2CAP_MOVE_CHAN_RSP		0x0f
+#define L2CAP_MOVE_CHAN_CFM		0x10
+#define L2CAP_MOVE_CHAN_CFM_RSP	0x11
 #define L2CAP_CONN_PARAM_UPDATE_REQ	0x12
 #define L2CAP_CONN_PARAM_UPDATE_RSP	0x13
 
@@ -101,36 +117,63 @@
 #define L2CAP_FEAT_STREAMING	0x00000010
 #define L2CAP_FEAT_FCS		0x00000020
 #define L2CAP_FEAT_FIXED_CHAN	0x00000080
+#define L2CAP_FEAT_EXT_WINDOW	0x00000100
+#define L2CAP_FEAT_UCD		0x00000200
 
 /* L2CAP checksum option */
 #define L2CAP_FCS_NONE		0x00
 #define L2CAP_FCS_CRC16		0x01
 
-/* L2CAP Control Field bit masks */
+/* L2CAP fixed channels */
+#define L2CAP_FC_L2CAP		0x02
+#define L2CAP_FC_A2MP		0x08
+
+/* L2CAP Control Field */
 #define L2CAP_CTRL_SAR               0xC000
 #define L2CAP_CTRL_REQSEQ            0x3F00
 #define L2CAP_CTRL_TXSEQ             0x007E
-#define L2CAP_CTRL_RETRANS           0x0080
 #define L2CAP_CTRL_FINAL             0x0080
 #define L2CAP_CTRL_POLL              0x0010
 #define L2CAP_CTRL_SUPERVISE         0x000C
 #define L2CAP_CTRL_FRAME_TYPE        0x0001 /* I- or S-Frame */
 
 #define L2CAP_CTRL_TXSEQ_SHIFT      1
+#define L2CAP_CTRL_SUPERVISE_SHIFT  2
+#define L2CAP_CTRL_POLL_SHIFT       4
+#define L2CAP_CTRL_FINAL_SHIFT      7
 #define L2CAP_CTRL_REQSEQ_SHIFT     8
 #define L2CAP_CTRL_SAR_SHIFT       14
 
-/* L2CAP Supervisory Function */
-#define L2CAP_SUPER_RCV_READY           0x0000
-#define L2CAP_SUPER_REJECT              0x0004
-#define L2CAP_SUPER_RCV_NOT_READY       0x0008
-#define L2CAP_SUPER_SELECT_REJECT       0x000C
+#define L2CAP_EXT_CTRL_SAR           0x00030000
+#define L2CAP_EXT_CTRL_REQSEQ        0x0000FFFC
+#define L2CAP_EXT_CTRL_TXSEQ         0xFFFC0000
+#define L2CAP_EXT_CTRL_FINAL         0x00000002
+#define L2CAP_EXT_CTRL_POLL          0x00040000
+#define L2CAP_EXT_CTRL_SUPERVISE     0x00030000
+#define L2CAP_EXT_CTRL_FRAME_TYPE    0x00000001 /* I- or S-Frame */
+
+#define L2CAP_EXT_CTRL_FINAL_SHIFT      1
+#define L2CAP_EXT_CTRL_REQSEQ_SHIFT     2
+#define L2CAP_EXT_CTRL_SAR_SHIFT       16
+#define L2CAP_EXT_CTRL_SUPERVISE_SHIFT 16
+#define L2CAP_EXT_CTRL_POLL_SHIFT      18
+#define L2CAP_EXT_CTRL_TXSEQ_SHIFT     18
+
+/* L2CAP Supervisory Frame Types */
+#define L2CAP_SFRAME_RR            0x00
+#define L2CAP_SFRAME_REJ           0x01
+#define L2CAP_SFRAME_RNR           0x02
+#define L2CAP_SFRAME_SREJ          0x03
 
 /* L2CAP Segmentation and Reassembly */
-#define L2CAP_SDU_UNSEGMENTED       0x0000
-#define L2CAP_SDU_START             0x4000
-#define L2CAP_SDU_END               0x8000
-#define L2CAP_SDU_CONTINUE          0xC000
+#define L2CAP_SAR_UNSEGMENTED      0x00
+#define L2CAP_SAR_START            0x01
+#define L2CAP_SAR_END              0x02
+#define L2CAP_SAR_CONTINUE         0x03
+
+/* L2CAP ERTM / Streaming extra field lengths */
+#define L2CAP_SDULEN_SIZE       2
+#define L2CAP_FCS_SIZE          2
 
 /* L2CAP structures */
 struct l2cap_hdr {
@@ -138,6 +181,8 @@
 	__le16     cid;
 } __packed;
 #define L2CAP_HDR_SIZE		4
+#define L2CAP_ENHANCED_HDR_SIZE	6
+#define L2CAP_EXTENDED_HDR_SIZE	8
 
 struct l2cap_cmd_hdr {
 	__u8       code;
@@ -165,6 +210,7 @@
 /* channel indentifier */
 #define L2CAP_CID_SIGNALING	0x0001
 #define L2CAP_CID_CONN_LESS	0x0002
+#define L2CAP_CID_A2MP		0x0003
 #define L2CAP_CID_LE_DATA	0x0004
 #define L2CAP_CID_LE_SIGNALING	0x0005
 #define L2CAP_CID_SMP		0x0006
@@ -200,6 +246,8 @@
 #define L2CAP_CONF_UNACCEPT	0x0001
 #define L2CAP_CONF_REJECT	0x0002
 #define L2CAP_CONF_UNKNOWN	0x0003
+#define L2CAP_CONF_PENDING	0x0004
+#define L2CAP_CONF_FLOW_SPEC_REJECT	0x0005
 
 struct l2cap_conf_opt {
 	__u8       type;
@@ -216,6 +264,13 @@
 #define L2CAP_CONF_QOS		0x03
 #define L2CAP_CONF_RFC		0x04
 #define L2CAP_CONF_FCS		0x05
+#define L2CAP_CONF_EXT_FS	0x06
+#define L2CAP_CONF_EXT_WINDOW	0x07
+
+/* QOS Service type */
+#define L2CAP_SERVICE_NO_TRAFFIC		0x00
+#define L2CAP_SERVICE_BEST_EFFORT		0x01
+#define L2CAP_SERVICE_GUARANTEED		0x02
 
 #define L2CAP_CONF_MAX_SIZE	22
 
@@ -228,6 +283,20 @@
 	__le16     max_pdu_size;
 } __packed;
 
+struct l2cap_conf_ext_fs {
+	__u8       id;
+	__u8       type;
+	__le16     max_sdu;
+	__le32     sdu_arr_time;
+	__le32     acc_latency;
+	__le32     flush_to;
+} __packed;
+
+struct l2cap_conf_prm {
+	__u8       fcs;
+	__le32     flush_to;
+};
+
 #define L2CAP_MODE_BASIC	0x00
 #define L2CAP_MODE_RETRANS	0x01
 #define L2CAP_MODE_FLOWCTL	0x02
@@ -254,6 +323,79 @@
 	__u8        data[0];
 } __packed;
 
+struct l2cap_create_chan_req {
+	__le16      psm;
+	__le16      scid;
+	__u8        amp_id;
+} __attribute__ ((packed));
+
+struct l2cap_create_chan_rsp {
+	__le16      dcid;
+	__le16      scid;
+	__le16      result;
+	__le16      status;
+} __attribute__ ((packed));
+
+#define L2CAP_CREATE_CHAN_SUCCESS				(0x0000)
+#define L2CAP_CREATE_CHAN_PENDING				(0x0001)
+#define L2CAP_CREATE_CHAN_REFUSED_PSM			(0x0002)
+#define L2CAP_CREATE_CHAN_REFUSED_SECURITY		(0x0003)
+#define L2CAP_CREATE_CHAN_REFUSED_RESOURCES		(0x0004)
+#define L2CAP_CREATE_CHAN_REFUSED_CONTROLLER	(0x0005)
+
+#define L2CAP_CREATE_CHAN_STATUS_NONE			(0x0000)
+#define L2CAP_CREATE_CHAN_STATUS_AUTHENTICATION	(0x0001)
+#define L2CAP_CREATE_CHAN_STATUS_AUTHORIZATION	(0x0002)
+
+struct l2cap_move_chan_req {
+	__le16      icid;
+	__u8        dest_amp_id;
+} __attribute__ ((packed));
+
+struct l2cap_move_chan_rsp {
+	__le16      icid;
+	__le16      result;
+} __attribute__ ((packed));
+
+#define L2CAP_MOVE_CHAN_SUCCESS				(0x0000)
+#define L2CAP_MOVE_CHAN_PENDING				(0x0001)
+#define L2CAP_MOVE_CHAN_REFUSED_CONTROLLER	(0x0002)
+#define L2CAP_MOVE_CHAN_REFUSED_SAME_ID		(0x0003)
+#define L2CAP_MOVE_CHAN_REFUSED_CONFIG		(0x0004)
+#define L2CAP_MOVE_CHAN_REFUSED_COLLISION	(0x0005)
+#define L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED	(0x0006)
+
+struct l2cap_move_chan_cfm {
+	__le16      icid;
+	__le16      result;
+} __attribute__ ((packed));
+
+#define L2CAP_MOVE_CHAN_CONFIRMED	(0x0000)
+#define L2CAP_MOVE_CHAN_UNCONFIRMED	(0x0001)
+
+struct l2cap_move_chan_cfm_rsp {
+	__le16      icid;
+} __attribute__ ((packed));
+
+struct l2cap_amp_signal_work {
+	struct work_struct work;
+	struct l2cap_cmd_hdr cmd;
+	struct l2cap_conn *conn;
+	struct sk_buff *skb;
+	u8 *data;
+};
+
+struct l2cap_resegment_work {
+	struct work_struct work;
+	struct sock *sk;
+};
+
+struct l2cap_logical_link_work {
+	struct work_struct work;
+	struct hci_chan *chan;
+	u8 status;
+};
+
 /* info type */
 #define L2CAP_IT_CL_MTU     0x0001
 #define L2CAP_IT_FEAT_MASK  0x0002
@@ -278,98 +420,10 @@
 #define L2CAP_CONN_PARAM_ACCEPTED	0x0000
 #define L2CAP_CONN_PARAM_REJECTED	0x0001
 
-/* ----- L2CAP channels and connections ----- */
-struct srej_list {
-	__u8	tx_seq;
-	struct list_head list;
-};
-
-struct l2cap_chan {
-	struct sock *sk;
-
-	struct l2cap_conn	*conn;
-
-	__u8		state;
-
-	atomic_t	refcnt;
-
-	__le16		psm;
-	__u16		dcid;
-	__u16		scid;
-
-	__u16		imtu;
-	__u16		omtu;
-	__u16		flush_to;
-	__u8		mode;
-	__u8		chan_type;
-
-	__le16		sport;
-
-	__u8		sec_level;
-	__u8		role_switch;
-	__u8		force_reliable;
-	__u8		flushable;
-	__u8		force_active;
-
-	__u8		ident;
-
-	__u8		conf_req[64];
-	__u8		conf_len;
-	__u8		num_conf_req;
-	__u8		num_conf_rsp;
-
-	__u8		fcs;
-
-	__u8		tx_win;
-	__u8		max_tx;
-	__u16		retrans_timeout;
-	__u16		monitor_timeout;
-	__u16		mps;
-
-	unsigned long	conf_state;
-	unsigned long	conn_state;
-
-	__u8		next_tx_seq;
-	__u8		expected_ack_seq;
-	__u8		expected_tx_seq;
-	__u8		buffer_seq;
-	__u8		buffer_seq_srej;
-	__u8		srej_save_reqseq;
-	__u8		frames_sent;
-	__u8		unacked_frames;
-	__u8		retry_count;
-	__u8		num_acked;
-	__u16		sdu_len;
-	__u16		partial_sdu_len;
-	struct sk_buff	*sdu;
-
-	__u8		remote_tx_win;
-	__u8		remote_max_tx;
-	__u16		remote_mps;
-
-	struct timer_list	chan_timer;
-	struct timer_list	retrans_timer;
-	struct timer_list	monitor_timer;
-	struct timer_list	ack_timer;
-	struct sk_buff		*tx_send_head;
-	struct sk_buff_head	tx_q;
-	struct sk_buff_head	srej_q;
-	struct list_head	srej_l;
-
-	struct list_head list;
-	struct list_head global_l;
-
-	void		*data;
-	struct l2cap_ops *ops;
-};
-
-struct l2cap_ops {
-	char		*name;
-
-	struct l2cap_chan	*(*new_connection) (void *data);
-	int			(*recv) (void *data, struct sk_buff *skb);
-	void			(*close) (void *data);
-	void			(*state_change) (void *data, int state);
+/* ----- L2CAP connections ----- */
+struct l2cap_chan_list {
+	struct sock	*head;
+	rwlock_t	lock;
 };
 
 struct l2cap_conn {
@@ -381,6 +435,8 @@
 	unsigned int	mtu;
 
 	__u32		feat_mask;
+	__u8		fc_mask;
+	struct amp_mgr *mgr;
 
 	__u8		info_state;
 	__u8		info_ident;
@@ -395,86 +451,136 @@
 
 	__u8		disc_reason;
 
-	__u8		preq[7]; /* SMP Pairing Request */
-	__u8		prsp[7]; /* SMP Pairing Response */
-	__u8		prnd[16]; /* SMP Pairing Random */
-	__u8		pcnf[16]; /* SMP Pairing Confirm */
-	__u8		tk[16]; /* SMP Temporary Key */
-	__u8		smp_key_size;
-
-	struct timer_list security_timer;
+	struct l2cap_chan_list chan_list;
+};
 
-	struct list_head chan_l;
-	rwlock_t	chan_lock;
+struct sock_del_list {
+	struct sock *sk;
+	struct list_head list;
 };
 
 #define L2CAP_INFO_CL_MTU_REQ_SENT	0x01
 #define L2CAP_INFO_FEAT_MASK_REQ_SENT	0x04
 #define L2CAP_INFO_FEAT_MASK_REQ_DONE	0x08
 
-#define L2CAP_CHAN_RAW			1
-#define L2CAP_CHAN_CONN_LESS		2
-#define L2CAP_CHAN_CONN_ORIENTED	3
-
-/* ----- L2CAP socket info ----- */
+/* ----- L2CAP channel and socket info ----- */
 #define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)
+#define TX_QUEUE(sk) (&l2cap_pi(sk)->tx_queue)
+#define SREJ_QUEUE(sk) (&l2cap_pi(sk)->srej_queue)
+
+struct l2cap_seq_list {
+	__u16 head;
+	__u16 tail;
+	__u16 size;
+	__u16 mask;
+	__u16 *list;
+};
 
 struct l2cap_pinfo {
 	struct bt_sock	bt;
-	struct l2cap_chan	*chan;
-	struct sk_buff	*rx_busy_skb;
-};
+	__le16		psm;
+	__u16		dcid;
+	__u16		scid;
 
-enum {
-	CONF_REQ_SENT,
-	CONF_INPUT_DONE,
-	CONF_OUTPUT_DONE,
-	CONF_MTU_DONE,
-	CONF_MODE_DONE,
-	CONF_CONNECT_PEND,
-	CONF_NO_FCS_RECV,
-	CONF_STATE2_DEVICE,
-};
+	__u16		imtu;
+	__u16		omtu;
+	__u16		flush_to;
+	__u8		mode;
+	__u8		fixed_channel;
+	__u8		num_conf_req;
+	__u8		num_conf_rsp;
+	__u8		incoming;
 
-#define L2CAP_CONF_MAX_CONF_REQ 2
-#define L2CAP_CONF_MAX_CONF_RSP 2
+	__u8		fcs;
+	__u8		sec_level;
+	__u8		role_switch;
+	__u8		force_reliable;
+	__u8		flushable;
+	__u8		force_active;
+
+	__u8		conf_req[64];
+	__u8		conf_len;
+	__u8		conf_ident;
+	__u16		conf_state;
+	__u8		conn_state;
+	__u8		tx_state;
+	__u8		rx_state;
+	__u8		reconf_state;
+
+	__u8		amp_id;
+	__u8		amp_move_id;
+	__u8		amp_move_state;
+	__u8		amp_move_role;
+	__u8		amp_move_cmd_ident;
+	__u16		amp_move_reqseq;
+	__u16		amp_move_event;
+
+	__u16		next_tx_seq;
+	__u16		expected_ack_seq;
+	__u16		expected_tx_seq;
+	__u16		buffer_seq;
+	__u16		srej_save_reqseq;
+	__u16		last_acked_seq;
+	__u32		frames_sent;
+	__u16		unacked_frames;
+	__u8		retry_count;
+	__u16		srej_queue_next;
+	__u16		sdu_len;
+	struct sk_buff	*sdu;
+	struct sk_buff	*sdu_last_frag;
+	atomic_t	ertm_queued;
+
+	__u8		ident;
+
+	__u16		tx_win;
+	__u16		tx_win_max;
+	__u8		max_tx;
+	__u8		amp_pref;
+	__u16		remote_tx_win;
+	__u8		remote_max_tx;
+	__u8		extended_control;
+	__u16		retrans_timeout;
+	__u16		monitor_timeout;
+	__u16		remote_mps;
+	__u16		mps;
 
-enum {
-	CONN_SAR_SDU,
-	CONN_SREJ_SENT,
-	CONN_WAIT_F,
-	CONN_SREJ_ACT,
-	CONN_SEND_PBIT,
-	CONN_REMOTE_BUSY,
-	CONN_LOCAL_BUSY,
-	CONN_REJ_ACT,
-	CONN_SEND_FBIT,
-	CONN_RNR_SENT,
-};
-
-#define __set_chan_timer(c, t) l2cap_set_timer(c, &c->chan_timer, (t))
-#define __clear_chan_timer(c) l2cap_clear_timer(c, &c->chan_timer)
-#define __set_retrans_timer(c) l2cap_set_timer(c, &c->retrans_timer, \
-		L2CAP_DEFAULT_RETRANS_TO);
-#define __clear_retrans_timer(c) l2cap_clear_timer(c, &c->retrans_timer)
-#define __set_monitor_timer(c) l2cap_set_timer(c, &c->monitor_timer, \
-		L2CAP_DEFAULT_MONITOR_TO);
-#define __clear_monitor_timer(c) l2cap_clear_timer(c, &c->monitor_timer)
-#define __set_ack_timer(c) l2cap_set_timer(c, &chan->ack_timer, \
-		L2CAP_DEFAULT_ACK_TO);
-#define __clear_ack_timer(c) l2cap_clear_timer(c, &c->ack_timer)
-
-static inline int l2cap_tx_window_full(struct l2cap_chan *ch)
-{
-	int sub;
+	__le16		sport;
 
-	sub = (ch->next_tx_seq - ch->expected_ack_seq) % 64;
+	struct delayed_work	retrans_work;
+	struct delayed_work	monitor_work;
+	struct delayed_work	ack_work;
+	struct work_struct	tx_work;
+	struct sk_buff_head	tx_queue;
+	struct sk_buff_head	srej_queue;
+	struct l2cap_seq_list srej_list;
+	struct l2cap_seq_list retrans_list;
+	struct hci_conn	*ampcon;
+	struct hci_chan	*ampchan;
+	struct l2cap_conn	*conn;
+	struct l2cap_conf_prm local_conf;
+	struct l2cap_conf_prm remote_conf;
+	struct l2cap_conf_ext_fs local_fs;
+	struct l2cap_conf_ext_fs remote_fs;
+	struct sock		*next_c;
+	struct sock		*prev_c;
+};
 
-	if (sub < 0)
-		sub += 64;
+#define L2CAP_CONF_REQ_SENT       0x0001
+#define L2CAP_CONF_INPUT_DONE     0x0002
+#define L2CAP_CONF_OUTPUT_DONE    0x0004
+#define L2CAP_CONF_MTU_DONE       0x0008
+#define L2CAP_CONF_MODE_DONE      0x0010
+#define L2CAP_CONF_CONNECT_PEND   0x0020
+#define L2CAP_CONF_NO_FCS_RECV    0x0040
+#define L2CAP_CONF_STATE2_DEVICE  0x0080
+#define L2CAP_CONF_EXT_WIN_RECV   0x0100
+#define L2CAP_CONF_LOCKSTEP       0x0200
+#define L2CAP_CONF_LOCKSTEP_PEND  0x0400
+#define L2CAP_CONF_PEND_SENT      0x0800
+#define L2CAP_CONF_EFS_RECV       0x1000
 
-	return sub == ch->remote_tx_win;
-}
+#define L2CAP_CONF_MAX_CONF_REQ 2
+#define L2CAP_CONF_MAX_CONF_RSP 2
 
 #define L2CAP_RECONF_NONE          0x00
 #define L2CAP_RECONF_INT           0x01
@@ -555,23 +661,60 @@
 #define __next_seq(x, pi) ((x + 1) & ((pi)->tx_win_max))
 
 extern int disable_ertm;
+extern const struct proto_ops l2cap_sock_ops;
+extern struct bt_sock_list l2cap_sk_list;
 
 int l2cap_init_sockets(void);
 void l2cap_cleanup_sockets(void);
 
-void __l2cap_connect_rsp_defer(struct l2cap_chan *chan);
+u8 l2cap_get_ident(struct l2cap_conn *conn);
+void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data);
+int l2cap_build_conf_req(struct sock *sk, void *data);
 int __l2cap_wait_ack(struct sock *sk);
 
-int l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm);
-int l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid);
+struct sk_buff *l2cap_create_connless_pdu(struct sock *sk, struct msghdr *msg, size_t len);
+struct sk_buff *l2cap_create_basic_pdu(struct sock *sk, struct msghdr *msg, size_t len);
+struct sk_buff *l2cap_create_iframe_pdu(struct sock *sk, struct msghdr *msg,
+				size_t len, u16 sdulen, int reseg);
+int l2cap_segment_sdu(struct sock *sk, struct sk_buff_head* seg_queue,
+			struct msghdr *msg, size_t len, int reseg);
+int l2cap_resegment_queue(struct sock *sk, struct sk_buff_head *queue);
+void l2cap_do_send(struct sock *sk, struct sk_buff *skb);
+void l2cap_streaming_send(struct sock *sk);
+int l2cap_ertm_send(struct sock *sk);
+int l2cap_strm_tx(struct sock *sk, struct sk_buff_head *skbs);
+int l2cap_ertm_tx(struct sock *sk, struct bt_l2cap_control *control,
+			struct sk_buff_head *skbs, u8 event);
+
+int l2cap_sock_le_params_valid(struct bt_le_params *le_params);
+void l2cap_sock_set_timer(struct sock *sk, long timeout);
+void l2cap_sock_clear_timer(struct sock *sk);
+void __l2cap_sock_close(struct sock *sk, int reason);
+void l2cap_sock_kill(struct sock *sk);
+void l2cap_sock_init(struct sock *sk, struct sock *parent);
+struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
+							int proto, gfp_t prio);
+struct sock *l2cap_find_sock_by_fixed_cid_and_dir(__le16 cid, bdaddr_t *src,
+						bdaddr_t *dst, int server);
+void l2cap_send_disconn_req(struct l2cap_conn *conn, struct sock *sk, int err);
+void l2cap_chan_del(struct sock *sk, int err);
+int l2cap_do_connect(struct sock *sk);
+int l2cap_data_channel(struct sock *sk, struct sk_buff *skb);
+void l2cap_amp_move_init(struct sock *sk);
+void l2cap_ertm_destruct(struct sock *sk);
+void l2cap_ertm_shutdown(struct sock *sk);
+void l2cap_ertm_recv_done(struct sock *sk);
+
+void l2cap_fixed_channel_config(struct sock *sk, struct l2cap_options *opt);
+
+void l2cap_recv_deferred_frame(struct sock *sk, struct sk_buff *skb);
 
-struct l2cap_chan *l2cap_chan_create(struct sock *sk);
-void l2cap_chan_close(struct l2cap_chan *chan, int reason);
-void l2cap_chan_destroy(struct l2cap_chan *chan);
-int l2cap_chan_connect(struct l2cap_chan *chan);
-int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len);
-void l2cap_chan_busy(struct l2cap_chan *chan, int busy);
+void l2cap_amp_physical_complete(int result, u8 remote_id, u8 local_id,
+				struct sock *sk);
 
-#endif /* __L2CAP_H */
+void l2cap_amp_logical_complete(int result, struct hci_conn *ampcon,
+				struct hci_chan *ampchan, struct sock *sk);
 
-#endif /* BT_MGMT */
+void l2cap_amp_logical_destroyed(struct hci_conn *ampcon);
+
+#endif /* __L2CAP_H */
Nur in final2/include/net/bluetooth: l2cap_mgmt.h.
diff -ru final2/include/net/bluetooth/mgmt.h ics/include/net/bluetooth/mgmt.h
--- final2/include/net/bluetooth/mgmt.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/net/bluetooth/mgmt.h	2013-04-19 11:37:14.000000000 +0200
@@ -21,10 +21,6 @@
    SOFTWARE IS DISCLAIMED.
 */
 
-#ifdef CONFIG_BT_MGMT
-#include "mgmt_mgmt.h"
-#else
-
 #define MGMT_INDEX_NONE			0xFFFF
 
 struct mgmt_hdr {
@@ -95,6 +91,8 @@
 	__u8 major;
 	__u8 minor;
 } __packed;
+#define MGMT_MAJOR_CLASS_MASK		0x1F
+#define MGMT_MAJOR_CLASS_LIMITED	0x20
 
 #define MGMT_OP_SET_SERVICE_CACHE	0x000C
 struct mgmt_cp_set_service_cache {
@@ -103,11 +101,13 @@
 
 struct mgmt_key_info {
 	bdaddr_t bdaddr;
-	u8 type;
+	u8 addr_type;
+	u8 key_type;
 	u8 val[16];
 	u8 pin_len;
+	u8 auth;
 	u8 dlen;
-	u8 data[0];
+	u8 data[10];
 } __packed;
 
 #define MGMT_OP_LOAD_KEYS		0x000D
@@ -206,20 +206,45 @@
 
 #define MGMT_OP_STOP_DISCOVERY		0x001C
 
-#define MGMT_OP_BLOCK_DEVICE		0x001D
-struct mgmt_cp_block_device {
+#define MGMT_OP_USER_PASSKEY_REPLY	0x001D
+struct mgmt_cp_user_passkey_reply {
 	bdaddr_t bdaddr;
+	__le32 passkey;
 } __packed;
 
-#define MGMT_OP_UNBLOCK_DEVICE		0x001E
-struct mgmt_cp_unblock_device {
+#define MGMT_OP_RESOLVE_NAME		0x001E
+struct mgmt_cp_resolve_name {
 	bdaddr_t bdaddr;
 } __packed;
 
-#define MGMT_OP_LE_TEST_END		0x0028
-struct mgmt_rp_le_test_end {
-	__u8 status;
-	__u16 num_pkts;
+#define MGMT_OP_SET_LIMIT_DISCOVERABLE	0x001F
+
+#define MGMT_OP_SET_CONNECTION_PARAMS	0x0020
+struct mgmt_cp_set_connection_params {
+	bdaddr_t bdaddr;
+	__le16 interval_min;
+	__le16 interval_max;
+	__le16 slave_latency;
+	__le16 timeout_multiplier;
+} __packed;
+
+#define MGMT_OP_ENCRYPT_LINK		0x0021
+struct mgmt_cp_encrypt_link {
+	bdaddr_t bdaddr;
+	__u8 enable;
+} __packed;
+
+#define MGMT_OP_SET_RSSI_REPORTER		0x0022
+struct mgmt_cp_set_rssi_reporter {
+	bdaddr_t	bdaddr;
+	__s8		rssi_threshold;
+	__le16	interval;
+	__u8		updateOnThreshExceed;
+} __packed;
+
+#define MGMT_OP_UNSET_RSSI_REPORTER		0x0023
+struct mgmt_cp_unset_rssi_reporter {
+	bdaddr_t	bdaddr;
 } __packed;
 
 #define MGMT_OP_LE_READ_WHITE_LIST_SIZE	0xE000
@@ -285,6 +310,7 @@
 #define MGMT_EV_CONNECTED		0x000B
 struct mgmt_ev_connected {
 	bdaddr_t bdaddr;
+	__u8 le;
 } __packed;
 
 #define MGMT_EV_DISCONNECTED		0x000C
@@ -308,7 +334,8 @@
 #define MGMT_EV_USER_CONFIRM_REQUEST	0x000F
 struct mgmt_ev_user_confirm_request {
 	bdaddr_t bdaddr;
-	__u8 confirm_hint;
+	__u8 auto_confirm;
+	__u8 event;
 	__le32 value;
 } __packed;
 
@@ -328,12 +355,15 @@
 	bdaddr_t bdaddr;
 	__u8 dev_class[3];
 	__s8 rssi;
+	__u8 le;
+	__u8 type;
 	__u8 eir[HCI_MAX_EIR_LENGTH];
 } __packed;
 
 #define MGMT_EV_REMOTE_NAME		0x0013
 struct mgmt_ev_remote_name {
 	bdaddr_t bdaddr;
+	__u8 status;
 	__u8 name[MGMT_MAX_NAME_LENGTH];
 } __packed;
 
@@ -384,5 +414,3 @@
 	__u16 latency;
 	__u16 timeout;
 } __packed;
-
-#endif /*BT_MGMT*/
Nur in final2/include/net/bluetooth: mgmt_mgmt.h.
diff -ru final2/include/net/bluetooth/rfcomm.h ics/include/net/bluetooth/rfcomm.h
--- final2/include/net/bluetooth/rfcomm.h	2014-08-29 08:16:36.116241000 +0200
+++ ics/include/net/bluetooth/rfcomm.h	2013-04-19 11:37:14.000000000 +0200
@@ -160,7 +160,6 @@
 	unsigned long    flags;
 	atomic_t         refcnt;
 	int              initiator;
-	int              acceptor_inc;
 
 	/* Default DLC parameters */
 	int    cfc;
@@ -235,8 +234,7 @@
 /* ---- RFCOMM DLCs (channels) ---- */
 struct rfcomm_dlc *rfcomm_dlc_alloc(gfp_t prio);
 void rfcomm_dlc_free(struct rfcomm_dlc *d);
-int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst,
-								u8 channel);
+int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst, u8 channel);
 int  rfcomm_dlc_close(struct rfcomm_dlc *d, int reason);
 int  rfcomm_dlc_send(struct rfcomm_dlc *d, struct sk_buff *skb);
 int  rfcomm_dlc_set_modem_status(struct rfcomm_dlc *d, u8 v24_sig);
@@ -273,8 +271,7 @@
 }
 
 /* ---- RFCOMM sessions ---- */
-void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src,
-								bdaddr_t *dst);
+void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src, bdaddr_t *dst);
 
 static inline void rfcomm_session_hold(struct rfcomm_session *s)
 {
@@ -315,8 +312,7 @@
 int  rfcomm_init_sockets(void);
 void rfcomm_cleanup_sockets(void);
 
-int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel,
-							struct rfcomm_dlc **d);
+int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel, struct rfcomm_dlc **d);
 
 /* ---- RFCOMM TTY ---- */
 #define RFCOMM_MAX_DEV  256
diff -ru final2/include/net/bluetooth/sco.h ics/include/net/bluetooth/sco.h
--- final2/include/net/bluetooth/sco.h	2014-08-29 08:20:15.312248000 +0200
+++ ics/include/net/bluetooth/sco.h	2013-04-19 11:37:14.000000000 +0200
@@ -23,9 +23,6 @@
    SOFTWARE IS DISCLAIMED.
 */
 
-#ifdef CONFIG_BT_MGMT
-#include "sco_mgmt.h"
-#else
 #ifndef __SCO_H
 #define __SCO_H
 
@@ -42,6 +39,7 @@
 	sa_family_t	sco_family;
 	bdaddr_t	sco_bdaddr;
 	__u16		sco_pkt_type;
+	__s8		is_wbs;
 };
 
 /* SCO socket options */
@@ -83,4 +81,3 @@
 };
 
 #endif /* __SCO_H */
-#endif /* CONFIG_BT_MGMT */
Nur in final2/include/net/bluetooth: sco_mgmt.h.
diff -ru final2/include/net/bluetooth/smp.h ics/include/net/bluetooth/smp.h
--- final2/include/net/bluetooth/smp.h	2014-08-29 08:16:36.116241000 +0200
+++ ics/include/net/bluetooth/smp.h	2013-04-19 11:37:14.000000000 +0200
@@ -19,9 +19,7 @@
    COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
    SOFTWARE IS DISCLAIMED.
 */
-#ifdef CONFIG_BT_MGMT
-#include "smp_mgmt.h"
-#else
+
 #ifndef __SMP_H
 #define __SMP_H
 
@@ -57,6 +55,13 @@
 #define SMP_AUTH_BONDING	0x01
 #define SMP_AUTH_MITM		0x04
 
+#define SMP_JUST_WORKS		0x00
+#define SMP_JUST_CFM		0x01
+#define SMP_REQ_PASSKEY		0x02
+#define SMP_CFM_PASSKEY		0x03
+#define SMP_REQ_OOB		0x04
+#define SMP_OVERLAP		0xFF
+
 #define SMP_CMD_PAIRING_CONFIRM	0x03
 struct smp_cmd_pairing_confirm {
 	__u8	confirm_val[16];
@@ -120,8 +125,7 @@
 /* SMP Commands */
 int smp_conn_security(struct l2cap_conn *conn, __u8 sec_level);
 int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb);
-int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);
+int smp_link_encrypt_cmplt(struct l2cap_conn *conn, __u8 status, __u8 encrypt);
+void smp_timeout(unsigned long l2cap_conn);
 
 #endif /* __SMP_H */
-
-#endif /* BT_MGMT */
Nur in final2/include/net/bluetooth: smp_mgmt.h.
Nur in final2/include: sec_feature.
diff -ru final2/init/main.c ics/init/main.c
--- final2/init/main.c	2014-08-29 08:16:36.180241000 +0200
+++ ics/init/main.c	2013-04-19 11:37:14.000000000 +0200
@@ -377,10 +377,6 @@
 	cpu_idle();
 }
 
-unsigned int kernel_uart_flag = 0;
-unsigned int board_hw_revision;
-unsigned int in_recovery_mode = 0;
-
 /* Check for early params. */
 static int __init do_early_param(char *param, char *val)
 {
@@ -397,50 +393,6 @@
 		}
 	}
 	/* We accept everything at this stage. */
-    if ((strcmp(param, "console") == 0 ) && (( strcmp(val, "NULL") == 0 ) || (strcmp(val, "null") == 0)))
-		kernel_uart_flag = 1;
-
-	// add board_hw_revision
-	if ( (strcmp(param, "hw") == 0 ) )
-	{
-		if (strcmp(val, "1") == 0)
-			board_hw_revision = 1;
-		else if (strcmp(val, "2") == 0)
-			board_hw_revision = 2;
-		else if (strcmp(val, "3") == 0)
-			board_hw_revision = 3;
-		else if (strcmp(val, "4") == 0)
-			board_hw_revision = 4;
-		else if (strcmp(val, "5") == 0)
-			board_hw_revision = 5;
-		else if (strcmp(val, "6") == 0)
-			board_hw_revision = 6;
-		else if (strcmp(val, "7") == 0)
-			board_hw_revision = 7;
-		else	
-			board_hw_revision = 0;
-
-#if defined(CONFIG_MACH_TREBON)
-		printk("Trebon H/W revision : 0x0%d\n", board_hw_revision);
-#elif defined(CONFIG_MACH_GEIM)
-		printk("Geim H/W revision : 0x0%d\n", board_hw_revision);
-#elif defined(CONFIG_MACH_JENA)
-		printk("Jena H/W revision : 0x0%d\n", board_hw_revision);
-#elif defined(CONFIG_MACH_AMAZING)
-		printk("Amazing H/W revision : 0x0%d\n", board_hw_revision);
-#elif defined(CONFIG_MACH_AMAZING_CDMA)
-		printk("Amazing_cdma H/W revision : 0x0%d\n", board_hw_revision);
-#elif defined(CONFIG_MACH_KYLE)
-		printk("Kyle H/W revision : 0x0%d\n", board_hw_revision);
-#endif		
-	}
-
-	if ( (strcmp(param, "recovery") == 0 ) )
-	{
-		if (strcmp(val, "1") == 0)
-			in_recovery_mode = 1;
-	}
-
 	return 0;
 }
 
diff -ru final2/kernel/cgroup.c ics/kernel/cgroup.c
--- final2/kernel/cgroup.c	2014-08-29 08:16:36.196241000 +0200
+++ ics/kernel/cgroup.c	2013-04-19 11:37:14.000000000 +0200
@@ -2543,8 +2543,7 @@
 	if (err)
 		return err;
 	cft = __d_cft(file->f_dentry);
-	if (!cft)
-		return -ENODEV;
+
 	if (cft->read_map || cft->read_seq_string) {
 		struct cgroup_seqfile_state *state =
 			kzalloc(sizeof(*state), GFP_USER);
diff -ru final2/kernel/hrtimer.c ics/kernel/hrtimer.c
--- final2/kernel/hrtimer.c	2014-08-29 08:16:36.228241000 +0200
+++ ics/kernel/hrtimer.c	2013-04-19 11:37:14.000000000 +0200
@@ -50,8 +50,6 @@
 
 #include <trace/events/timer.h>
 
-#include <linux/sec_debug.h>
-
 /*
  * The timer bases:
  *
@@ -1218,9 +1216,6 @@
 	raw_spin_unlock(&cpu_base->lock);
 	trace_hrtimer_expire_entry(timer, now);
 	restart = fn(timer);
-#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
-	sec_debug_timer_log(1111, (int)irqs_disabled(), (void *)fn);
-#endif /* CONFIG_SEC_DEBUG_SCHED_LOG */
 	trace_hrtimer_expire_exit(timer);
 	raw_spin_lock(&cpu_base->lock);
 
diff -ru final2/kernel/irq/handle.c ics/kernel/irq/handle.c
--- final2/kernel/irq/handle.c	2014-08-29 08:16:36.228241000 +0200
+++ ics/kernel/irq/handle.c	2013-04-19 11:37:14.000000000 +0200
@@ -19,7 +19,6 @@
 #include <trace/events/irq.h>
 
 #include "internals.h"
-#include <linux/sec_debug.h>
 
 /**
  * handle_bad_irq - handle spurious and unhandled irqs
@@ -122,19 +121,11 @@
 
 	do {
 		irqreturn_t res;
-#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
-		sec_debug_irq_sched_log(irq, (void *)action->handler, 1);
-		sec_debug_timer_log(4444, (int)irqs_disabled(),\
-					(void *)action->handler);
-#endif /* CONFIG_SEC_DEBUG_SCHED_LOG */
+
 		trace_irq_handler_entry(irq, action);
 		res = action->handler(irq, action->dev_id);
 		trace_irq_handler_exit(irq, action, res);
-#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
-		sec_debug_timer_log(5555, (int)irqs_disabled(),\
-					(void *)action->handler);
-		sec_debug_irq_sched_log(irq, (void *)action->handler, 2);
-#endif /* CONFIG_SEC_DEBUG_SCHED_LOG */
+
 		if (WARN_ONCE(!irqs_disabled(),"irq %u handler %pF enabled interrupts\n",
 			      irq, action->handler))
 			local_irq_disable();
diff -ru final2/kernel/panic.c ics/kernel/panic.c
--- final2/kernel/panic.c	2014-08-29 08:16:36.264241000 +0200
+++ ics/kernel/panic.c	2013-04-19 11:37:14.000000000 +0200
@@ -23,7 +23,6 @@
 #include <linux/init.h>
 #include <linux/nmi.h>
 #include <linux/dmi.h>
-#include <asm/cacheflush.h>
 
 #define PANIC_TIMER_STEP 100
 #define PANIC_BLINK_SPD 18
@@ -56,15 +55,6 @@
 long (*panic_blink)(int state);
 EXPORT_SYMBOL(panic_blink);
 
-#if defined(CONFIG_MACH_TREBON) || defined(CONFIG_MACH_AMAZING) \
-	|| defined(CONFIG_MACH_AMAZING_CDMA) || defined(CONFIG_MACH_KYLE)
-#include "../arch/arm/mach-msm/smd_private.h"
-#include "../arch/arm/mach-msm/proc_comm.h"
-#include <mach/msm_iomap-7xxx.h>
-#include <mach/msm_iomap.h>
-#include <asm/io.h>
-
-#endif
 /**
  *	panic - halt the system
  *	@fmt: The text string to print
@@ -73,11 +63,7 @@
  *
  *	This function never returns.
  */
-#ifdef CONFIG_APPLY_GA_SOLUTION
-extern void dump_all_task_info();
-extern void dump_cpu_stat();
-#endif
-NORET_TYPE void panic(const char *fmt, ...)
+NORET_TYPE void panic(const char * fmt, ...)
 {
 	static char buf[1024];
 	va_list args;
@@ -96,53 +82,11 @@
 	va_start(args, fmt);
 	vsnprintf(buf, sizeof(buf), fmt, args);
 	va_end(args);
-	printk(KERN_EMERG "Kernel panic - not syncing: %s\n", buf);
+	printk(KERN_EMERG "Kernel panic - not syncing: %s\n",buf);
 #ifdef CONFIG_DEBUG_BUGVERBOSE
 	dump_stack();
 #endif
 
-#if defined(CONFIG_SEC_DEBUG)
-	do {
-		extern void sec_save_final_context(void);
-		sec_save_final_context();
-	} while (0);
-#endif
-
-#ifdef CONFIG_APPLY_GA_SOLUTION
-	dump_all_task_info();
-	dump_cpu_stat();
-#endif
-
-#if defined(CONFIG_SEC_DEBUG)
-	unsigned size;
-	samsung_vendor1_id *smem_vendor1 = (samsung_vendor1_id *) \
-			smem_get_entry(SMEM_ID_VENDOR1, &size);
-	if (smem_vendor1 && smem_vendor1->ram_dump_level) {
-		writel_relaxed(0xCCCC, MSM_SHARED_RAM_BASE + 0x30);
-	} else {
-		if (smem_vendor1)
-			smem_vendor1->silent_reset = 0xAEAEAEAE;
-		else
-			printk(KERN_EMERG "smem_vendor1 is NULL\n");
-	}
-
-	if (strncmp(buf, "[Crash Key]", 11) == 0)
-		memcpy(&(smem_vendor1->apps_dump.apps_string),\
-				"USER_FORCED_UPLOAD",\
-				sizeof("USER_FORCED_UPLOAD"));
-
-	else
-		memcpy(&(smem_vendor1->apps_dump.apps_string),\
-				"Kernel panic",\
-				sizeof("Kernel panic"));
-
-	printk(KERN_EMERG "[PANIC] call msm_proc_comm_reset_modem_now func\n");
-
-	flush_cache_all();
-	outer_flush_all();
-
-	msm_proc_comm_reset_modem_now();
-#endif
 	/*
 	 * If we have crashed and we have a crash kernel loaded let it handle
 	 * everything else.
diff -ru final2/kernel/power/consoleearlysuspend.c ics/kernel/power/consoleearlysuspend.c
--- final2/kernel/power/consoleearlysuspend.c	2014-08-29 08:16:36.272241000 +0200
+++ ics/kernel/power/consoleearlysuspend.c	2013-04-19 11:37:14.000000000 +0200
@@ -31,10 +31,8 @@
 	if (set_console(EARLY_SUSPEND_CONSOLE))
 		goto err;
 
-	tty_lock();
 	if (vt_waitactive(EARLY_SUSPEND_CONSOLE + 1))
 		pr_warning("console_early_suspend: Can't switch VCs.\n");
-	tty_unlock();
 	return;
 err:
 	pr_warning("console_early_suspend: Can't set console\n");
@@ -49,10 +47,8 @@
 		return;
 	}
 
-	tty_lock();
 	if (vt_waitactive(orig_fgconsole + 1))
 		pr_warning("console_late_resume: Can't switch VCs.\n");
-	tty_unlock();
 }
 
 static struct early_suspend console_early_suspend_desc = {
diff -ru final2/kernel/power/earlysuspend.c ics/kernel/power/earlysuspend.c
--- final2/kernel/power/earlysuspend.c	2014-08-29 08:16:36.272241000 +0200
+++ ics/kernel/power/earlysuspend.c	2013-04-19 11:37:14.000000000 +0200
@@ -19,9 +19,6 @@
 #include <linux/rtc.h>
 #include <linux/wakelock.h>
 #include <linux/workqueue.h>
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-#include <asm/atomic.h>
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 
 #include "power.h"
 
@@ -30,11 +27,7 @@
 	DEBUG_SUSPEND = 1U << 2,
 	DEBUG_VERBOSE = 1U << 3,
 };
-static int debug_mask = DEBUG_USER_STATE | DEBUG_SUSPEND;
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-atomic_t optimize_comp_on = ATOMIC_INIT(0);
-EXPORT_SYMBOL(optimize_comp_on);
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
+static int debug_mask = DEBUG_USER_STATE;
 module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
 
 static DEFINE_MUTEX(early_suspend_lock);
@@ -85,9 +78,6 @@
 
 	mutex_lock(&early_suspend_lock);
 	spin_lock_irqsave(&state_lock, irqflags);
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-	atomic_set(&optimize_comp_on, 1);
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 	if (state == SUSPEND_REQUESTED)
 		state |= SUSPENDED;
 	else
@@ -128,9 +118,6 @@
 
 	mutex_lock(&early_suspend_lock);
 	spin_lock_irqsave(&state_lock, irqflags);
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-	atomic_set(&optimize_comp_on, 0);
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 	if (state == SUSPENDED)
 		state &= ~SUSPENDED;
 	else
@@ -170,7 +157,6 @@
 		struct rtc_time tm;
 		getnstimeofday(&ts);
 		rtc_time_to_tm(ts.tv_sec, &tm);
-		#if !defined(CONFIG_MACH_KYLE)
 		pr_info("request_suspend_state: %s (%d->%d) at %lld "
 			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n",
 			new_state != PM_SUSPEND_ON ? "sleep" : "wakeup",
@@ -178,7 +164,6 @@
 			ktime_to_ns(ktime_get()),
 			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
 			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
-		#endif
 	}
 	if (!old_sleep && new_state != PM_SUSPEND_ON) {
 		state |= SUSPEND_REQUESTED;
diff -ru final2/kernel/power/main.c ics/kernel/power/main.c
--- final2/kernel/power/main.c	2014-08-29 08:16:36.272241000 +0200
+++ ics/kernel/power/main.c	2013-04-19 11:37:14.000000000 +0200
@@ -14,9 +14,6 @@
 #include <linux/workqueue.h>
 
 #include "power.h"
-#ifdef CONFIG_SEC_DVFS
-#include <linux/cpufreq.h>
-#endif
 
 DEFINE_MUTEX(pm_mutex);
 
@@ -316,218 +313,6 @@
 power_attr(wake_unlock);
 #endif
 
-#ifdef CONFIG_SEC_DVFS
-DEFINE_MUTEX(dvfs_mutex);
-static unsigned long dvfs_id;
-static unsigned long apps_min_freq = MIN_FREQ_LIMIT;
-static unsigned long apps_max_freq = MAX_FREQ_LIMIT;
-static unsigned long thermald_max_freq = MAX_FREQ_LIMIT;
-
-static unsigned long touch_min_freq = MAX_TOUCH_LIMIT;
-static unsigned long unicpu_max_freq = MAX_UNICPU_LIMIT;
-
-static int verify_cpufreq_target(unsigned int target)
-{
-	int i;
-	struct cpufreq_frequency_table *table;
-
-	table = cpufreq_frequency_get_table(BOOT_CPU);
-	if (table == NULL)
-		return -EFAULT;
-
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		if (table[i].frequency < MIN_FREQ_LIMIT ||
-			table[i].frequency > MAX_FREQ_LIMIT)
-			continue;
-
-		if (target == table[i].frequency)
-			return 0;
-	}
-
-	return -EINVAL;
-}
-
-int set_freq_limit(unsigned long id, unsigned int freq)
-{
-	int ret = 0;
-	unsigned int min = MIN_FREQ_LIMIT;
-	unsigned int max = MAX_FREQ_LIMIT;
-	unsigned int cur = 0;
-
-	if (id < 0)
-		return -EINVAL;
-
-	if (freq != 0 && freq != -1 && verify_cpufreq_target(freq))
-		return -EINVAL;
-
-	mutex_lock(&dvfs_mutex);
-
-	if (freq == -1)
-		dvfs_id &= ~id;
-	else
-		dvfs_id |= id;
-
-	/* update freq for apps/thermald */
-	if (id == DVFS_APPS_MIN_ID)
-		apps_min_freq = freq;
-	else if (id == DVFS_APPS_MAX_ID)
-		apps_max_freq = freq;
-	else if (id == DVFS_THERMALD_ID)
-		thermald_max_freq = freq;
-	else if (id == DVFS_TOUCH_ID)
-		touch_min_freq = freq;
-	/* set min - apps */
-	if (dvfs_id & DVFS_APPS_MIN_ID && min < apps_min_freq)
-		min = apps_min_freq;
-	if (dvfs_id & DVFS_TOUCH_ID && min < touch_min_freq)
-		min = touch_min_freq;
-
-	/* set max */
-	if (dvfs_id & DVFS_APPS_MAX_ID && max > apps_max_freq)
-		max = apps_max_freq;
-	if (dvfs_id & DVFS_THERMALD_ID && max > thermald_max_freq)
-		max = thermald_max_freq;
-	if (dvfs_id & DVFS_UNICPU_ID && max > unicpu_max_freq)
-		max = unicpu_max_freq;
-
-	/* check min max*/
-	if (min > max)
-		min = max;
-
-	/* update */
-	set_min_lock(min);
-	set_max_lock(max);
-	#if !defined(CONFIG_MACH_KYLE)
-	pr_info("%s: 0x%x %d, min %d, max %d\n",
-				__func__, id, freq, min, max);
-	#endif
-
-	/* need to update now */
-	if (id & UPDATE_NOW_BITS) {
-		int cpu;
-
-		for_each_online_cpu(cpu)
-		{
-			cur = cpufreq_quick_get(cpu);
-			if (cur) {
-				struct cpufreq_policy policy;
-				policy.cpu = cpu;
-
-				if (cur < min)
-					cpufreq_driver_target(&policy, min,
-					CPUFREQ_RELATION_H);
-				else if (cur > max)
-					cpufreq_driver_target(&policy, max,
-					CPUFREQ_RELATION_L);
-			}
-		}
-	}
-
-	mutex_unlock(&dvfs_mutex);
-
-	return 0;
-}
-
-static ssize_t cpufreq_min_limit_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf)
-{
-	int freq;
-
-	freq = get_min_lock();
-	if (!freq)
-		freq = -1;
-
-	return snprintf(buf, 20, "%d\n", freq);
-}
-
-static ssize_t cpufreq_min_limit_store(struct kobject *kobj,
-					struct kobj_attribute *attr,
-					const char *buf, size_t n)
-{
-	int freq_min_limit;
-
-	sscanf(buf, "%d", &freq_min_limit);
-
-	set_freq_limit(DVFS_APPS_MIN_ID, freq_min_limit);
-#ifdef CONFIG_SEC_DVFS_DUAL
-	if (freq_min_limit == MAX_FREQ_LIMIT)
-		dual_boost(1);
-	else
-		dual_boost(0);
-#endif
-	return n;
-}
-
-static ssize_t cpufreq_max_limit_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf)
-{
-	int freq;
-
-	freq = get_max_lock();
-	if (!freq)
-		freq = -1;
-
-	return snprintf(buf, 20, "%d\n", freq);
-}
-
-static ssize_t cpufreq_max_limit_store(struct kobject *kobj,
-					struct kobj_attribute *attr,
-					const char *buf, size_t n)
-{
-	int freq_max_limit;
-
-	sscanf(buf, "%d", &freq_max_limit);
-
-	set_freq_limit(DVFS_APPS_MAX_ID, freq_max_limit);
-
-	return n;
-}
-static ssize_t cpufreq_table_show(struct kobject *kobj,
-			struct kobj_attribute *attr, char *buf)
-{
-	ssize_t len = 0;
-	int i, count;
-	unsigned int freq;
-
-	struct cpufreq_frequency_table *table;
-
-	table = cpufreq_frequency_get_table(BOOT_CPU);
-	if (table == NULL)
-		return 0;
-
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++)
-		;
-
-	count = i;
-
-	for (i = count-1; i >= 0; i--) {
-		freq = table[i].frequency;
-
-		if (freq < MIN_FREQ_LIMIT || freq > MAX_FREQ_LIMIT)
-			continue;
-
-		len += snprintf(buf + len, 20, "%u ", freq);
-	}
-
-	len--;
-	len += snprintf(buf + len, 20, "\n");
-
-	return len;
-}
-
-static ssize_t cpufreq_table_store(struct kobject *kobj,
-					struct kobj_attribute *attr,
-					const char *buf, size_t n)
-{
-	pr_info("%s: Not supported\n", __func__);
-	return n;
-}
-
-power_attr(cpufreq_max_limit);
-power_attr(cpufreq_min_limit);
-power_attr(cpufreq_table);
-#endif
-
 static struct attribute * g[] = {
 	&state_attr.attr,
 #ifdef CONFIG_PM_TRACE
@@ -545,12 +330,6 @@
 	&wake_unlock_attr.attr,
 #endif
 #endif
-#ifdef CONFIG_SEC_DVFS
-	&cpufreq_min_limit_attr.attr,
-	&cpufreq_max_limit_attr.attr,
-	&cpufreq_table_attr.attr,
-#endif
-
 	NULL,
 };
 
@@ -575,9 +354,6 @@
 static int __init pm_init(void)
 {
 	int error = pm_start_workqueue();
-#ifdef CONFIG_SEC_DVFS
-	int dvfs_id = 0;
-#endif
 	if (error)
 		return error;
 	hibernate_image_size_init();
diff -ru final2/kernel/power/wakelock.c ics/kernel/power/wakelock.c
--- final2/kernel/power/wakelock.c	2014-08-29 08:16:36.300241000 +0200
+++ ics/kernel/power/wakelock.c	2013-04-19 11:37:14.000000000 +0200
@@ -31,7 +31,7 @@
 	DEBUG_EXPIRE = 1U << 3,
 	DEBUG_WAKE_LOCK = 1U << 4,
 };
-static int debug_mask = DEBUG_EXIT_SUSPEND | DEBUG_WAKEUP | DEBUG_SUSPEND;
+static int debug_mask = DEBUG_EXIT_SUSPEND | DEBUG_WAKEUP;
 module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
 
 #define WAKE_LOCK_TYPE_MASK              (0x0f)
@@ -286,10 +286,9 @@
 	int ret;
 
 	spin_lock(&suspend_sys_sync_lock);
-	suspend_sys_sync_count++;
 	ret = queue_work(suspend_sys_sync_work_queue, &suspend_sys_sync_work);
-	if (!ret)
-		suspend_sys_sync_count--;
+	if (ret)
+		suspend_sys_sync_count++;
 	spin_unlock(&suspend_sys_sync_lock);
 }
 
@@ -351,17 +350,9 @@
 
 	entry_event_num = current_event_num;
 	suspend_sys_sync_queue();
-
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("suspend: enter suspend\n");
 	getnstimeofday(&ts_entry);
-	if (debug_mask & DEBUG_SUSPEND) {
-		struct rtc_time tm;
-		rtc_time_to_tm(ts_entry.tv_sec, &tm);
-		pr_info("suspend: enter suspend, ret = %d "
-			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n", ret,
-			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
-			tm.tm_hour, tm.tm_min, tm.tm_sec, ts_entry.tv_nsec);
-	}
-
 	ret = pm_suspend(requested_suspend_state);
 	getnstimeofday(&ts_exit);
 
diff -ru final2/kernel/printk.c ics/kernel/printk.c
--- final2/kernel/printk.c	2014-08-29 08:16:36.300241000 +0200
+++ ics/kernel/printk.c	2013-04-19 11:37:14.000000000 +0200
@@ -168,26 +168,6 @@
 }
 #endif
 
-#ifdef CONFIG_APPLY_GA_SOLUTION
-/* Mark for GetLog */
-
-struct struct_kernel_log_mark {
-	u32 special_mark_1;
-	u32 special_mark_2;
-	u32 special_mark_3;
-	u32 special_mark_4;
-	void *p__log_buf;
-};
-
-static struct struct_kernel_log_mark kernel_log_mark = {
-	.special_mark_1 = (('*' << 24) | ('^' << 16) | ('^' << 8) | ('*' << 0)),
-	.special_mark_2 = (('I' << 24) | ('n' << 16) | ('f' << 8) | ('o' << 0)),
-	.special_mark_3 = (('H' << 24) | ('e' << 16) | ('r' << 8) | ('e' << 0)),
-	.special_mark_4 = (('k' << 24) | ('l' << 16) | ('o' << 8) | ('g' << 0)),
-	.p__log_buf = __log_buf+0x200000, 
-};
-#endif
-
 /* requested log_buf_len from kernel cmdline */
 static unsigned long __initdata new_log_buf_len;
 
@@ -220,13 +200,7 @@
 
 		mem = memblock_alloc(new_log_buf_len, PAGE_SIZE);
 		if (mem == MEMBLOCK_ERROR)
-		{
-#ifdef CONFIG_APPLY_GA_SOLUTION
-			/* Mark for GetLog */
-			kernel_log_mark.p__log_buf = __log_buf+0x200000;
-#endif
 			return;
-		}
 		new_log_buf = __va(mem);
 	} else {
 		new_log_buf = alloc_bootmem_nopanic(new_log_buf_len);
@@ -235,10 +209,6 @@
 	if (unlikely(!new_log_buf)) {
 		pr_err("log_buf_len: %ld bytes not available\n",
 			new_log_buf_len);
-#ifdef CONFIG_APPLY_GA_SOLUTION
-			/* Mark for GetLog */
-		kernel_log_mark.p__log_buf = __log_buf+0x200000;
-#endif
 		return;
 	}
 
@@ -265,11 +235,6 @@
 	pr_info("log_buf_len: %d\n", log_buf_len);
 	pr_info("early log buf free: %d(%d%%)\n",
 		free, (free * 100) / __LOG_BUF_LEN);
-
-#ifdef CONFIG_APPLY_GA_SOLUTION
-	/* Mark for GetLog */
-	kernel_log_mark.p__log_buf = __log_buf+0x200000;
-#endif
 }
 
 #ifdef CONFIG_BOOT_PRINTK_DELAY
diff -ru final2/kernel/ptrace.c ics/kernel/ptrace.c
--- final2/kernel/ptrace.c	2014-08-29 08:16:36.300241000 +0200
+++ ics/kernel/ptrace.c	2013-04-19 11:37:14.000000000 +0200
@@ -38,36 +38,6 @@
 	child->parent = new_parent;
 }
 
-/* Ensure that nothing can wake it up, even SIGKILL */
-static bool ptrace_freeze_traced(struct task_struct *task)
-{
-	bool ret = false;
-
-	spin_lock_irq(&task->sighand->siglock);
-	if (task_is_traced(task) && !__fatal_signal_pending(task)) {
-		task->state = __TASK_TRACED;
-		ret = true;
-	}
-	spin_unlock_irq(&task->sighand->siglock);
-
-	return ret;
-}
-
-static void ptrace_unfreeze_traced(struct task_struct *task)
-{
-	if (task->state != __TASK_TRACED)
-		return;
-
-	WARN_ON(!task->ptrace || task->parent != current);
-
-	spin_lock_irq(&task->sighand->siglock);
-	if (__fatal_signal_pending(task))
-		wake_up_state(task, __TASK_TRACED);
-	else
-		task->state = TASK_TRACED;
-	spin_unlock_irq(&task->sighand->siglock);
-}
-
 /**
  * __ptrace_unlink - unlink ptracee and restore its execution state
  * @child: ptracee to be unlinked
@@ -122,7 +92,7 @@
 	 * TASK_KILLABLE sleeps.
 	 */
 	if (child->group_stop & GROUP_STOP_PENDING || task_is_traced(child))
-		ptrace_signal_wake_up(child, true);
+		signal_wake_up(child, task_is_traced(child));
 
 	spin_unlock(&child->sighand->siglock);
 }
@@ -142,29 +112,23 @@
 	 * be changed by us so it's not changing right after this.
 	 */
 	read_lock(&tasklist_lock);
-	if (child->ptrace && child->parent == current) {
-		WARN_ON(child->state == __TASK_TRACED);
+	if ((child->ptrace & PT_PTRACED) && child->parent == current) {
 		/*
 		 * child->sighand can't be NULL, release_task()
 		 * does ptrace_unlink() before __exit_signal().
 		 */
-		if (kill || ptrace_freeze_traced(child))
+		spin_lock_irq(&child->sighand->siglock);
+		WARN_ON_ONCE(task_is_stopped(child));
+		if (task_is_traced(child) || kill)
 			ret = 0;
+		spin_unlock_irq(&child->sighand->siglock);
 	}
 	read_unlock(&tasklist_lock);
 
-	if (!ret && !kill) {
-		if (!wait_task_inactive(child, __TASK_TRACED)) {
-			/*
-			 * This can only happen if may_ptrace_stop() fails and
-			 * ptrace_stop() changes ->state back to TASK_RUNNING,
-			 * so we should not worry about leaking __TASK_TRACED.
-			 */
-			WARN_ON(child->state == __TASK_TRACED);
-			ret = -ESRCH;
-		}
-	}
+	if (!ret && !kill)
+		ret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;
 
+	/* All systems go.. */
 	return ret;
 }
 
@@ -281,7 +245,7 @@
 	 */
 	if (task_is_stopped(task)) {
 		task->group_stop |= GROUP_STOP_PENDING | GROUP_STOP_TRAPPING;
-		signal_wake_up_state(task, __TASK_STOPPED);
+		signal_wake_up(task, 1);
 		wait_trap = true;
 	}
 
@@ -813,8 +777,6 @@
 		goto out_put_task_struct;
 
 	ret = arch_ptrace(child, request, addr, data);
-	if (ret || request != PTRACE_DETACH)
-		ptrace_unfreeze_traced(child);
 
  out_put_task_struct:
 	put_task_struct(child);
@@ -953,11 +915,8 @@
 	}
 
 	ret = ptrace_check_attach(child, request == PTRACE_KILL);
-	if (!ret) {
+	if (!ret)
 		ret = compat_arch_ptrace(child, request, addr, data);
-		if (ret || request != PTRACE_DETACH)
-			ptrace_unfreeze_traced(child);
-	}
 
  out_put_task_struct:
 	put_task_struct(child);
diff -ru final2/kernel/resource.c ics/kernel/resource.c
--- final2/kernel/resource.c	2014-08-29 08:16:36.312241000 +0200
+++ ics/kernel/resource.c	2013-04-19 11:37:14.000000000 +0200
@@ -1056,7 +1056,7 @@
 {
 	struct resource *p = &iomem_resource;
 	int err = 0;
-	loff_t l = 0;
+	loff_t l;
 
 	read_lock(&resource_lock);
 	for (p = p->child; p ; p = r_next(NULL, p, &l)) {
diff -ru final2/kernel/sched.c ics/kernel/sched.c
--- final2/kernel/sched.c	2014-08-29 08:16:36.312241000 +0200
+++ ics/kernel/sched.c	2013-04-19 11:37:14.000000000 +0200
@@ -84,7 +84,6 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/sched.h>
 
-#include <linux/sec_debug.h>
 /*
  * Convert user-nice values [ -20 ... 0 ... 19 ]
  * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
@@ -4285,9 +4284,6 @@
 		 */
 		cpu = smp_processor_id();
 		rq = cpu_rq(cpu);
-#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
-		sec_debug_task_sched_log(cpu, rq->curr);
-#endif
 	} else
 		raw_spin_unlock_irq(&rq->lock);
 
diff -ru final2/kernel/signal.c ics/kernel/signal.c
--- final2/kernel/signal.c	2014-08-29 08:16:36.320241000 +0200
+++ ics/kernel/signal.c	2013-04-19 11:37:14.000000000 +0200
@@ -631,17 +631,23 @@
  * No need to set need_resched since signal event passing
  * goes through ->blocked
  */
-void signal_wake_up_state(struct task_struct *t, unsigned int state)
+void signal_wake_up(struct task_struct *t, int resume)
 {
+	unsigned int mask;
+
 	set_tsk_thread_flag(t, TIF_SIGPENDING);
+
 	/*
-	 * TASK_WAKEKILL also means wake it up in the stopped/traced/killable
+	 * For SIGKILL, we want to wake it up in the stopped/traced/killable
 	 * case. We don't check t->state here because there is a race with it
 	 * executing another processor and just now entering stopped state.
 	 * By using wake_up_state, we ensure the process will wake up and
 	 * handle its death signal.
 	 */
-	if (!wake_up_state(t, state | TASK_INTERRUPTIBLE))
+	mask = TASK_INTERRUPTIBLE;
+	if (resume)
+		mask |= TASK_WAKEKILL;
+	if (!wake_up_state(t, mask))
 		kick_process(t);
 }
 
@@ -1669,10 +1675,6 @@
 	 * If SIGKILL was already sent before the caller unlocked
 	 * ->siglock we must see ->core_state != NULL. Otherwise it
 	 * is safe to enter schedule().
-	 *
-	 * This is almost outdated, a task with the pending SIGKILL can't
-	 * block in TASK_TRACED. But PTRACE_EVENT_EXIT can be reported
-	 * after SIGKILL was already dequeued.
 	 */
 	if (unlikely(current->mm->core_state) &&
 	    unlikely(current->mm == current->parent->mm))
@@ -1804,7 +1806,6 @@
 		if (gstop_done)
 			do_notify_parent_cldstop(current, false, why);
 
-		/* tasklist protects us from ptrace_freeze_traced() */
 		__set_current_state(TASK_RUNNING);
 		if (clear_code)
 			current->exit_code = 0;
@@ -1901,7 +1902,7 @@
 		sig->group_stop_count = 1;
 		for (t = next_thread(current); t != current;
 		     t = next_thread(t)) {
-				t->group_stop &= ~GROUP_STOP_SIGMASK;
+			t->group_stop &= ~GROUP_STOP_SIGMASK;
 			/*
 			 * Setting state to TASK_STOPPED for a group
 			 * stop is always done with the siglock held,
diff -ru final2/kernel/softirq.c ics/kernel/softirq.c
--- final2/kernel/softirq.c	2014-08-29 08:16:36.320241000 +0200
+++ ics/kernel/softirq.c	2013-04-19 11:37:14.000000000 +0200
@@ -29,8 +29,6 @@
 #include <trace/events/irq.h>
 
 #include <asm/irq.h>
-
-#include <linux/sec_debug.h>
 /*
    - No shared variables, all the data are CPU local.
    - If a softirq needs serialization, let it serialize itself
@@ -237,10 +235,6 @@
 			kstat_incr_softirqs_this_cpu(vec_nr);
 
 			trace_softirq_entry(vec_nr);
-#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
-			sec_debug_timer_log(6666, (int)irqs_disabled(),\
-					(void *)h->action);
-#endif /* CONFIG_SEC_DEBUG_SCHED_LOG */
 			h->action(h);
 			trace_softirq_exit(vec_nr);
 			if (unlikely(prev_count != preempt_count())) {
@@ -466,13 +460,7 @@
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
-#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
-				sec_debug_irq_sched_log(-1, t->func, 3);
-#endif /* CONFIG_SEC_DEBUG_SCHED_LOG */
 				t->func(t->data);
-#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
-				sec_debug_irq_sched_log(-1, t->func, 4);
-#endif /* CONFIG_SEC_DEBUG_SCHED_LOG */
 				tasklet_unlock(t);
 				continue;
 			}
diff -ru final2/kernel/sys.c ics/kernel/sys.c
--- final2/kernel/sys.c	2014-08-29 08:20:15.312248000 +0200
+++ ics/kernel/sys.c	2013-04-19 11:37:14.000000000 +0200
@@ -53,10 +53,6 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unistd.h>
-#if !defined(CONFIG_MACH_KYLE)
-#include "../drivers/dpram/dpram.h"
-#endif
-
 
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
@@ -376,7 +372,6 @@
  *
  *	Shutdown everything and perform a clean system power_off.
  */
-struct timer_list power_off_timer;
 void kernel_power_off(void)
 {
 	kernel_shutdown_prepare(SYSTEM_POWER_OFF);
@@ -385,11 +380,6 @@
 	disable_nonboot_cpus();
 	syscore_shutdown();
 	printk(KERN_EMERG "Power down.\n");
-
-#if (defined(CONFIG_MACH_TREBON) || defined(CONFIG_MACH_AMAZING)) && defined(CONFIG_SEC_DEBUG) && defined(CONFIG_DPRAM)
-	power_down_registertimer(&power_off_timer, POWER_DOWN_TIME);
-#endif 
-
 	kmsg_dump(KMSG_DUMP_POWEROFF);
 	machine_power_off();
 }
diff -ru final2/kernel/timer.c ics/kernel/timer.c
--- final2/kernel/timer.c	2014-08-29 08:16:36.336241000 +0200
+++ ics/kernel/timer.c	2013-04-19 11:37:14.000000000 +0200
@@ -50,8 +50,6 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/timer.h>
 
-#include <linux/sec_debug.h>
-
 u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;
 
 EXPORT_SYMBOL(jiffies_64);
@@ -1065,9 +1063,6 @@
 
 	trace_timer_expire_entry(timer);
 	fn(data);
-#ifdef CONFIG_SEC_DEBUG_SCHED_LOG
-	sec_debug_timer_log(3333, (int)irqs_disabled(), (void *)fn);
-#endif /* CONFIG_SEC_DEBUG_SCHED_LOG */
 	trace_timer_expire_exit(timer);
 
 	lock_map_release(&lockdep_map);
diff -ru final2/lib/genalloc.c ics/lib/genalloc.c
--- final2/lib/genalloc.c	2014-08-29 08:20:15.312248000 +0200
+++ ics/lib/genalloc.c	2013-04-19 11:37:14.000000000 +0200
@@ -124,21 +124,18 @@
 {
 	struct list_head *_chunk;
 	struct gen_pool_chunk *chunk;
-	phys_addr_t paddr = -1;
 
 	read_lock(&pool->lock);
 	list_for_each(_chunk, &pool->chunks) {
 		chunk = list_entry(_chunk, struct gen_pool_chunk, next_chunk);
 
 		if (addr >= chunk->start &&
-		    addr < (chunk->start + chunk->size)) {
-			paddr = chunk->phys_addr + addr - chunk->start;
-			break;
-			}
+		    addr < (chunk->start + chunk->size))
+			return chunk->phys_addr + addr - chunk->start;
 	}
 	read_unlock(&pool->lock);
 
-	 return paddr;
+	return -1;
 }
 EXPORT_SYMBOL(gen_pool_virt_to_phys);
 
diff -ru final2/lib/Kconfig.debug ics/lib/Kconfig.debug
--- final2/lib/Kconfig.debug	2014-08-29 08:16:36.352241000 +0200
+++ ics/lib/Kconfig.debug	2013-04-19 11:37:14.000000000 +0200
@@ -466,7 +466,7 @@
 config DEBUG_PREEMPT
 	bool "Debug preemptible kernel"
 	depends on DEBUG_KERNEL && PREEMPT && TRACE_IRQFLAGS_SUPPORT
-	default n
+	default y
 	help
 	  If you say Y here then the kernel will use a debug variant of the
 	  commonly used smp_processor_id() function and will print warnings
diff -ru final2/lib/klist.c ics/lib/klist.c
--- final2/lib/klist.c	2014-08-29 08:16:36.356241000 +0200
+++ ics/lib/klist.c	2013-04-19 11:37:14.000000000 +0200
@@ -192,10 +192,11 @@
 	list_for_each_entry_safe(waiter, tmp, &klist_remove_waiters, list) {
 		if (waiter->node != n)
 			continue;
-		list_del(&waiter->list);
+
 		waiter->woken = 1;
 		mb();
 		wake_up_process(waiter->process);
+		list_del(&waiter->list);
 	}
 	spin_unlock(&klist_remove_lock);
 	knode_set_klist(n, NULL);
Nur in ics/: .mailmap.
diff -ru final2/Makefile ics/Makefile
--- final2/Makefile	2014-08-29 08:16:08.752240000 +0200
+++ ics/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -192,8 +192,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= arm
-CROSS_COMPILE	?= /opt/toolchains/arm-eabi-4.4.3/bin/arm-eabi-
+ARCH		?= $(SUBARCH)
+CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
diff -ru final2/mm/memory.c ics/mm/memory.c
--- final2/mm/memory.c	2014-08-29 08:16:36.404241000 +0200
+++ ics/mm/memory.c	2013-04-19 11:37:14.000000000 +0200
@@ -2304,53 +2304,6 @@
 }
 EXPORT_SYMBOL(remap_pfn_range);
 
-/**
- * vm_iomap_memory - remap memory to userspace
- * @vma: user vma to map to
- * @start: start of area
- * @len: size of area
- *
- * This is a simplified io_remap_pfn_range() for common driver use. The
- * driver just needs to give us the physical memory range to be mapped,
- * we'll figure out the rest from the vma information.
- *
- * NOTE! Some drivers might want to tweak vma->vm_page_prot first to get
- * whatever write-combining details or similar.
- */
-int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)
-{
-	unsigned long vm_len, pfn, pages;
-
-	/* Check that the physical memory area passed in looks valid */
-	if (start + len < start)
-		return -EINVAL;
-	/*
-	 * You *really* shouldn't map things that aren't page-aligned,
-	 * but we've historically allowed it because IO memory might
-	 * just have smaller alignment.
-	 */
-	len += start & ~PAGE_MASK;
-	pfn = start >> PAGE_SHIFT;
-	pages = (len + ~PAGE_MASK) >> PAGE_SHIFT;
-	if (pfn + pages < pfn)
-		return -EINVAL;
-
-	/* We start the mapping 'vm_pgoff' pages into the area */
-	if (vma->vm_pgoff > pages)
-		return -EINVAL;
-	pfn += vma->vm_pgoff;
-	pages -= vma->vm_pgoff;
-
-	/* Can we fit all of the mapping? */
-	vm_len = vma->vm_end - vma->vm_start;
-	if (vm_len >> PAGE_SHIFT > pages)
-		return -EINVAL;
-
-	/* Ok, let it rip */
-	return io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);
-}
-EXPORT_SYMBOL(vm_iomap_memory);
-
 static int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,
 				     unsigned long addr, unsigned long end,
 				     pte_fn_t fn, void *data)
diff -ru final2/mm/swapfile.c ics/mm/swapfile.c
--- final2/mm/swapfile.c	2014-08-29 08:16:36.452241000 +0200
+++ ics/mm/swapfile.c	2013-04-19 11:37:14.000000000 +0200
@@ -2014,159 +2014,6 @@
 	return nr_extents;
 }
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-int swapon(char *name, int swap_flags)
-{
-	struct swap_info_struct *p;
-
-	struct file *swap_file = NULL;
-	struct address_space *mapping;
-	int i;
-	int prio;
-	int error;
-	union swap_header *swap_header;
-	int nr_extents;
-	sector_t span;
-	unsigned long maxpages;
-	unsigned char *swap_map = NULL;
-	struct page *page = NULL;
-	struct inode *inode = NULL;
-
-	p = alloc_swap_info();
-	if (IS_ERR(p))
-		return PTR_ERR(p);
-
-	swap_file = filp_open(name, O_RDWR | O_LARGEFILE, 0);
-	if (IS_ERR(swap_file)) {
-		error = PTR_ERR(swap_file);
-		swap_file = NULL;
-		printk("swapon, filp_open failed\n");
-		goto bad_swap;
-	}
-
-
-	p->swap_file = swap_file;
-	mapping = swap_file->f_mapping;
-
-	for (i = 0; i < nr_swapfiles; i++) {
-		struct swap_info_struct *q = swap_info[i];
-
-		if (q == p || !q->swap_file)
-			continue;
-		if (mapping == q->swap_file->f_mapping) {
-			error = -EBUSY;
-			goto bad_swap;
-		}
-	}
-
-	inode = mapping->host;
-	/* If S_ISREG(inode->i_mode) will do mutex_lock(&inode->i_mutex); */
-	error = claim_swapfile(p, inode);
-	if (unlikely(error))
-		goto bad_swap;
-
-	/*
-	 * Read the swap header.
-	 */
-	if (!mapping->a_ops->readpage) {
-		error = -EINVAL;
-		goto bad_swap;
-	}
-	page = read_mapping_page(mapping, 0, swap_file);
-	if (IS_ERR(page)) {
-		error = PTR_ERR(page);
-		goto bad_swap;
-	}
-	swap_header = kmap(page);
-
-	maxpages = read_swap_header(p, swap_header, inode);
-	if (unlikely(!maxpages)) {
-		error = -EINVAL;
-		goto bad_swap;
-	}
-
-	/* OK, set up the swap map and apply the bad block list */
-	swap_map = vzalloc(maxpages);
-	if (!swap_map) {
-		error = -ENOMEM;
-		goto bad_swap;
-	}
-
-	error = swap_cgroup_swapon(p->type, maxpages);
-	if (error)
-		goto bad_swap;
-
-	nr_extents = setup_swap_map_and_extents(p, swap_header, swap_map,
-						maxpages, &span);
-	if (unlikely(nr_extents < 0)) {
-		error = nr_extents;
-		goto bad_swap;
-	}
-
-	if (p->bdev) {
-		if (blk_queue_nonrot(bdev_get_queue(p->bdev))) {
-			p->flags |= SWP_SOLIDSTATE;
-			p->cluster_next = 1 + (random32() % p->highest_bit);
-		}
-		if (discard_swap(p) == 0 && (swap_flags & SWAP_FLAG_DISCARD))
-			p->flags |= SWP_DISCARDABLE;
-	}
-
-	mutex_lock(&swapon_mutex);
-	prio = -1;
-	if (swap_flags & SWAP_FLAG_PREFER)
-		prio =
-		    (swap_flags & SWAP_FLAG_PRIO_MASK) >> SWAP_FLAG_PRIO_SHIFT;
-	enable_swap_info(p, prio, swap_map);
-
-	printk(KERN_INFO "Adding %uk swap on %s.  "
-	       "Priority:%d extents:%d across:%lluk %s%s\n",
-	       p->pages << (PAGE_SHIFT - 10), name, p->prio,
-	       nr_extents, (unsigned long long)span << (PAGE_SHIFT - 10),
-	       (p->flags & SWP_SOLIDSTATE) ? "SS" : "",
-	       (p->flags & SWP_DISCARDABLE) ? "D" : "");
-
-	mutex_unlock(&swapon_mutex);
-	atomic_inc(&proc_poll_event);
-	wake_up_interruptible(&proc_poll_wait);
-
-	if (S_ISREG(inode->i_mode))
-		inode->i_flags |= S_SWAPFILE;
-	error = 0;
-	goto out;
- bad_swap:
-	if (inode && S_ISBLK(inode->i_mode) && p->bdev) {
-		set_blocksize(p->bdev, p->old_block_size);
-		blkdev_put(p->bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);
-	}
-	destroy_swap_extents(p);
-	swap_cgroup_swapoff(p->type);
-	spin_lock(&swap_lock);
-	p->swap_file = NULL;
-	p->flags = 0;
-	spin_unlock(&swap_lock);
-	vfree(swap_map);
-	if (swap_file) {
-		if (inode && S_ISREG(inode->i_mode)) {
-			mutex_unlock(&inode->i_mutex);
-			inode = NULL;
-		}
-		filp_close(swap_file, NULL);
-	}
- out:
-	if (page && !IS_ERR(page)) {
-		kunmap(page);
-		page_cache_release(page);
-	}
-
-	if (inode && S_ISREG(inode->i_mode))
-		mutex_unlock(&inode->i_mutex);
-	return error;
-}
-
-EXPORT_SYMBOL(swapon);
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-
 SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)
 {
 	struct swap_info_struct *p;
diff -ru final2/mm/vmscan.c ics/mm/vmscan.c
--- final2/mm/vmscan.c	2014-08-29 08:16:36.460241000 +0200
+++ ics/mm/vmscan.c	2013-04-19 11:37:14.000000000 +0200
@@ -717,10 +717,7 @@
 /*
  * shrink_page_list() returns the number of reclaimed pages
  */
-#ifndef CONFIG_ZRAM_FOR_ANDROID
-static
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-unsigned long shrink_page_list(struct list_head *page_list,
+static unsigned long shrink_page_list(struct list_head *page_list,
 				      struct zone *zone,
 				      struct scan_control *sc)
 {
@@ -1017,40 +1014,6 @@
 	return ret;
 }
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-/**
- * isolate_lru_page_compcache - tries to isolate a page for compcache
- * @page: page to isolate from its LRU list
- *
- * Isolates a @page from an LRU list, clears PageLRU,but
- * does not adjusts the vmstat statistic
- * Returns 0 if the page was removed from an LRU list.
- * Returns -EBUSY if the page was not on an LRU list.
- */
-int isolate_lru_page_compcache(struct page *page)
-{
-	int ret = -EBUSY;
-
-	VM_BUG_ON(!page_count(page));
-
-	if (PageLRU(page)) {
-		struct zone *zone = page_zone(page);
-
-		spin_lock_irq(&zone->lru_lock);
-		if (PageLRU(page)) {
-			int lru = page_lru(page);
-			ret = 0;
-			get_page(page);
-			ClearPageLRU(page);
-			list_del(&page->lru);
-			mem_cgroup_del_lru_list(page, lru);
-		}
-		spin_unlock_irq(&zone->lru_lock);
-	}
-	return ret;
-}
-#endif
-
 /*
  * zone->lru_lock is heavily contended.  Some of the functions that
  * shrink the lists perform better by taking out a batch of pages
@@ -1214,10 +1177,7 @@
  * clear_active_flags() is a helper for shrink_active_list(), clearing
  * any active bits from the pages in the list.
  */
-#ifndef CONFIG_ZRAM_FOR_ANDROID
-static
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-unsigned long clear_active_flags(struct list_head *page_list,
+static unsigned long clear_active_flags(struct list_head *page_list,
 					unsigned int *count)
 {
 	int nr_active = 0;
@@ -1519,44 +1479,6 @@
 	return nr_reclaimed;
 }
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-unsigned long
-zone_id_shrink_pagelist(struct zone *zone, struct list_head *page_list)
-{
-	unsigned long nr_reclaimed = 0;
-	unsigned long nr_anon;
-	unsigned long nr_file;
-
-	struct scan_control sc = {
-		.gfp_mask = GFP_USER,
-		.may_writepage = 1,
-		.nr_to_reclaim = SWAP_CLUSTER_MAX,
-		.may_unmap = 1,
-		.may_swap = 1,
-		.swappiness = vm_swappiness,
-		.order = 0,
-		.mem_cgroup = NULL,
-		.nodemask = NULL,
-	};
-
-	spin_lock_irq(&zone->lru_lock);
-
-	update_isolated_counts(zone, &sc, &nr_anon, &nr_file, page_list);
-
-	spin_unlock_irq(&zone->lru_lock);
-
-	nr_reclaimed = shrink_page_list(page_list, zone, &sc);
-
-	__count_zone_vm_events(PGSTEAL, zone, nr_reclaimed);
-
-	putback_lru_pages(zone, &sc, nr_anon, nr_file, page_list);
-
-	return nr_reclaimed;
-}
-
-EXPORT_SYMBOL(zone_id_shrink_pagelist);
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-
 /*
  * This moves pages from the active list to the inactive list.
  *
Nur in final2/net: bluetooth_mgmt.
diff -ru final2/net/core/skbuff.c ics/net/core/skbuff.c
--- final2/net/core/skbuff.c	2014-08-29 08:16:36.572241000 +0200
+++ ics/net/core/skbuff.c	2013-04-19 11:37:14.000000000 +0200
@@ -326,8 +326,7 @@
 		if (skb_shinfo(skb)->nr_frags) {
 			int i;
 			for (i = 0; i < skb_shinfo(skb)->nr_frags; i++)
-			    if (skb_shinfo(skb)->frags[i].page)
-			        put_page(skb_shinfo(skb)->frags[i].page);
+				put_page(skb_shinfo(skb)->frags[i].page);
 		}
 
 		if (skb_has_frag_list(skb))
diff -ru final2/net/Kconfig ics/net/Kconfig
--- final2/net/Kconfig	2014-08-29 08:16:36.480241000 +0200
+++ ics/net/Kconfig	2013-04-19 11:37:14.000000000 +0200
@@ -313,7 +313,6 @@
 source "net/can/Kconfig"
 source "net/irda/Kconfig"
 source "net/bluetooth/Kconfig"
-source "net/bluetooth_mgmt/Kconfig"
 source "net/rxrpc/Kconfig"
 
 config FIB_RULES
diff -ru final2/net/Makefile ics/net/Makefile
--- final2/net/Makefile	2014-08-29 08:16:36.480241000 +0200
+++ ics/net/Makefile	2013-04-19 11:37:14.000000000 +0200
@@ -34,11 +34,7 @@
 obj-$(CONFIG_AX25)		+= ax25/
 obj-$(CONFIG_CAN)		+= can/
 obj-$(CONFIG_IRDA)		+= irda/
-#ifeq ($(CONFIG_BT_MGMT),y)
-obj-$(CONFIG_BT)		+= bluetooth_mgmt/
-#else
-#obj-$(CONFIG_BT)		+= bluetooth/
-#endif
+obj-$(CONFIG_BT)		+= bluetooth/
 obj-$(CONFIG_SUNRPC)		+= sunrpc/
 obj-$(CONFIG_AF_RXRPC)		+= rxrpc/
 obj-$(CONFIG_ATM)		+= atm/
@@ -52,15 +48,7 @@
 obj-$(CONFIG_IP_DCCP)		+= dccp/
 obj-$(CONFIG_IP_SCTP)		+= sctp/
 obj-$(CONFIG_RDS)		+= rds/
-ifeq ($(CONFIG_MACH_AMAZING),y)
-obj-$(CONFIG_WIRELESS)		+= wireless_ath/
-else ifeq ($(CONFIG_MACH_AMAZING_CDMA),y)
-obj-$(CONFIG_WIRELESS)		+= wireless_ath/
-else ifeq ($(CONFIG_MACH_KYLE),y)
-obj-$(CONFIG_WIRELESS)		+= wireless_ath/
-else
 obj-$(CONFIG_WIRELESS)		+= wireless/
-endif
 obj-$(CONFIG_MAC80211)		+= mac80211/
 obj-$(CONFIG_TIPC)		+= tipc/
 obj-$(CONFIG_NETLABEL)		+= netlabel/
Nur in final2/net: wireless_ath.
diff -ru final2/scripts/gcc-wrapper.py ics/scripts/gcc-wrapper.py
--- final2/scripts/gcc-wrapper.py	2014-08-29 08:20:15.312248000 +0200
+++ ics/scripts/gcc-wrapper.py	2013-04-19 11:37:14.000000000 +0200
@@ -30,6 +30,7 @@
 # Invoke gcc, looking for warnings, and causing a failure if there are
 # non-whitelisted warnings.
 
+import errno
 import re
 import os
 import sys
@@ -57,9 +58,10 @@
     "msm_sdcc.c:128",
     "nf_conntrack_netlink.c:790",
     "nf_nat_standalone.c:118",
-    "return_address.c:61",
+    "return_address.c:62",
     "soc-core.c:1719",
     "xt_log.h:50",
+    "vx6953.c:3124",
  ])
 
 # Capture the name of the object file, can find it.
@@ -70,16 +72,16 @@
     """Decode the message from gcc.  The messages we care about have a filename, and a warning"""
     line = line.rstrip('\n')
     m = warning_re.match(line)
-#    if m and m.group(2) not in allowed_warnings:
-#        print "error, forbidden warning:", m.group(2)
+    if m and m.group(2) not in allowed_warnings:
+        print "error, forbidden warning:", m.group(2)
 
         # If there is a warning, remove any object if it exists.
-#        if ofile:
-#            try:
-#                os.remove(ofile)
-#            except OSError:
-#                pass
-#        sys.exit(1)
+        if ofile:
+            try:
+                os.remove(ofile)
+            except OSError:
+                pass
+        sys.exit(1)
 
 def run_gcc():
     args = sys.argv[1:]
@@ -93,12 +95,20 @@
 
     compiler = sys.argv[0]
 
-    proc = subprocess.Popen(args, stderr=subprocess.PIPE)
-    for line in proc.stderr:
-        print line,
-        interpret_warning(line)
-
-    result = proc.wait()
+    try:
+        proc = subprocess.Popen(args, stderr=subprocess.PIPE)
+        for line in proc.stderr:
+            print line,
+            interpret_warning(line)
+
+        result = proc.wait()
+    except OSError as e:
+        result = e.errno
+        if result == errno.ENOENT:
+            print args[0] + ':',e.strerror
+            print 'Is your PATH set correctly?'
+        else:
+            print ' '.join(args), str(e)
 
     return result
 
